<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="preload" href="/favori-logo-blank.png" as="image" data-next-head=""/><meta name="title" content="chrome V8 引擎中的垃圾回收机制" data-next-head=""/><meta name="author" content="Favori" data-next-head=""/><link rel="icon" type="image/png" sizes="70x70" href="/favicon-70x70.png" data-next-head=""/><title data-next-head="">chrome V8 引擎中的垃圾回收机制</title><style data-next-head="">:root{--nextra-bg:250,250,250;}.dark{--nextra-bg:17,17,17;}</style><link rel="preload" href="/_next/static/css/552cfd626c7d3395.css" as="style"/><link rel="stylesheet" href="/_next/static/css/552cfd626c7d3395.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-7aa77703737d139f.js" defer=""></script><script src="/_next/static/chunks/framework-4e48f2cc6a39465a.js" defer=""></script><script src="/_next/static/chunks/main-d7c2d8830adc2477.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2ec274c3be73acea.js" defer=""></script><script src="/_next/static/chunks/2195-a5c3dde35c1c11c2.js" defer=""></script><script src="/_next/static/chunks/pages/posts/other/v8gc-b3cdca071d0c603c.js" defer=""></script><script src="/_next/static/liUDpDv9XeuZIQ0wA6cxc/_buildManifest.js" defer=""></script><script src="/_next/static/liUDpDv9XeuZIQ0wA6cxc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script>((e,t,r,n,o,a,i,s)=>{let l=document.documentElement,u=["light","dark"];function c(t){(Array.isArray(e)?e:[e]).forEach(e=>{let r="class"===e,n=r&&a?o.map(e=>a[e]||e):o;r?(l.classList.remove(...n),l.classList.add(t)):l.setAttribute(e,t)}),s&&u.includes(t)&&(l.style.colorScheme=t)}if(n)c(n);else try{let e=localStorage.getItem(t)||r,n=i&&"system"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e;c(n)}catch(e){}})("class","theme","system",null,["light","dark"],null,true,true)</script><div class="Layout_container__o59WT"><header class="Header_header__aO32P"><div class="Header_headerInner__np1cA"><div class="Header_nav__wk8Zc"><a class="Header_logo__Vr4sK" href="/"><img alt="Favori Logo" width="140" height="50" decoding="async" data-nimg="1" style="color:transparent" src="/favori-logo-blank.png"/></a></div><div class="Header_search__c61pn"></div><div class="Header_rightNav__NG1Lv"><button class="Header_themeButton__zM4Kv" aria-label="Toggle theme"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg></button><a href="https://github.com/yuanguandong" target="_blank" rel="noopener noreferrer" class="Header_navLink__Kg8GB"><svg height="20" viewBox="0 0 16 16" width="20" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg><span class="hidden md:inline ml-1">GitHub</span></a></div></div></header><main class="Layout_main__5FFfL"><article class="_container _prose max-md:_prose-sm dark:_prose-invert" dir="ltr"><h1>chrome V8 引擎中的垃圾回收机制</h1><div class="_mb-8 _flex _gap-3 _items-center"><div class="_not-prose _grow dark:_text-gray-400 _text-gray-600"><div class="_flex _flex-wrap _items-center _gap-1">Favori<!-- -->,<time dateTime="2022-03-03T00:00:00.000Z">Thu Mar 03 2022</time></div></div><div class="_flex _items-center _gap-3 print:_hidden"></div></div><p><img alt="V8gc" loading="lazy" width="1200" height="900" decoding="async" data-nimg="1" style="color:transparent;background-size:cover;background-position:50% 50%;background-repeat:no-repeat;background-image:url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 320 240&#x27;%3E%3Cfilter id=&#x27;b&#x27; color-interpolation-filters=&#x27;sRGB&#x27;%3E%3CfeGaussianBlur stdDeviation=&#x27;20&#x27;/%3E%3CfeColorMatrix values=&#x27;1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1&#x27; result=&#x27;s&#x27;/%3E%3CfeFlood x=&#x27;0&#x27; y=&#x27;0&#x27; width=&#x27;100%25&#x27; height=&#x27;100%25&#x27;/%3E%3CfeComposite operator=&#x27;out&#x27; in=&#x27;s&#x27;/%3E%3CfeComposite in2=&#x27;SourceGraphic&#x27;/%3E%3CfeGaussianBlur stdDeviation=&#x27;20&#x27;/%3E%3C/filter%3E%3Cimage width=&#x27;100%25&#x27; height=&#x27;100%25&#x27; x=&#x27;0&#x27; y=&#x27;0&#x27; preserveAspectRatio=&#x27;none&#x27; style=&#x27;filter: url(%23b);&#x27; href=&#x27;data:image/webp;base64,UklGRkIAAABXRUJQVlA4IDYAAACwAQCdASoIAAYAAkA4JaQAAxeTutgAAP75CPK9JqE7m5tf7h02nbkLrU7zi4TOZcSt9eBAAAA=&#x27;/%3E%3C/svg%3E&quot;)" src="/_next/static/media/hero.f2777d0d.webp"/></p>
<div class="img-desc">图：Peter Tarka</div>
<!-- -->
<h2 id="引言" class="subheading-h2">引言<a href="#引言" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>JavaScript 可以高效地运行在浏览器和 Nodejs 这两大宿主环境中，是因为背后有强大的 V8 引擎在为其保驾护航，甚至成就了 Chrome 在浏览器中的霸主地位。</p>
<p>正是因为有 V8 引擎的存在才会有前端今天的繁荣生态</p>
<p>感谢V8 🙇</p>
<p>V8 引擎为了追求极致的性能和更好的用户体验，为我们做了太多太多。</p>
<p>V8 引擎努力降低整体的内存占用和提升到更高的运行性能。</p>
<p>我们来看一下 V8 引擎中的垃圾回收机制</p>
<h2 id="引用法" class="subheading-h2">引用法<a href="#引用法" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<h3 id="概念" class="subheading-h3">概念<a href="#概念" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h3>
<p>判断一个对象的引用数，引用数为 0 就回收，引用数大于 0 就不回收</p>
<div class="nextra-code _relative [&amp;:not(:first-child)]:_mt-6"><pre class="nextra-focus _overflow-x-auto _subpixel-antialiased _text-[.9em] _bg-white dark:_bg-black _py-4 _ring-1 _ring-inset _ring-gray-300 dark:_ring-neutral-700 contrast-more:_ring-gray-900 contrast-more:dark:_ring-gray-50 contrast-more:_contrast-150 _rounded-md _not-prose" tabindex="0"><code class="nextra-code" dir="ltr"><span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// 在堆中创建一个对象，foo是这个对象的引用</span></span>
<span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> };</span></span>
<span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// 把引用地址改为null, { name: &quot;foo&quot; }对象在堆中没有被栈中引用，那么这块堆中的内存就会被回收</span></span>
<span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span></code></pre><div class="_opacity-0 _transition [div:hover&gt;&amp;]:_opacity-100 focus-within:_opacity-100 _flex _gap-1 _absolute _right-4 _top-2"><button class="_transition _border _border-gray-300 dark:_border-neutral-700 contrast-more:_border-gray-900 contrast-more:dark:_border-gray-50 _rounded-md _p-1.5 md:_hidden" title="Toggle word wrap" type="button" data-headlessui-state=""><svg viewBox="0 0 24 24" fill="currentColor" height="16"><path d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3l3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"></path></svg></button><button class="_transition _border _border-gray-300 dark:_border-neutral-700 contrast-more:_border-gray-900 contrast-more:dark:_border-gray-50 _rounded-md _p-1.5" title="Copy code" type="button" data-headlessui-state=""><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" height="16" class="nextra-copy-icon"><rect x="9" y="9" width="13" height="13" rx="2"></rect><path d="M5 15H4C2.89543 15 2 14.1046 2 13V4C2 2.89543 2.89543 2 4 2H13C14.1046 2 15 2.89543 15 4V5"></path></svg></button></div></div>
<h3 id="缺陷" class="subheading-h3">缺陷<a href="#缺陷" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h3>
<p>如果对象之间有相互引用关系，并且引用关系一直存在，那么就不会被回收，从而造成内存泄漏</p>
<div class="nextra-code _relative [&amp;:not(:first-child)]:_mt-6"><pre class="nextra-focus _overflow-x-auto _subpixel-antialiased _text-[.9em] _bg-white dark:_bg-black _py-4 _ring-1 _ring-inset _ring-gray-300 dark:_ring-neutral-700 contrast-more:_ring-gray-900 contrast-more:dark:_ring-gray-50 contrast-more:_contrast-150 _rounded-md _not-prose" tabindex="0"><code class="nextra-code" dir="ltr"><span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">() {</span></span>
<span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> obj1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {};</span></span>
<span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> obj2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {};</span></span>
<span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  obj1.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> obj2;</span></span>
<span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  obj2.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> obj1;</span></span>
<span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">();</span></span></code></pre><div class="_opacity-0 _transition [div:hover&gt;&amp;]:_opacity-100 focus-within:_opacity-100 _flex _gap-1 _absolute _right-4 _top-2"><button class="_transition _border _border-gray-300 dark:_border-neutral-700 contrast-more:_border-gray-900 contrast-more:dark:_border-gray-50 _rounded-md _p-1.5 md:_hidden" title="Toggle word wrap" type="button" data-headlessui-state=""><svg viewBox="0 0 24 24" fill="currentColor" height="16"><path d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3l3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"></path></svg></button><button class="_transition _border _border-gray-300 dark:_border-neutral-700 contrast-more:_border-gray-900 contrast-more:dark:_border-gray-50 _rounded-md _p-1.5" title="Copy code" type="button" data-headlessui-state=""><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" height="16" class="nextra-copy-icon"><rect x="9" y="9" width="13" height="13" rx="2"></rect><path d="M5 15H4C2.89543 15 2 14.1046 2 13V4C2 2.89543 2.89543 2 4 2H13C14.1046 2 15 2.89543 15 4V5"></path></svg></button></div></div>
<h2 id="标记法" class="subheading-h2">标记法<a href="#标记法" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>标记法就是，将可达的对象标记起来，不可达的对象当成垃圾回收。</p>
<p>就是从初始的根对象（window 或者 global）的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，并为其进行标记，然后接着递归搜索，直到所有子节点被遍历结束。那么没有被遍历到节点，也就没有被标记，也就会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。</p>
<h2 id="javascript-内存管理" class="subheading-h2">JavaScript 内存管理<a href="#javascript-内存管理" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>1、分配给使用者所需的内存</p>
<p>2、使用者拿到这些内存，并使用内存</p>
<p>3、使用者不需要这些内存了，释放并归还给系统</p>
<div class="nextra-code _relative [&amp;:not(:first-child)]:_mt-6"><pre class="nextra-focus _overflow-x-auto _subpixel-antialiased _text-[.9em] _bg-white dark:_bg-black _py-4 _ring-1 _ring-inset _ring-gray-300 dark:_ring-neutral-700 contrast-more:_ring-gray-900 contrast-more:dark:_ring-gray-50 contrast-more:_contrast-150 _rounded-md _not-prose" tabindex="0"><code class="nextra-code" dir="ltr"><span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> &quot;john&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span>
<span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;john&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> };</span></span></code></pre><div class="_opacity-0 _transition [div:hover&gt;&amp;]:_opacity-100 focus-within:_opacity-100 _flex _gap-1 _absolute _right-4 _top-2"><button class="_transition _border _border-gray-300 dark:_border-neutral-700 contrast-more:_border-gray-900 contrast-more:dark:_border-gray-50 _rounded-md _p-1.5 md:_hidden" title="Toggle word wrap" type="button" data-headlessui-state=""><svg viewBox="0 0 24 24" fill="currentColor" height="16"><path d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3l3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"></path></svg></button><button class="_transition _border _border-gray-300 dark:_border-neutral-700 contrast-more:_border-gray-900 contrast-more:dark:_border-gray-50 _rounded-md _p-1.5" title="Copy code" type="button" data-headlessui-state=""><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" height="16" class="nextra-copy-icon"><rect x="9" y="9" width="13" height="13" rx="2"></rect><path d="M5 15H4C2.89543 15 2 14.1046 2 13V4C2 2.89543 2.89543 2 4 2H13C14.1046 2 15 2.89543 15 4V5"></path></svg></button></div></div>
<p>name 和 obj 是使用者</p>
<ul>
<li>
<p>基础数据类型：拥有固定的大小，值保存在栈内存里，可以通过值直接访问</p>
</li>
<li>
<p>引用数据类型：大小不固定(可以加属性)，栈内存中存着指针，指向堆内存中的对象空间，通过引用来访问</p>
</li>
<li>
<p>由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是操作系统自动分配和释放回收的</p>
</li>
<li>
<p>由于堆内存所存大小不固定，系统无法自动释放回收，所以需要 JS 引擎来手动释放这些内存</p>
</li>
</ul>
<h2 id="分代回收" class="subheading-h2">分代回收<a href="#分代回收" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>在 JavaScript 中，对象存活周期分为两种情况</p>
<ul>
<li>存活周期很短：经过一次垃圾回收后，就被释放回收掉</li>
<li>存活周期很长：经过多次垃圾回收后，他还存在，赖着不走</li>
</ul>
<p>V8 将堆分为两个空间，一个叫新生代，一个叫老生代，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方</p>
<p>新生代通常只有 1-8M 的容量，而老生代的容量就大很多了。对于这两块区域，V8 分别使用了不同的垃圾回收器和不同的回收算法，以便更高效地实施垃圾回收</p>
<ul>
<li>副垃圾回收器 + Scavenge 算法：主要负责新生代的垃圾回收</li>
<li>主垃圾回收器 + Mark-Sweep &amp;&amp; Mark-Compact 算法：主要负责老生代的垃圾回收</li>
</ul>
<h3 id="新生代" class="subheading-h3">新生代<a href="#新生代" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h3>
<p>在 JavaScript 中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。</p>
<p>在新生代中，主要使用 Scavenge（清道夫）算法进行垃圾回收，Scavenge 算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。</p>
<p>Scavange 算法将新生代堆分为两部分，分别叫 from-space 和 to-space，工作方式也很简单，就是将 from-space 中存活的活动对象复制到 to-space 中，并将这些对象的内存有序的排列起来，然后将 from-space 中的非活动对象的内存进行释放，完成之后，将 from space  和 to space 进行互换，这样可以使得新生代中的这两块区域可以重复利用。</p>
<ul>
<li>1、标记活动对象和非活动对象</li>
<li>2、复制 from-space 的活动对象到 to-space 中并进行排序</li>
<li>3、清除 from-space 中的非活动对象</li>
<li>4、将 from-space 和 to-space 进行角色互换，以便下一次的 Scavenge 算法垃圾回收</li>
</ul>
<p>通过可达性进行活动对象的判断</p>
<p>在新生代中，还进一步进行了细分。
分为 nursery（托儿所小班） 子代和 intermediate（托儿所中班） 子代两个区域，一个对象第一次分配内存时会被分配到新生代中的 nursery 子代，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们将此对象移动到 intermediate 子代，在经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升</p>
<blockquote>
<p>很形象，顽固的老油条我来单独处理你，别在托儿所上了，让小学老师来收拾你 🤣 😎</p>
</blockquote>
<h3 id="老生代" class="subheading-h3">老生代<a href="#老生代" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h3>
<p>新生代空间的对象，身经百战之后，留下来的老对象，成功晋升到了老生代空间里，由于这些对象都是经过多次回收过程但是没有被回收走的，都是一群生命力顽强，存活率高的对象，所以老生代里，回收算法不宜使用 Scavenge 算法，为啥呢，有以下原因：</p>
<p>Scavenge 算法是复制算法，反复复制这些存活率高的对象，没什么意义，效率极低
Scavenge 算法是以空间换时间的算法，老生代是内存很大的空间，如果使用 Scavenge 算法，空间资源非常浪费，得不偿失啊。。</p>
<p>所以老生代里使用了 Mark-Sweep 算法(标记清理)和 Mark-Compact 算法(标记整理)</p>
<p>套路和之前一样
Mark-Sweep 算法(标记清理)</p>
<ul>
<li>标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记</li>
<li>清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象</li>
</ul>
<p>Mark-Compact 算法(标记整理)
把内存空间整理一下，就像文件夹按网格排序一样</p>
<h3 id="全停顿stop-the-world" class="subheading-h3">全停顿(Stop-The-World)<a href="#全停顿stop-the-world" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h3>
<p>说完V8的分代回收，咱们来聊聊一个问题。JS代码的运行要用到JS引擎，垃圾回收也要用到JS引擎，那如果这两者同时进行了，发生冲突了咋办呢？答案是，垃圾回收优先于代码执行，会先停止代码的执行，等到垃圾回收完毕，再执行JS代码。这个过程，称为全停顿
由于新生代空间小，并且存活对象少，再配合Scavenge算法，停顿时间较短。但是老生代就不一样了，某些情况活动对象比较多的时候，停顿时间就会较长，使得页面出现了卡顿现象。</p>
<h3 id="orinoco奥里诺科优化" class="subheading-h3">Orinoco（奥里诺科）优化<a href="#orinoco奥里诺科优化" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h3>
<p>orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，它提出了增量标记、懒性清理、并发、并行的优化方法。</p>
<h3 id="增量标记incremental-marking" class="subheading-h3">增量标记(Incremental marking)<a href="#增量标记incremental-marking" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h3>
<p>咱们前面不断强调了先标记，后清除，而增量标记就是在标记这个阶段进行了优化。我举个生动的例子：路上有很多垃圾，害得路人都走不了路，需要清洁工打扫干净才能走。前几天路上的垃圾都比较少，所以路人们都等到清洁工全部清理干净才通过，但是后几天垃圾越来越多，清洁工清理的太久了，路人就等不及了，跟清洁工说：“你打扫一段，我就走一段，这样效率高”。
大家把上面例子里，清洁工清理垃圾的过程——标记过程，路人——JS代码，一一对应就懂了。当垃圾少量时不会做增量标记优化，但是当垃圾达到一定数量时，增量标记就会开启：标记一点，JS代码运行一段，从而提高效率</p>
<p>非常像react fiber架构，任务纤维化</p>
<h3 id="惰性清理lazy-sweeping" class="subheading-h3">惰性清理(Lazy sweeping)<a href="#惰性清理lazy-sweeping" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h3>
<p>上面说了，增量标记只是针对标记阶段，而惰性清理就是针对清除阶段了。在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就延迟了清理，让JS代码先执行，或者只清理部分垃圾，而不清理全部。这个优化就叫做惰性清理
整理标记和惰性清理的出现，大大改善了全停顿现象。但是问题也来了：增量标记是标记一点，JS运行一段，那如果你前脚刚标记一个对象为活动对象，后脚JS代码就把此对象设置为非活动对象，或者反过来，前脚没有标记一个对象为活动对象，后脚JS代码就把此对象设置为活动对象。总结起来就是：标记和代码执行的穿插，有可能造成对象引用改变，标记错误现象。这就需要使用写屏障技术来记录这些引用关系的变化</p>
<h3 id="并发concurrent" class="subheading-h3">并发(Concurrent)<a href="#并发concurrent" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h3>
<p>并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行写屏障操作。</p>
<h3 id="并行" class="subheading-h3">并行<a href="#并行" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h3>
<p>并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。</p>
<h2 id="总结" class="subheading-h2">总结<a href="#总结" class="_not-prose subheading-anchor" aria-label="Permalink for this section"></a></h2>
<p>我们在写react时有一句俗语，“遇事不决加一层”， 同样，在性能优化方面，总是绕不开 “遇事不决加一个线程” ，并发、协程的解决问题， 纤维化任务等。</p>
<p>程序世界果然好多套路都是相通的！</p></article></main><footer class="Footer_footer__hibhg"><div class="Footer_footerInner___6PzH"><div class="Footer_footerContent__7ET_v"><div class="Footer_footerLeft__6YSJc"><div class="Footer_footerMotto__hGlND"><p class="Footer_mottoContent__DZtOp"></p><p class="Footer_mottoAuthor__CLOkJ">—— </p></div></div><div class="Footer_footerRight__gZmlM"><div class="Footer_footerLinks__nX7_m"><a href="https://github.com/yuanguandong" class="Footer_footerLink__PHLXX">GitHub</a></div><div class="Footer_footerCopyright__v5EO_">© <!-- -->2024<!-- --> 重剑的博客 All rights reserved.</div><div class="Footer_footerICP__U9ArL"><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer" class="Footer_footerLink__PHLXX">蜀ICP备2024070350号-3</a></div></div></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/posts/other/v8gc","query":{},"buildId":"liUDpDv9XeuZIQ0wA6cxc","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>