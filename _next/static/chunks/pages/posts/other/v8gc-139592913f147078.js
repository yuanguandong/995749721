(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[807],{78798:(i,s,n)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/other/v8gc",function(){return n(92078)}])},92078:(i,s,n)=>{"use strict";n.r(s),n.d(s,{default:()=>t,useTOC:()=>c});var e=n(86070),h=n(19422),l=n(72522),d=n(24756);let r={src:"/_next/static/media/hero.f2777d0d.webp",height:900,width:1200,blurDataURL:"data:image/webp;base64,UklGRkIAAABXRUJQVlA4IDYAAACwAQCdASoIAAYAAkA4JaQAAxeTutgAAP75CPK9JqE7m5tf7h02nbkLrU7zi4TOZcSt9eBAAAA=",blurWidth:8,blurHeight:6};n(88564);var a=n(39942);function c(i){return[{value:"引言",id:"引言",depth:2},{value:"引用法",id:"引用法",depth:2},{value:"概念",id:"概念",depth:3},{value:"缺陷",id:"缺陷",depth:3},{value:"标记法",id:"标记法",depth:2},{value:"JavaScript 内存管理",id:"javascript-内存管理",depth:2},{value:"分代回收",id:"分代回收",depth:2},{value:"新生代",id:"新生代",depth:3},{value:"老生代",id:"老生代",depth:3},{value:"全停顿(Stop-The-World)",id:"全停顿stop-the-world",depth:3},{value:"Orinoco（奥里诺科）优化",id:"orinoco奥里诺科优化",depth:3},{value:"增量标记(Incremental marking)",id:"增量标记incremental-marking",depth:3},{value:"惰性清理(Lazy sweeping)",id:"惰性清理lazy-sweeping",depth:3},{value:"并发(Concurrent)",id:"并发concurrent",depth:3},{value:"并行",id:"并行",depth:3},{value:"总结",id:"总结",depth:2}]}let t=(0,h.e)(function(i){let{toc:s=c(i)}=i,n={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",span:"span",ul:"ul",...(0,d.R)(),...i.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.p,{children:(0,e.jsx)(n.img,{alt:"V8gc",placeholder:"blur",src:r})}),"\n",(0,e.jsx)("div",{className:"img-desc",children:"图：Peter Tarka"}),"\n","\n",(0,e.jsx)(n.h2,{id:s[0].id,children:s[0].value}),"\n",(0,e.jsx)(n.p,{children:"JavaScript 可以高效地运行在浏览器和 Nodejs 这两大宿主环境中，是因为背后有强大的 V8 引擎在为其保驾护航，甚至成就了 Chrome 在浏览器中的霸主地位。"}),"\n",(0,e.jsx)(n.p,{children:"正是因为有 V8 引擎的存在才会有前端今天的繁荣生态"}),"\n",(0,e.jsx)(n.p,{children:"感谢V8 \uD83D\uDE47"}),"\n",(0,e.jsx)(n.p,{children:"V8 引擎为了追求极致的性能和更好的用户体验，为我们做了太多太多。"}),"\n",(0,e.jsx)(n.p,{children:"V8 引擎努力降低整体的内存占用和提升到更高的运行性能。"}),"\n",(0,e.jsx)(n.p,{children:"我们来看一下 V8 引擎中的垃圾回收机制"}),"\n",(0,e.jsx)(n.h2,{id:s[1].id,children:s[1].value}),"\n",(0,e.jsx)(n.h3,{id:s[2].id,children:s[2].value}),"\n",(0,e.jsx)(n.p,{children:"判断一个对象的引用数，引用数为 0 就回收，引用数大于 0 就不回收"}),"\n",(0,e.jsx)(n.pre,{icon:a.js,tabIndex:"0","data-language":"js","data-word-wrap":"","data-copy":"",children:(0,e.jsxs)(n.code,{children:[(0,e.jsx)(n.span,{children:(0,e.jsx)(n.span,{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"},children:"// 在堆中创建一个对象，foo是这个对象的引用"})}),"\n",(0,e.jsxs)(n.span,{children:[(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"let"}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" foo "}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"="}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" { name: "}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"},children:'"foo"'}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" };"})]}),"\n",(0,e.jsx)(n.span,{children:(0,e.jsx)(n.span,{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"},children:'// 把引用地址改为null, { name: "foo" }对象在堆中没有被栈中引用，那么这块堆中的内存就会被回收'})}),"\n",(0,e.jsxs)(n.span,{children:[(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"foo "}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"="}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"},children:" null"}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:";"})]})]})}),"\n",(0,e.jsx)(n.h3,{id:s[3].id,children:s[3].value}),"\n",(0,e.jsx)(n.p,{children:"如果对象之间有相互引用关系，并且引用关系一直存在，那么就不会被回收，从而造成内存泄漏"}),"\n",(0,e.jsx)(n.pre,{icon:a.js,tabIndex:"0","data-language":"js","data-word-wrap":"","data-copy":"",children:(0,e.jsxs)(n.code,{children:[(0,e.jsxs)(n.span,{children:[(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"function"}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:" fn"}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"() {"})]}),"\n",(0,e.jsxs)(n.span,{children:[(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"  const"}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"},children:" obj1"}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:" ="}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" {};"})]}),"\n",(0,e.jsxs)(n.span,{children:[(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"  const"}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"},children:" obj2"}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:" ="}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" {};"})]}),"\n",(0,e.jsxs)(n.span,{children:[(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"  obj1.a "}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"="}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" obj2;"})]}),"\n",(0,e.jsxs)(n.span,{children:[(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"  obj2.a "}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"="}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" obj1;"})]}),"\n",(0,e.jsx)(n.span,{children:(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"}"})}),"\n",(0,e.jsxs)(n.span,{children:[(0,e.jsx)(n.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"fn"}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"();"})]})]})}),"\n",(0,e.jsx)(n.h2,{id:s[4].id,children:s[4].value}),"\n",(0,e.jsx)(n.p,{children:"标记法就是，将可达的对象标记起来，不可达的对象当成垃圾回收。"}),"\n",(0,e.jsx)(n.p,{children:"就是从初始的根对象（window 或者 global）的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，并为其进行标记，然后接着递归搜索，直到所有子节点被遍历结束。那么没有被遍历到节点，也就没有被标记，也就会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。"}),"\n",(0,e.jsx)(n.h2,{id:s[5].id,children:s[5].value}),"\n",(0,e.jsx)(n.p,{children:"1、分配给使用者所需的内存"}),"\n",(0,e.jsx)(n.p,{children:"2、使用者拿到这些内存，并使用内存"}),"\n",(0,e.jsx)(n.p,{children:"3、使用者不需要这些内存了，释放并归还给系统"}),"\n",(0,e.jsx)(n.pre,{icon:a.js,tabIndex:"0","data-language":"js","data-word-wrap":"","data-copy":"",children:(0,e.jsxs)(n.code,{children:[(0,e.jsxs)(n.span,{children:[(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"var"}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" name "}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"="}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"},children:' "john"'}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:";"})]}),"\n",(0,e.jsxs)(n.span,{children:[(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"var"}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" obj "}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"="}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" { name: "}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"},children:'"john"'}),(0,e.jsx)(n.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" };"})]})]})}),"\n",(0,e.jsx)(n.p,{children:"name 和 obj 是使用者"}),"\n",(0,e.jsxs)(n.ul,{children:["\n",(0,e.jsxs)(n.li,{children:["\n",(0,e.jsx)(n.p,{children:"基础数据类型：拥有固定的大小，值保存在栈内存里，可以通过值直接访问"}),"\n"]}),"\n",(0,e.jsxs)(n.li,{children:["\n",(0,e.jsx)(n.p,{children:"引用数据类型：大小不固定(可以加属性)，栈内存中存着指针，指向堆内存中的对象空间，通过引用来访问"}),"\n"]}),"\n",(0,e.jsxs)(n.li,{children:["\n",(0,e.jsx)(n.p,{children:"由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是操作系统自动分配和释放回收的"}),"\n"]}),"\n",(0,e.jsxs)(n.li,{children:["\n",(0,e.jsx)(n.p,{children:"由于堆内存所存大小不固定，系统无法自动释放回收，所以需要 JS 引擎来手动释放这些内存"}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(n.h2,{id:s[6].id,children:s[6].value}),"\n",(0,e.jsx)(n.p,{children:"在 JavaScript 中，对象存活周期分为两种情况"}),"\n",(0,e.jsxs)(n.ul,{children:["\n",(0,e.jsx)(n.li,{children:"存活周期很短：经过一次垃圾回收后，就被释放回收掉"}),"\n",(0,e.jsx)(n.li,{children:"存活周期很长：经过多次垃圾回收后，他还存在，赖着不走"}),"\n"]}),"\n",(0,e.jsx)(n.p,{children:"V8 将堆分为两个空间，一个叫新生代，一个叫老生代，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方"}),"\n",(0,e.jsx)(n.p,{children:"新生代通常只有 1-8M 的容量，而老生代的容量就大很多了。对于这两块区域，V8 分别使用了不同的垃圾回收器和不同的回收算法，以便更高效地实施垃圾回收"}),"\n",(0,e.jsxs)(n.ul,{children:["\n",(0,e.jsx)(n.li,{children:"副垃圾回收器 + Scavenge 算法：主要负责新生代的垃圾回收"}),"\n",(0,e.jsx)(n.li,{children:"主垃圾回收器 + Mark-Sweep && Mark-Compact 算法：主要负责老生代的垃圾回收"}),"\n"]}),"\n",(0,e.jsx)(n.h3,{id:s[7].id,children:s[7].value}),"\n",(0,e.jsx)(n.p,{children:"在 JavaScript 中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。"}),"\n",(0,e.jsx)(n.p,{children:"在新生代中，主要使用 Scavenge（清道夫）算法进行垃圾回收，Scavenge 算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。"}),"\n",(0,e.jsx)(n.p,{children:"Scavange 算法将新生代堆分为两部分，分别叫 from-space 和 to-space，工作方式也很简单，就是将 from-space 中存活的活动对象复制到 to-space 中，并将这些对象的内存有序的排列起来，然后将 from-space 中的非活动对象的内存进行释放，完成之后，将 from space\xa0 和 to space 进行互换，这样可以使得新生代中的这两块区域可以重复利用。"}),"\n",(0,e.jsxs)(n.ul,{children:["\n",(0,e.jsx)(n.li,{children:"1、标记活动对象和非活动对象"}),"\n",(0,e.jsx)(n.li,{children:"2、复制 from-space 的活动对象到 to-space 中并进行排序"}),"\n",(0,e.jsx)(n.li,{children:"3、清除 from-space 中的非活动对象"}),"\n",(0,e.jsx)(n.li,{children:"4、将 from-space 和 to-space 进行角色互换，以便下一次的 Scavenge 算法垃圾回收"}),"\n"]}),"\n",(0,e.jsx)(n.p,{children:"通过可达性进行活动对象的判断"}),"\n",(0,e.jsx)(n.p,{children:"在新生代中，还进一步进行了细分。\n分为 nursery（托儿所小班） 子代和 intermediate（托儿所中班） 子代两个区域，一个对象第一次分配内存时会被分配到新生代中的 nursery 子代，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们将此对象移动到 intermediate 子代，在经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升"}),"\n",(0,e.jsxs)(n.blockquote,{children:["\n",(0,e.jsx)(n.p,{children:"很形象，顽固的老油条我来单独处理你，别在托儿所上了，让小学老师来收拾你 \uD83E\uDD23 \uD83D\uDE0E"}),"\n"]}),"\n",(0,e.jsx)(n.h3,{id:s[8].id,children:s[8].value}),"\n",(0,e.jsx)(n.p,{children:"新生代空间的对象，身经百战之后，留下来的老对象，成功晋升到了老生代空间里，由于这些对象都是经过多次回收过程但是没有被回收走的，都是一群生命力顽强，存活率高的对象，所以老生代里，回收算法不宜使用 Scavenge 算法，为啥呢，有以下原因："}),"\n",(0,e.jsx)(n.p,{children:"Scavenge 算法是复制算法，反复复制这些存活率高的对象，没什么意义，效率极低\nScavenge 算法是以空间换时间的算法，老生代是内存很大的空间，如果使用 Scavenge 算法，空间资源非常浪费，得不偿失啊。。"}),"\n",(0,e.jsx)(n.p,{children:"所以老生代里使用了 Mark-Sweep 算法(标记清理)和 Mark-Compact 算法(标记整理)"}),"\n",(0,e.jsx)(n.p,{children:"套路和之前一样\nMark-Sweep 算法(标记清理)"}),"\n",(0,e.jsxs)(n.ul,{children:["\n",(0,e.jsx)(n.li,{children:"标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记"}),"\n",(0,e.jsx)(n.li,{children:"清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象"}),"\n"]}),"\n",(0,e.jsx)(n.p,{children:"Mark-Compact 算法(标记整理)\n把内存空间整理一下，就像文件夹按网格排序一样"}),"\n",(0,e.jsx)(n.h3,{id:s[9].id,children:s[9].value}),"\n",(0,e.jsx)(n.p,{children:"说完V8的分代回收，咱们来聊聊一个问题。JS代码的运行要用到JS引擎，垃圾回收也要用到JS引擎，那如果这两者同时进行了，发生冲突了咋办呢？答案是，垃圾回收优先于代码执行，会先停止代码的执行，等到垃圾回收完毕，再执行JS代码。这个过程，称为全停顿\n由于新生代空间小，并且存活对象少，再配合Scavenge算法，停顿时间较短。但是老生代就不一样了，某些情况活动对象比较多的时候，停顿时间就会较长，使得页面出现了卡顿现象。"}),"\n",(0,e.jsx)(n.h3,{id:s[10].id,children:s[10].value}),"\n",(0,e.jsx)(n.p,{children:"orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，它提出了增量标记、懒性清理、并发、并行的优化方法。"}),"\n",(0,e.jsx)(n.h3,{id:s[11].id,children:s[11].value}),"\n",(0,e.jsx)(n.p,{children:"咱们前面不断强调了先标记，后清除，而增量标记就是在标记这个阶段进行了优化。我举个生动的例子：路上有很多垃圾，害得路人都走不了路，需要清洁工打扫干净才能走。前几天路上的垃圾都比较少，所以路人们都等到清洁工全部清理干净才通过，但是后几天垃圾越来越多，清洁工清理的太久了，路人就等不及了，跟清洁工说：“你打扫一段，我就走一段，这样效率高”。\n大家把上面例子里，清洁工清理垃圾的过程——标记过程，路人——JS代码，一一对应就懂了。当垃圾少量时不会做增量标记优化，但是当垃圾达到一定数量时，增量标记就会开启：标记一点，JS代码运行一段，从而提高效率"}),"\n",(0,e.jsx)(n.p,{children:"非常像react fiber架构，任务纤维化"}),"\n",(0,e.jsx)(n.h3,{id:s[12].id,children:s[12].value}),"\n",(0,e.jsx)(n.p,{children:"上面说了，增量标记只是针对标记阶段，而惰性清理就是针对清除阶段了。在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就延迟了清理，让JS代码先执行，或者只清理部分垃圾，而不清理全部。这个优化就叫做惰性清理\n整理标记和惰性清理的出现，大大改善了全停顿现象。但是问题也来了：增量标记是标记一点，JS运行一段，那如果你前脚刚标记一个对象为活动对象，后脚JS代码就把此对象设置为非活动对象，或者反过来，前脚没有标记一个对象为活动对象，后脚JS代码就把此对象设置为活动对象。总结起来就是：标记和代码执行的穿插，有可能造成对象引用改变，标记错误现象。这就需要使用写屏障技术来记录这些引用关系的变化"}),"\n",(0,e.jsx)(n.h3,{id:s[13].id,children:s[13].value}),"\n",(0,e.jsx)(n.p,{children:"并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行写屏障操作。"}),"\n",(0,e.jsx)(n.h3,{id:s[14].id,children:s[14].value}),"\n",(0,e.jsx)(n.p,{children:"并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。"}),"\n",(0,e.jsx)(n.h2,{id:s[15].id,children:s[15].value}),"\n",(0,e.jsx)(n.p,{children:"我们在写react时有一句俗语，“遇事不决加一层”， 同样，在性能优化方面，总是绕不开 “遇事不决加一个线程” ，并发、协程的解决问题， 纤维化任务等。"}),"\n",(0,e.jsx)(n.p,{children:"程序世界果然好多套路都是相通的！"})]})},"/posts/other/v8gc",{filePath:"pages/posts/other/v8gc/index.mdx",timestamp:1732443695e3,pageMap:l.O,frontMatter:{slug:"other-v8gc",title:"chrome V8 引擎中的垃圾回收机制",author:"Favori",date:"2022-03-03",hero:"./hero.webp",excerpt:"V8引擎就是nodejs的发动机"},title:"chrome V8 引擎中的垃圾回收机制"},"undefined"==typeof RemoteContent?c:RemoteContent.useTOC)},88564:(i,s,n)=>{"use strict";n.d(s,{A:()=>h});var e=n(86070);n(30758);let h=i=>{let{name:s}=i;return(0,e.jsx)("img",{src:"http://github.com/yuanguandong/code/blob/master/draw/".concat(s,".png?raw=true")})}}},i=>{var s=s=>i(i.s=s);i.O(0,[2195,636,6593,8792],()=>s(78798)),_N_E=i.O()}]);