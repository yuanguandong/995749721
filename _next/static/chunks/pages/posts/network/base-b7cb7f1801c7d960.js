(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3166],{80236:(n,e,i)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/network/base",function(){return i(46342)}])},46342:(n,e,i)=>{"use strict";i.r(e),i.d(e,{default:()=>t,useTOC:()=>p});var d=i(86070),l=i(19422),s=i(72522),r=i(24756);let h={src:"/_next/static/media/hero.7c2b5b9d.webp",height:820,width:1082,blurDataURL:"data:image/webp;base64,UklGRkgAAABXRUJQVlA4IDwAAACwAQCdASoIAAYAAkA4JZQCdAD0klH4AP76DH8Jq8h4xhxj3medvbbmZZVY3+l5UzGdj65K2TvSmPKQAAA=",blurWidth:8,blurHeight:6},c={src:"/_next/static/media/1.a95eee0e.png",height:400,width:1033,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAADCAMAAACZFr56AAAABlBMVEX29vbu7u4m5kP6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFElEQVR4nGNghAAGEIBQjGAGIwMAAOoADmdbRywAAAAASUVORK5CYII=",blurWidth:8,blurHeight:3},A={src:"/_next/static/media/3.89385157.png",height:732,width:656,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAICAMAAAAC2hU0AAAASFBMVEXZ5r7D0ue5zOHz4tTa4crR2ufmzLXw1Lvs0Lj4+fTk5uHt3M/f5s3L1+HX4O7o2MvU28TO2rbg59Dt7uni5/T76dvd4uXx2sUjw3JWAAAACXBIWXMAABcSAAAXEgFnn9JSAAAAOklEQVR4nCXBtwHAMAwDMKrYolxT/381QwBky8x24/DLhw+c+M0iqnOhLFEpD6KSZKAyyErs3s3s/QA2twGvM2AbKAAAAABJRU5ErkJggg==",blurWidth:7,blurHeight:8};function p(n){return[{value:"TCP/IP网络协议",id:"tcpip网络协议",depth:2},{value:"OSI七层模型",id:"osi七层模型",depth:2},{value:"数据包",id:"数据包",depth:2},{value:"每层在接收到数据后除了添加首部, 还要做什么呢?",id:"每层在接收到数据后除了添加首部-还要做什么呢",depth:2},{value:"通过以下这几个数据综合来识别一次通信：",id:"通过以下这几个数据综合来识别一次通信",depth:2},{value:"TCP/UDP的区别",id:"tcpudp的区别",depth:2},{value:"TCP通过什么方式提供可靠性？",id:"tcp通过什么方式提供可靠性",depth:2},{value:"TCP如何控制拥塞？",id:"tcp如何控制拥塞",depth:2},{value:"TCP协议的一次数据传输, 从建立连接到断开连接都有哪些流程?",id:"tcp协议的一次数据传输-从建立连接到断开连接都有哪些流程",depth:2},{value:"IP地址",id:"ip地址",depth:2},{value:"IPv6",id:"ipv6",depth:2},{value:"DNS",id:"dns",depth:2}]}let t=(0,l.e)(function(n){let{toc:e=p(n)}=n,i={code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",span:"span",ul:"ul",...(0,r.R)(),...n.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(i.p,{children:(0,d.jsx)(i.img,{alt:"Base",placeholder:"blur",src:h})}),"\n",(0,d.jsx)("div",{className:"img-desc",children:"图：Kashish Arora"}),"\n",(0,d.jsx)(i.h2,{id:e[0].id,children:e[0].value}),"\n",(0,d.jsx)(i.p,{children:"传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议"}),"\n",(0,d.jsx)(i.p,{children:"IP是Internet Protocol（网际互连协议）的缩写，是TCP/IP体系中的网际层协议。"}),"\n",(0,d.jsx)(i.p,{children:"是⼀一个协议家族, 以TCP、IP协议为核⼼心, 包含HTTP、SMTP、TELNET等各种协议。"}),"\n",(0,d.jsx)(i.h2,{id:e[1].id,children:e[1].value}),"\n",(0,d.jsx)(i.p,{children:"OSI（开放系统互联(Open System Interconnection)）一般指开放式系统互联"}),"\n",(0,d.jsx)(i.p,{children:"开放式系统互联是把网络通信的工作分为7层,分别是物理层,数据链路层,网络层,传输层,会话层,表示层和应用层。"}),"\n",(0,d.jsx)(i.p,{children:"第七层： 应用层 为操作系统或者网络应用程序提供访问网络服务的接口。 （html）"}),"\n",(0,d.jsx)(i.p,{children:"第六层： 表示层 压缩，格式转换"}),"\n",(0,d.jsx)(i.p,{children:"第五层： 会话层 负责数据传输中维持网络设备之间的通信链接"}),"\n",(0,d.jsx)(i.p,{children:"第四层： 传输层 把传输表头加到数据上形成数据包，完成端到端的数据传输。协议：TCP UDP"}),"\n",(0,d.jsx)(i.p,{children:"第三层： 网络层 负责对子网间的数据包进行寻址和路由选择,可以实现拥塞控制、网际互联等功能。协议：IP; (路由器)"}),"\n",(0,d.jsx)(i.p,{children:"第二层： 数据链路层 物理地址寻址 （交换机/猫）"}),"\n",(0,d.jsx)(i.p,{children:"第一层： 物理层 在局域网上进行数据传输，负责电脑通信设备与网络媒体之间的互通 (网线网卡……)"}),"\n",(0,d.jsx)(i.p,{children:(0,d.jsx)(i.img,{placeholder:"blur",src:c})}),"\n",(0,d.jsx)(i.h2,{id:e[2].id,children:e[2].value}),"\n",(0,d.jsx)(i.p,{children:"数据包是⽹网络层及以上分层中包的单位"}),"\n",(0,d.jsx)(i.p,{children:"每个分层都会对发送的数据添加一个首部, 首部包含了该层协议相关的信息, 而真正要发送的内容称之为数据."}),"\n",(0,d.jsx)(i.p,{children:"也就是说每一个数据包都由首部 + 数据组成."}),"\n",(0,d.jsx)(i.p,{children:"而对于下层来说, 上层发送过来的全部内容, 都会当做本层的数据, 举个例子："}),"\n",(0,d.jsx)(i.p,{children:"传输层 TCP包：TCP包首部 + 数据\n网络层 IP包：IP包首部 + (TCP包首部 + 数据)\n数据链路层 以太网包：以太网包首部 + (IP包首部 + (TCP包首部 + 数据))"}),"\n",(0,d.jsx)(i.h2,{id:e[3].id,children:e[3].value}),"\n",(0,d.jsx)(i.p,{children:"用户1"}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsx)(i.li,{children:"传输层：TCP模块为保证数据的可靠传输, 需要添加TCP首部"}),"\n",(0,d.jsx)(i.li,{children:"网络层：IP包生成后，参考路由控制表决定接受此 IP 包的路由或主机。"}),"\n",(0,d.jsx)(i.li,{children:"数据链路层：生成的以太网数据包将通过物理层传输给接收端"}),"\n"]}),"\n",(0,d.jsx)(i.p,{children:"用户2"}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsx)(i.li,{children:"数据链路层：主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。\n如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，比如IP."}),"\n",(0,d.jsx)(i.li,{children:"网络层：从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，比如TCP"}),"\n",(0,d.jsx)(i.li,{children:"传输层：在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照顺序接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。"}),"\n"]}),"\n",(0,d.jsx)(i.p,{children:"总结一下几个地址："}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsx)(i.li,{children:"数据链路层的是MAC地址, 用来识别同一链路中的不同计算机"}),"\n",(0,d.jsx)(i.li,{children:"网络层的是IP地址, 用来识别TCP/IP 网络中互连的主机和路由器"}),"\n",(0,d.jsx)(i.li,{children:"传输层的是端口号(程序地址), 用来识别同一台计算机中进行通信的不同应用程序"}),"\n"]}),"\n",(0,d.jsx)(i.h2,{id:e[4].id,children:e[4].value}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsx)(i.li,{children:"IP首部：源IP地址"}),"\n",(0,d.jsx)(i.li,{children:"IP首部：目标IP地址"}),"\n",(0,d.jsx)(i.li,{children:"协议号, TCP或者UDP"}),"\n",(0,d.jsx)(i.li,{children:"TCP首部：源端口号"}),"\n",(0,d.jsx)(i.li,{children:"TCP首部：目标端口号"}),"\n"]}),"\n",(0,d.jsx)(i.h2,{id:e[5].id,children:e[5].value}),"\n",(0,d.jsx)(i.p,{children:"用户数据报协议（UDP，User Datagram Protocol）"}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsx)(i.li,{children:"UDP是无连接的，TCP必须三次握手建立连接"}),"\n",(0,d.jsx)(i.li,{children:"UDP是面向报文，没有拥塞控制，所以速度快，适合多媒体通信要求，比如及时聊天，支持一对一，一队多。多对一，多对多。"}),"\n",(0,d.jsx)(i.li,{children:"TCP只能是一对一的可靠性传输"}),"\n"]}),"\n",(0,d.jsx)(i.p,{children:"那么咱们的直播底层是什么协议呢?"}),"\n",(0,d.jsx)(i.p,{children:"其实现在常见的rtmp和hls直播, 都是基于TCP的, 希望能提供稳定的直播环境."}),"\n",(0,d.jsx)(i.h2,{id:e[6].id,children:e[6].value}),"\n",(0,d.jsxs)(i.ul,{children:["\n",(0,d.jsx)(i.li,{children:"超时重发，发出报文段要是没有收到及时的确认，会重发。"}),"\n",(0,d.jsx)(i.li,{children:"数据包的校验，也就是校验首部数据和。"}),"\n",(0,d.jsx)(i.li,{children:"对失序的数据重新排序"}),"\n",(0,d.jsx)(i.li,{children:"进行流量控制，防止缓冲区溢出"}),"\n",(0,d.jsx)(i.li,{children:"快重传和快恢复"}),"\n",(0,d.jsx)(i.li,{children:"TCP会将数据截断为合理的长度"}),"\n"]}),"\n",(0,d.jsx)(i.h2,{id:e[7].id,children:e[7].value}),"\n",(0,d.jsx)(i.p,{children:"拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。"}),"\n",(0,d.jsx)(i.p,{children:"发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。"}),"\n",(0,d.jsx)(i.p,{children:"为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下："}),"\n",(0,d.jsx)(i.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"","data-copy":"",children:(0,d.jsxs)(i.code,{children:[(0,d.jsx)(i.span,{children:(0,d.jsx)(i.span,{children:"当cwnd<ssthresh时，使用慢开始算法。也就是乘法算法"})}),"\n",(0,d.jsx)(i.span,{children:(0,d.jsx)(i.span,{})}),"\n",(0,d.jsx)(i.span,{children:(0,d.jsx)(i.span,{children:"当cwnd>ssthresh时，改用拥塞避免算法。也就是加法算法"})}),"\n",(0,d.jsx)(i.span,{children:(0,d.jsx)(i.span,{})}),"\n",(0,d.jsx)(i.span,{children:(0,d.jsx)(i.span,{children:"当cwnd=ssthresh时，慢开始与拥塞避免算法任意。"})})]})}),"\n",(0,d.jsx)(i.p,{children:"当出现拥塞的时候就把心的门限值设为此时窗口大小的一般，窗口大小设置为1，再重新执行上面的步骤。\n当收到连续三个重传的时候这就需要快重传和快恢复了，当收到连续三个重传 这个时候发送方就要重传自己的信息，然后门限减半但是这个时候并不是网络阻塞，窗口只会减半执行拥塞避免算法。"}),"\n",(0,d.jsx)(i.h2,{id:e[8].id,children:e[8].value}),"\n",(0,d.jsx)(i.p,{children:(0,d.jsx)(i.img,{placeholder:"blur",src:A})}),"\n",(0,d.jsx)(i.p,{children:"第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；"}),"\n",(0,d.jsx)(i.p,{children:"第二次握手：服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，\n设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，\n将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，\n一并发送给客户端，此时服务器进入SYN_RECV状态；"}),"\n",(0,d.jsx)(i.p,{children:"第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，\n向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，\n完成TCP三次握手。"}),"\n",(0,d.jsx)(i.p,{children:"完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。通信结束客户端和服务端就断开连接，需要经过四次分手确认。"}),"\n",(0,d.jsx)(i.p,{children:"第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；\n此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；"}),"\n",(0,d.jsx)(i.p,{children:"第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；\n主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；"}),"\n",(0,d.jsx)(i.p,{children:"第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；"}),"\n",(0,d.jsx)(i.p,{children:"第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；"}),"\n",(0,d.jsx)(i.p,{children:"主机2收到主机1的ACK报文段以后，就关闭连接；\n此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。"}),"\n",(0,d.jsx)(i.h2,{id:e[9].id,children:e[9].value}),"\n",(0,d.jsx)(i.p,{children:"IP 地址（IPv4 地址）由32位正整数来表示，在计算机内部以二进制方式被处理。日常生活中，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数"}),"\n",(0,d.jsx)(i.p,{children:"IP地址包含网络标识和主机标识, 比如152.112.110.16"}),"\n",(0,d.jsx)(i.p,{children:"152.112.110就是网络标识, 同一网段内网络标识必须相同\n16就是主机标识, 同一网段内主机标识不能重复"}),"\n",(0,d.jsx)(i.h2,{id:e[10].id,children:e[10].value}),"\n",(0,d.jsx)(i.p,{children:"IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。"}),"\n",(0,d.jsx)(i.h2,{id:e[11].id,children:e[11].value}),"\n",(0,d.jsx)(i.p,{children:"我们平时访问一个网站, 一个应用程序, 并不是用ip来访问的, 而是用一个域名. 那么域名是怎么和ip地址建立联系的呢?"}),"\n",(0,d.jsx)(i.p,{children:"就是通过dns, Domain Name System. 比如wiki上的一个例子"}),"\n",(0,d.jsx)(i.p,{children:"以访问 zh.wikipedia.org 为例："}),"\n",(0,d.jsx)(i.p,{children:"客户端发送查询报文”query zh.wikipedia.org”至DNS服务器，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果。\n如果记录老化或不存在，则：\nDNS服务器向根域名服务器发送查询报文”query zh.wikipedia.org”，根域名服务器返回顶级域 .org 的顶级域名服务器地址。\nDNS服务器向 .org 域的顶级域名服务器发送查询报文”query zh.wikipedia.org”，得到二级域 .wikipedia.org 的权威域名服务器地址。\nDNS服务器向 .wikipedia.org 域的权威域名服务器发送查询报文”query zh.wikipedia.org”，得到主机 zh 的A记录，存入自身缓存并返回给客户端。"})]})},"/posts/network/base",{filePath:"pages/posts/network/base/index.mdx",timestamp:1732442721e3,pageMap:s.O,frontMatter:{slug:"network-base",title:"Nodejs 网络 & HTTP",author:"Favori",date:"2020-08-14",hero:"./hero.webp",excerpt:"nodejs-network"},title:"Nodejs 网络 & HTTP"},"undefined"==typeof RemoteContent?p:RemoteContent.useTOC)}},n=>{var e=e=>n(n.s=e);n.O(0,[2195,636,6593,8792],()=>e(80236)),_N_E=n.O()}]);