{"/":{"title":"Index","data":{}},"/posts/algo/adding-large-numbers":{"title":"JS 实现两个大数相加？","data":{"js中的大数相加#js中的大数相加":"当有两个整数 a 和 b ，在通常情况下我们有\"+\"运算符对其进行相加运算：\nlet sum = a + b;\n但是 JS 在存放整数的时候是有一个安全范围的，一旦数字超过这个范围便会损失精度。我们不能拿精度损失的数字进行运行，因为运算结果一样是会损失精度的。所以，我们要用字符串来表示数据！（不会丢失精度）\nJS 中整数的最大安全范围可以查到是：9007199254740991\n假如我们要进行 9007199254740991 + 1234567899999999999我们要先准备两个字符串变量和一个方法：\nlet a = \"9007199254740991\";\nlet b = \"1234567899999999999\";\nfunction add(a ,b){\n   //...\n}\n然后从个位开始相加：\nlet a = \"9007199254740991\";\nlet b = \"1234567899999999999\";\nfunction add(a ,b){\n   //取两个数字的最大长度\n   let maxLength = Math.max(a.length, b.length);\n   //用0去补齐长度\n   a = a.padStart(maxLength , 0);//\"0009007199254740991\"\n   b = b.padStart(maxLength , 0);//\"1234567899999999999\"\n   //定义加法过程中需要用到的变量\n   let t = 0;\n   let f = 0;   //\"进位\"\n   let sum = \"\";\n   for(let i=maxLength-1 ; i>=0 ; i--){\n      t = parseInt(a[i]) + parseInt(b[i]) + f;\n      f = Math.floor(t/10);\n      sum = t%10 + sum;\n   }\n   if(f == 1){\n      sum = \"1\" + sum;\n   }\n   return sum;\n}\nadd(a ,b); //结果为：1243575099254740990"}},"/posts/algo/clonedeep":{"title":"cloneDeep 深克隆实现","data":{"":"图：Nguyen Nhut","测试对象#测试对象":"var obj = {\n  //原数据，包含字符串、对象、函数、数组等不同的类型\n  name: \"test\",\n  main: {\n    a: 1,\n    b: 2,\n  },\n  fn: function () {\n    alert(1);\n  },\n  date: new Date(),\n  reg: new RegExp(),\n  friends: [1, 2, 3, [22, 33]],\n};","浅克隆#浅克隆":"function clone(obj) {\n  let newObj = {};\n  for (let i in obj) {\n    newObj[i] = obj[i];\n  }\n  return newObj;\n}","深克隆#深克隆":"function cloneDeep(obj) {\n  let newObj = null;\n  if (typeof obj === \"object\" && typeof obj !== null) {\n    if (obj instanceof Array) {\n      newObj = [];\n      for (let i in obj) {\n        newObj[i] = cloneDeep(obj[i]);\n      }\n    } else if (obj instanceof Date) {\n      newObj = new Date(obj)\n    } else if (obj instanceof RegExp) {\n      newObj = new RegExp(obj)\n    } else {\n      newObj = {};\n      for (let i in obj) {\n        newObj[i] = cloneDeep(obj[i]);\n      }\n    }\n  } else {\n    newObj = obj;\n  }\n  return newObj;\n}"}},"/posts/algo/lodash-get":{"title":"Lodash Get 实现","data":{"":"图：Nguyen Nhut","实现#实现":"const a = {\n  b: {\n    c: [1, 2, 3],\n  },\n};\nconst get = (obj, path, defaultValue = undefined) => {\n  if (path.length === 0) {\n    return obj;\n  }\n  if (!obj) {\n    return defaultValue;\n  }\n  if (typeof path === \"string\") {\n    path = path.replace(/\\[/g, \".\").replace(/\\]/g, \"\").split(\".\");\n  }\n  let p = path.shift();\n  return get(obj[p], path);\n};\nconst res = get(a, \"b.c[3]\");\nconsole.log(res);"}},"/posts/algo/reduce":{"title":"手写reduce实现","data":{"":"图：Nguyen Nhut","实现#实现":"const arr = [1, 2, 3, 4];\nArray.prototype.MyReduce = function (callback, initialArray) {\n  let instance = this;\n  if (!callback) {\n    return initialArray;\n  }\n  const fn = function (res, index) {\n    if (index >= instance.length) {\n      return res;\n    }\n    const currentValue = instance[index];\n    return fn(callback(res, currentValue, index, instance), index + 1);\n  };\n  return fn(initialArray, 0);\n};\nconst res = arr.MyReduce((result, currentValue, index, array) => {\n  return result + currentValue;\n}, 0);\nconsole.log(\"res\", res);"}},"/posts/algo/trie":{"title":"字典树 trie","data":{"":"图：Peter Tarka","概念#概念":"字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。","实现#实现":"字典树节点\nclass TrieNode {\n  constructor(key) {\n    this.key = key;\n    this.children = [];\n  }\n}\n字典树\nclass Trie {\n  constructor() {\n    this.root = new TrieNode(null);\n  }\n  /** 插入 */\n  insert(string) {\n    this._insert(string, this.root);\n  }\n  /**\n   * 插入数据到指定节点\n   * @param {string} string 数据\n   * @param {TrieNode} node 操作节点\n   */\n  _insert(string, node) {\n    if (!string) {\n      return;\n    }\n    let children = node.children;\n    let header;\n    // 遍历子节点，存在与第一个字符相等的节点赋值为 header\n    children.map(child => {\n      if (child.key === string[0]) {\n        header = child;\n      }\n    })\n    if (header) {\n      // 递归：除了第一个字符外的其他字符插入\n      this._insert(string.substring(1), header);\n    } else {\n      let node = new TrieNode(string[0])\n      if (!children.length) {\n        // 操作节点无子节点时，直接将操作节点push到子节点中\n        children.push(node);\n      } else {\n        // 否则，对比操作节点与子节点的ASCII码，按序插入到对应位置\n        let position = 0;\n        children.map(child => {\n          if (child.key < string[0]) {\n            position++;\n          }\n        })\n        children.splice(position, 0, node);\n      }\n      this._insert(string.substring(1), node);\n    }\n  }\n  /** 查找树中是否有string */\n  search(string) {\n    if (string === '' || !this.root.children.length) {\n      return false;\n    }\n    for (let i = 0; i < this.root.children.length; i++) {\n      if (this._search(string, this.root.children[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * 查找某数据是否在指定节点中\n   * @param {string} string \n   * @param {TrieNode} node \n   */\n  _search(string, node) {\n    if (node.key !== string[0]) {\n      return false;\n    }\n    let children = node.children;\n    // 无子节点的key值与string相同\n    if (!children.length && string.length === 1) {\n      return true;\n    }\n    if (children.length > 0 && string.length > 1) {\n      // 递归查询\n      for (let i = 0; i < children.length; i++) {\n        if (children[i].key === string[1]) {\n          return this._search(string.substring(1), children[i]);\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n  delete(string) {\n    if (this.search(string)) {\n      for (let i = 0; i < this.root.children.length; i++) {\n        if (this.root.children[i].key === string[0]) {\n          this._delete(string, this.root, i, string)\n          return true;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n  /**\n   * @param {string} string \n   * @param {TrieNode} parent \n   * @param {number} index \n   * @param {string} originString \n   */\n  _delete(string, parent, index, originString) {\n    // key值与string[0]相等的节点\n    let node = parent.children[index];\n    let children = node.children;\n    if (!children.length && string.length === 1) {\n      // string和node.key相等 且 node无子节点\n      parent.children.splice(index, 1);\n      return this.delete(originString.substring(0, originString.length - 1))\n      // this.delete(delStr.substring(0, delStr.length - 1))\n    } else if (children.length && string.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        if (children[i].key === string[1]) {\n          this._delete(string.substring(1), node, i, originString);\n          return true\n        }\n      }\n    }\n    return false;\n  }\n  show() {\n    this._show(this.root);\n  }\n  _show(node) {\n    node.children.map(child => {\n      console.log('parent: ' + node.key + '; node:', child);\n      if (child.children.length) {\n        this._show(child);\n      }\n    })\n  }\n}\n示例\nconst tree = new Trie();\ntree.insert('girl');\ntree.insert('boy');\ntree.insert('book');\ntree.insert('go');\nconsole.log(tree.search('b')); // false\nconsole.log(tree.search('boy')); // true\ntree.delete('go')\nconsole.log(tree.root);\ntree.show();"}},"/posts/css/dashboard1":{"title":"极品透明Dashboard样式分享","data":{"":"发现了别人做的一个非常好看的dashboard样式，分享给大家","codepen示例#CodePen示例":""}},"/posts/css/bfc":{"title":"Block Formatting Context 块级格式化上下文","data":{"":"图：AI","bfc定义#BFC定义":"BFC - Block Formatting Context 块级格式化上下文 BFC的定义：1、一个BFC区域包含创建该上下文元素的所有子元素，但是不包括创建了新的BFC的子元素的内部元素，2、BFC是一块块独立的渲染区域，可以将BFC看成是元素的一种属性，拥有了这种属性的元素就会使他的子元素与世隔绝，不会影响到外部其他元素\n<div className=\"box1\" id=\"bfc1\">\n  <div className=\"box2\"></div>\n  <div className=\"box3\"></div>\n  <div className=\"box4\"></div>\n  <div className=\"box5\" id=\"bfc2\">\n    <div className=\"box6\"></div>\n    <div className=\"box7\"></div>\n    <div className=\"box8\"></div>\n  </div>\n</div>\n假设box1和box5是两个BFC区域，那么根据上述原理能理解到的就是，box1这个BFC区域包含了子元素box2，box3，box4，box5。\n但不包括box678。而box5这块BFC区域则包含了box678这三个子元素。","总结#总结:":"1,每一个BFC区域只包括其子元素，不包括其子元素的子元素。\n2,每一个BFC区域都是独立隔绝的,互不影响","怎样使一个元素变成bfc区域#怎样使一个元素变成BFC区域":"大概有以下几种办法：\n·body根元素\n·设置浮动，不包括none\n·设置定位，absoulte或者fixed\n·行内块显示模式，inline-block\n·设置overflow，即hidden，auto，scroll\n·表格单元格，table-cell\n·弹性布局，flex\n那知道了怎么让元素变成BFC区域后，这个BFC到底有什么作用呢？根据上面的描述，BFC区域有一个特点，那就是独立。不会影响外部元素。根绝这个特性就能解决很多布局问题。","1解决外边距的塌陷问题垂直塌陷#1，解决外边距的塌陷问题(垂直塌陷)":"开发中，前端的布局手段，离不开外边距margin，那么，也会遇到一些问题，例如外边距的垂直塌陷问题。看上面son2的例子，两个盒子都有100的外边距，但是实际上两个盒子的距离却只有100px，按理来说应该是200才对，这就是margin垂直塌陷。那要解决这个问题只需要给这两个盒子都加一个父元素，并且将这个父元素设置成BFC区域，就可以解决这个margin塌陷的问题。","2利用bfc解决包含塌陷#2，利用BFC解决包含塌陷":"有时候我们给子元素加margin可能会带着父元素一起跑, 如father1很显然，我们只是想要子元素距离父元素50px，而不是整个父元素都一起跑。这个时候用padding可以解决问题，但是用BFC同样可以解决只需要将父元素变为BFC区域，就能得到解决因为将父盒子变成一个独立的区域，这样在BFC区域内部的任何操作，都不会影响到外部","3清除浮动#3.清除浮动。":"大家都知道，浮动会导致父元素高度塌陷，那大家还记得怎么清除浮动吗？相信很多人都知道：overflow：hidden嘛。\n相信在认识BFC之前大家肯定不太清楚为什么overflow：hidden可以清除浮动。\n现在知道了，BFC区域内的子元素任何边动都是不会影响到外部元素的。所以BFC区域同样可以清除浮动带来的影响。\n如son3","4bfc可以阻止标准流元素被浮动元素覆盖#4.BFC可以阻止标准流元素被浮动元素覆盖":"大家都知道，浮动的元素会脱离文档流，跑到上一个层面，也就是和原本的元素们不在一个层面了。所以可能会导致浮动元素覆盖基本元素的问题。那么这个时候我们只需要让蓝色区域触发BFC，就可以做到不受浮动元素影响如red, blue一个BFC区域只包含其子元素，不包括其子元素的子元素。\n并不是所有的元素都能成为一块BFC区域，只有当这个元素满足条件的时候才会成为一块BFC区域。\n不同的BFC区域之间是相互独立的，互不影响的。利用这个特性我们可以让不同BFC区域之间的布局不产生影响。"}},"/posts/css/jsbackground":{"title":"用JS绘制背景，让CSS直接使用 'background:paint(xxx)'","data":{"":"图：Nguyen Nhut","css对象#CSS对象":"CSS.paintWorklet.addModule 是一个新方法，具体参见\nhttps://developer.mozilla.org/en-US/docs/Web/API/Worklet/addModule","indexhtml#index.html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    .radius {\n      width: 200px;\n      height: 200px;\n      background: paint(transparent-grid)\n    }\n  </style>\n  <script>\n    CSS.paintWorklet.addModule('jsbackground.js');\n  </script>\n</head>\n<body>\n  <div class=\"radius\"></div>\n</body>\n</html>","jsbackgroundjs#jsbackground.js":"// transparent-grid命名和CSS中的对应\nregisterPaint(\n  \"smooth-corners\",\n  class {\n    paint(ctx, size) {\n      ctx.strokeStyle = \"black\";\n      ctx.lineWidth = 4;\n      ctx.beginPath();\n      ctx.arc(200, 200, 50, 0, 2 * Math.PI);\n      ctx.stroke();\n      ctx.closePath();\n    }\n  }\n);\nregisterPaint(\n  \"transparent-grid\",\n  class {\n    paint(context, size) {\n      // 两个格子颜色\n      var color1 = \"#fff\",\n        color2 = \"#eee\";\n      // 格子尺寸\n      var units = 8;\n      // 横轴数轴循环遍历下\n      for (var x = 0; x < size.width; x += units) {\n        for (var y = 0; y < size.height; y += units) {\n          context.fillStyle = (x + y) % (units * 2) === 0 ? color1 : color2;\n          context.fillRect(x, y, units, units);\n        }\n      }\n    }\n  }\n);","效果#效果":"svg矢量图，可以用来做图片编辑时的背景"}},"/posts/css/less-foreach":{"title":"Less中的for和forEach循环","data":{"":"图：Vivivian","for循环#for循环":"循环的使用是保持代码干燥和避免重复的好方法。与 Sass 不同，Less 中没有用于编写循环的内置@for或@each指令，但它仍然可以使用递归混合来编写。递归 mixin 只不过是一个不断调用自身的 mixin。使用 Less 编写的循环有四个关键组件，它们如下所示：\n带有保护表达式的 mixin。当满足循环的退出条件时，守卫用于终止循环。就 JavaScript for 循环 ( for([initialization]; [condition]; [final-expression])) 而言，守卫是[condition].\n对 mixin 的主要调用以执行第一次迭代。对 mixin 的主要调用可以在选择器块内进行（如果 mixin 没有选择器包装其所有内容）或从选择器块外部（如果 mixin 有选择器包装其内容）。就 JavaScript for 循环而言，此主要调用用作[initialization]设置类计数器变量的基值。\n从内部调用 mixin 以使其递归。此调用通常将计数器变量的递增或递减值作为参数传递。因此它调用了后续的迭代。就 JS for 循环而言，这[final-expression]与下一个调用一起执行。\n最后但并非最不重要的一点是，mixin 的其他内容等价statement于典型的 for 循环语法。\n下面是一个用 Less 编写的简单 for 循环，它创建多个#img*选择器（其中 * 是一个数字）并将background-image属性设置为image*.png\n.for-loop(@index) when (@index > 0) { /* recursive mixin with guard expression - condition */\n  /* the statement */\n  #img@{index} {\n    background-image: url(\"http://mysite.com/image@{index}.png\");\n  }\n  /* end of the statement */\n  .for-loop(@index - 1); /* the next iteration's call - final-expression*/\n}\n.for-loop(3); /* the primary call - initialization */\n编译的CSS：\n#img3 {\n  background-image: url(\"http://mysite.com/image3.png\");\n}\n#img2 {\n  background-image: url(\"http://mysite.com/image2.png\");\n}\n#img1 {\n  background-image: url(\"http://mysite.com/image1.png\");\n}","foreach-循环#forEach 循环":"Less 中的 for-each 循环与 for 循环具有相同的关键组件，但有以下区别：\n包含必须迭代的项目列表的变量。\nextract()基于循环索引提取变量中每个项目的函数。\n一个length()计算数组长度的函数（即列表中的项目数）并在主 mixin 调用（for [initialization]）中使用它。\n下面是一个用 Less 编写的 for-each 循环示例，它遍历@images变量中的每个项目，创建一个与项目/图像名称相同的#id选择器，并为其设置背景图像属性id\n@images: cat, dog, apple, orange; /* the array list of items */\n.for-each-loop(@index) when (@index > 0) { /* recursive mixin call with guard - condition */\n  \n  @image: extract(@images, @index); /* extract function to fetch each item from the list */\n  \n /* the statement */\n  #@{image} {\n    background-image: url(\"http://mysite.com/@{image}.png\");\n  }\n  /* end of the statement */\n  .for-each-loop(@index - 1); /* the next iteration's call - final-expression */\n}\n.for-loop(length(@images)); /* the primary call with length() function - initialization */\n编译的CSS：\n#orange {\n  background-image: url(\"http://mysite.com/orange.png\");\n}\n#apple {\n  background-image: url(\"http://mysite.com/apple.png\");\n}\n#dog {\n  background-image: url(\"http://mysite.com/dog.png\");\n}\n#cat {\n  background-image: url(\"http://mysite.com/cat.png\");\n}"}},"/posts/css/liststyle":{"title":"CSS联合选择器区分列表元素个数不同所要求的不同样式","data":{"":"图：Nguyen Nhut\n对于列表，在有些时候针对于不同个数的item会有不同的显示，比如col份数，用js固然可以，是否可以用css更简便的实现呢？","实现#实现":"<!DOCTYPE html>\n<html>\n<head>\n  <title>css3</title>\n  <style type=\"text/css\">\n    * {\n      box-sizing: border-box;\n    }\n    ul {\n      width: 100%;\n      margin: 0;\n      padding: 0;\n      font-size: 0;\n    }\n    li {\n      margin: 0;\n      padding: 0;\n      display: inline-block;\n      vertical-align: top;\n      font-size: 13px;\n      border: 1px solid rgba(128, 128, 128, 0.5);\n      margin-bottom: 10px;\n      height: 100px;\n      text-align: center;\n      font-weight: bold;\n      line-height: 100px;\n      color:#fff;\n    }\n    /*ul只有一个子元素的样式*/\n    li:nth-last-child(1):first-child {\n      width: 100%;\n      background: #000;\n    }\n    /*ul有2个子元素的样式*/\n    /*li:nth-last-child(2):first-child,  是倒数第二个元素，又是第一个元素，说明li的父元素ul有2个子元素（起到了 判断某父元素下有几个子元素 的作用）*/\n    li:nth-last-child(2):first-child,\n    /* ~ 选择位于li:nth-last-child(2):first-child 即 第一个子元素之后的元素*/\n    li:nth-last-child(2):first-child~li {\n      width: calc(100% / 2);\n      background: #202020;\n    }\n    /*ul有3个子元素的样式*/\n    /*第一个元素宽度为1/3，字体颜色为蓝色*/\n    ul>*:nth-last-child(3):first-child {\n      width: calc(100% / 3);\n      background: #222;\n    }\n    /*第一个元素之后的第一个元素（即 有3个子元素的ul 的 第 2 个元素）*/\n    ul>*:nth-last-child(3):first-child~li:nth-last-child(2) {\n      width: calc(100% / 3);\n      background: #333;\n    }\n    /*第一个元素之后的第一个元素（即 有3个子元素的ul 的 第 3 个元素）*/\n    ul>*:nth-last-child(3):first-child~li:nth-last-child(1) {\n      width: calc(100% / 3);\n      background: #444;\n    }\n  </style>\n</head>\n<body>\n  <ul class=\"list\">\n    <li>one</li>\n  </ul>\n  <ul class=\"list\">\n    <li>two</li>\n    <li>two</li>\n  </ul>\n  <ul class=\"list\">\n    <li>three</li>\n    <li>three</li>\n    <li>three</li>\n  </ul>\n</body>\n</html>","codepen示例#CodePen示例":""}},"/posts/engin/ast":{"title":"JavaScript AST 抽象语法树","data":{"":"图：Mako Tsereteli","简介#简介":"AST（Abstract Syntax Tree，抽象语法树）在 Wikipedia 的定义如下：\nIn computer science, an abstract syntax tree (AST), or just syntax tree, is a tree representation of the abstract syntactic structure of source code written in a programming language.\n指的是：源代码的抽象语法结构的树状表现形式","编译原理#编译原理":"先回顾下编译原理的几大过程：\n**词法分析**   ===>   单词与记号、正则表达式、有限自动机、从正则表达式到有限自动机的转换、词法分析器的实现\n        ││\n    **语法分析**   ===>   上下文无关文法、递归下降分析、LR 分析、错误处理、语法分析器自动生成\n        ││\n    **语义分析**   ===>   类型系统、属性文法、语法制导翻译、符号表管理、抽象语法树、线性中间表示、图中间表示\n        ││\n  **中间代码生成**   ===>   变量地址分配、算术表达式翻译、布尔表达式翻译、数组、结构体和字符串的翻译、控制流的翻译、函数调用的翻译\n        ││\n**目标代码优化与生成**   ===>   目标体系结构、树匹配代码生成、基于动态规划的代码生成、寄存器分配、指令调度、控制流分析、数据流分析、死代码删除、常量传播、拷贝传播、静态单赋值形式\nJavaScript 是一门解释型语言，但其在执行过程中仍然需要即时编译（JIT），其编译过程也遵循这些流程：\n**分词／词法分析**   ===>   把字符串分解成有意义的代码块，这些代码块被称为词法单元\n      ││\n**解析／语法分析**   ===>   词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，即 AST\n      ││\n  **代码生成**   ===>   将 AST 转换为可执行代码\n总结一下：通过 Parser 把代码转化为抽象语法树（AST），该树定义了代码的结构，通过对树的处理，能实现对代码的分析、优化等操作。","javascript-词法解析#JavaScript 词法解析":"通过分析每行代码字符串，通过识别关键字来判断某句代码是什么表达式类型，然后把这些信息生成 AST 语法树\nif (b === 1) {\n  a = 2;\n  alert(a);\n}\n词法分析思维抽象如图","javascript-语法解析#JavaScript 语法解析":"在编译过程中，代码会被映射为 AST，那么就可以通过 AST 对代码进行分析、转换。像 webpack、babel、eslint 等涉及代码分析的工具类库，其背后都有 AST 的影子。先看看 AST 长什么样，通过 AST Explorer 或者Parser可以实时解析和查看 JavaScript 的 AST。\nconst a = 1;\n对应的 AST\n{\n  \"type\": \"Program\",\n  \"body\": [\n    {\n      \"type\": \"VariableDeclaration\",\n      \"declarations\": [\n        {\n          \"type\": \"VariableDeclarator\",\n          \"id\": {\n            \"type\": \"Identifier\",\n            \"name\": \"a\"\n          },\n          \"init\": {\n            \"type\": \"Literal\",\n            \"value\": 1,\n            \"raw\": \"1\"\n          }\n        }\n      ],\n      \"kind\": \"const\"\n    }\n  ],\n  \"sourceType\": \"script\"\n}\nAST 的格式每种 Parser 都有各自的标准，Esprima 的语法树结构文档 Syntax Tree Format，下面是 type 的类型列表。\ntype Expression =\n  | ThisExpression\n  | Identifier\n  | Literal\n  | ArrayExpression\n  | ObjectExpression\n  | FunctionExpression\n  | ArrowFunctionExpression\n  | ClassExpression\n  | TaggedTemplateExpression\n  | MemberExpression\n  | Super\n  | MetaProperty\n  | NewExpression\n  | CallExpression\n  | UpdateExpression\n  | AwaitExpression\n  | UnaryExpression\n  | BinaryExpression\n  | LogicalExpression\n  | ConditionalExpression\n  | YieldExpression\n  | AssignmentExpression\n  | SequenceExpression;","javascript-parser#JavaScript Parser":"介绍完 AST 树，下面列举常用的 JavaScript Parser\nEsprima\nUglifyJS2\nTraceur\nacorn\nespree eslint\nShift\n各个 parser 的速度对比可以参见 Speed Comparison","应用#应用":"AST 的应用很广，从技术角度出发，所有涉及对代码处理的场景，AST 都有其用武之地。编译器、代码压缩、代码混淆、代码优化，所有的 lint（不仅仅是 JavaScript），所有的打包构建工具及其插件，包括 webpack、rollup、parcel、browserify 等...🍻"}},"/posts/engin/babel":{"title":"babel核心","data":{"":"图：Amrit Pal Singh","babelcore#babel/core":"const babel = require('@babel/core');\nconst code = \"class glass {get name() { return '水杯' }}\";\nconst options = {\n    presets: ['@babel/preset-env'],\n}\n// 直接转换\nconst result1 = babel.transform(code, options);\n// 异步转换\nbabel.transformAsync(code, options).then(res => console.log(res));\nconsole.log(result);\n// 加载文件同步转换\nconst content = babel.transformFileSync('./babel-file.js');\nconsole.log(content);\n// 生成AST语法树\nconst parsedAst = babel.parse(code, { parserOpts: { allowReturnOutsideFunction: true } });\nconsole.log(parsedAst);\n// 通过语法树转换\nconst result3 = babel.transformFromAst(parsedAst, code, options);\nconsole.log(result3);\n// 生成config\nconst config = babel.loadPartialConfig(options); // 提前生成config\nconst result = babel.transform(code, config.options);\nconsole.log(result);\nbabel/core的作用\n= \nbabel/parser(词法分析+语法分析 = AST) \n+ \nbabel/traverse (AST 经过plugin转化) \n+ \nbabel/generator (AST 生成code字符串)","babelparser#babel/parser":"实际就是babel内置的parser\nbabelParser.parse(code, options) 等价于babel.parse(code, options); 会return一个AST树\nconst babel = require('@babel/core');\nconst code = \"class glass {get name() { return '水杯' }}\";\nconst options = {\n    presets: ['@babel/preset-env'],\n}\nconst parsedAst = babel.parse(code);\nconsole.log(parsedAst);\nimport { parse } from '@babel/parser';\nconst ast = parse(code);\nconsole.log(ast);","babelgenerator#babel/generator":"读取ast，并将它转化成代码以及source map.\nimport { parse } from '@babel/parser';\nimport generate from '@babel/generator';\nconst ast = parse(code);\nconst output = generate(ast, {minified: true}, code);\nconsole.log(output);\ngenerater的作用仅仅是进行转化成代码，不会进行处理，与babel/core一节的transformFromAst不同，transformFromAst是会经过plugin的处理的，实质上是babel/traverse + generater的结合.","总结#总结":"实际上，通过babel/core的实现也可以看到，babel/core的依赖就是babel/parser + babel/traverse + babel/generator。"}},"/posts/engin/microapp":{"title":"微前端解决方案-qiankun","data":{"":"图：","什么是微前端#什么是微前端？":"微前端就是将不同的功能按照不同的维度拆分成多个子应用, 通过主应用来加载这些子应用。\n@玉伯: 微前端的前提，还是得有主体应用，然后才有微组件或微应用，解决的是可控体系下的前端协同开发问题（含空间分离带来的协作和时间延续带来的升级维护）。\n微前端的核心在于拆, 拆完后再合!","为什么要去使用微前端#为什么要去使用微前端？":"不同团队间开发同一个应用技术栈不同怎么破？\n希望每个团队都可以独立开发，独立部署怎么破？\n项目中还需要老的应用代码怎么破？\n我们是不是可以将一个应用划分成若干个子应用，将子应用打包成一个个的 lib。当路径切换时加载同的子应用。这样每个子应用都是独立的，技术栈也不用做限制了！从而解决了前端协同开发问题","核心准则微前端目标#核心准则/微前端目标":"技术栈无关\n主框架不限制接入应用的技术栈，微应用具备完全自主权\n向前向后兼容\n独立开发、独立部署\n微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n增量升级\n在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\n独立运行时\n每个微应用之间状态隔离，运行时状态不共享","核心原理#核心原理":"通过动态加载 html 分析其加载的 css 和 js, 然后动态加载其 js 和 css","微前端的两种形态#微前端的两种形态":"","主应用结构#主应用结构":"此 demo 展示最基本的原理，不是最终的方案实现","微前端框架临的共性问题和解决方案#微前端框架⾯临的共性问题和解决方案":"JS 隔离\nCSS 隔离\nHTML entry\n按需加载\n预加载\n父子应用通信\n子应用并行\n子应用嵌套\n公共依赖","中心化#中心化":"应用注册表。这个应用注册表拥有每个应用及对应的入口。在前端领域里，入口的直接表现形式可以是路由，又或者对应的应用映射。","标识化应用#标识化应用":"我们需要一个标识符来标识不同的应用，以便于在安装、卸载的时候，能寻找到指定的应用。一个简单的模式，就是通过康威定律来命名应用。应用生命周期管理。高内聚，低耦合。","生命周期#生命周期":"微前端应用作为一个客户端应用，每个应用都拥有自己的生命周期：\nLoad，决定加载哪个应用，并绑定生命周期\nbootstrap，获取静态资源\nMount，安装应用，如创建 DOM 节点\nUnload，删除应用的生命周期\nUnmount，卸载应用，如删除 DOM 节点、取消事件绑定\n精简后\nbootstrap\nmount\nonmount","两组问题#两组问题":"","应用加载和切换#应用加载和切换":"应⽤路由劫持和转发应⽤接⼊：协议接⼊\n应用加载 App Entry\n加载时机\n最优加载是运行时 HTML Entry","应用的隔离和通信#应用的隔离和通信":"JS 变量隔离、JS 沙箱快照沙箱\n代理沙箱\n样式隔离、CSS隔离\n子应用间的样式隔离父子应用样式隔离\n影子DOM方案","应用通信#应用通信":"基于路由基于事件总线\n基于状态传递 props、全局状态管理器 dva/redux\n通信方式总结","faq#FAQ":"","为什么不是-iframe#为什么不是 iFrame?":"为什么","组件widget-与微应用的区别#组件/widget 与微应用的区别?":"独立开发独立部署的——微应用不是独立开发独立部署的——组件/widget组件/widget 和 微应用可以按具体业务需求进行提升/转化"}},"/posts/engin/miniwebpack":{"title":"mini webpack实现","data":{"":"图：Amrit Pal Singh","实现#实现":"废话补多说，直接上代码\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst parser = require(\"@babel/parser\");\nconst traverse = require(\"@babel/traverse\").default;\nconst babel = require(\"@babel/core\");\nconst options = require(\"./mini-webpack.config\");\nclass MiniWebpack {\n  constructor(options) {\n    this.options = options;\n  }\n  parse = (filename) => {\n    // 读取文件\n    const fileBuffer = fs.readFileSync(filename, \"utf-8\");\n    // 转换成抽象语法树\n    const ast = parser.parse(fileBuffer, { sourceType: \"module\" });\n    const dependencies = {};\n    // 遍历抽象语法树\n    traverse(ast, {\n      // 处理ImportDeclaration节点\n      ImportDeclaration({ node }) {\n        const dirname = path.dirname(filename);\n        const newDirname = \"./\" + path.join(dirname, node.source.value).replace(\"\\\\\", \"/\");\n        dependencies[node.source.value] = newDirname;\n      },\n    });\n    // 将抽象语法树转换成代码\n    const { code } = babel.transformFromAst(ast, null, {\n      presets: [\"@babel/preset-env\"],\n    });\n    return {\n      filename,\n      dependencies,\n      code,\n    };\n  };\n  analyse = (entry) => {\n    // 解析入口文件\n    const entryModule = this.parse(entry);\n    const graphArray = [entryModule];\n    // 循环解析模块，保存信息\n    for (let i = 0; i < graphArray.length; ++i) {\n      const { dependencies } = graphArray[i];\n      Object.keys(dependencies).forEach((filename) => {\n        graphArray.push(this.parse(dependencies[filename]));\n      });\n    }\n    const graph = {};\n    // 生成依赖图谱对象\n    graphArray.forEach(({ filename, dependencies, code }) => {\n      graph[filename] = {\n        dependencies,\n        code,\n      };\n    });\n    return graph;\n  };\n  generate = (graph, entry) => {\n    return `\n        (function(graph){\n            function require(filename){\n                function localRequire(relativePath){\n                    return require(graph[filename].dependencies[relativePath]);\n                }\n                const exports = {};\n                (function(require, exports, code){\n                    eval(code);\n                })(localRequire, exports, graph[filename].code)\n                return exports;\n            }\n            \n            require('${entry}');\n        })(${graph})\n        `;\n  };\n  fileOutput = (output, code) => {\n    const { path: dirPath, filename } = output;\n    const outputPath = path.join(dirPath, filename);\n    // 如果没有文件夹的话，生成文件夹\n    if (!fs.existsSync(dirPath)) {\n      fs.mkdirSync(dirPath);\n    }\n    // 写入文件中\n    fs.writeFileSync(outputPath, code, \"utf-8\");\n  };\n  run = () => {\n    const { entry, output } = this.options;\n    const graph = this.analyse(entry);\n    // stringify一下依赖图谱对象，防止在模板字符串中调用toString()返回[object Object]\n    const graphStr = JSON.stringify(graph);\n    const code = this.generate(graphStr, entry);\n    this.fileOutput(output, code);\n  };\n}\nconst miniWebpack = new MiniWebpack(options);\nminiWebpack.run();\n可以在 codesadebox 里测试\nTerminal 里执行 node main.js"}},"/posts/engin/performance":{"title":"Web 前端性能优化","data":{"":"图：Amrit Pal Singh","前端页面生命周期#前端页面生命周期":"1、用户在浏览器中输入 url 地址2、浏览器解析域名得到服务器 ip 地址浏览器会首先从缓存中找是否存在域名，如果存在就直接取出对应的 ip 地址，如果没有就开启一个 DNS 域名解\n析器。DNS 域名解析器会首先访问顶级域名服务器，将对应的 ip 发给客户端；然后访问根域名解析器，将对应的\nip 发给客户端；最后访问本地域名服务器，得到最终的 ip 地址。3、TCP 三次握手建立客户端和服务器的连接因为 HTTP 是基于 TCP 的可靠传输，所以在发送 http 数据报之前，需要先进行 TCP 的三次握手建立连接。三次\n握手过程如下：第一次握手：客户端--->服务端 ack=1,seq=x（x 随机生成）第二次握手：服务端--->客户端 ACK=1,ack=x+1,seq=y（y 随机生成）第三次握手：客户端--->服务端 ACK=1,ack=y+1,seq=x+1完成第三次握手时，实际上客户端已经与服务器建立了连接，所以第三次握手的报文已经可以携带数据了。4、客户端发送 HTTP 请求获取服务器端的静态资源5、服务器发送 HTTP 响应报文给客户端，客户端获取到页面静态资源6、TCP 四次挥手关闭客户端和服务器的连接数据传输完毕后，TCP 会进行四次挥手断开连接，释放资源。四次挥手过程如下：第一次挥手：客户端--->服务器 FIN=1,ack=1,seq=u 客户端状态变为 FIN_WAIT_1第二次挥手：服务器--->客户端 ACK=1,ack=u+1,seq=v 服务器状态变为 CLOSE_WAIT，TCP 进入半关闭状态第三次挥手：服务器--->客户端 FIN=1,ACK=1,ack=u+1,seq=w 服务器状态变为 LAST_ACK第四次挥手：客户端--->服务器 ACK=1,ack=w+1,seq=u+1 客户端状态变为 TIME_WAIT，此时 TCP 未释放，需要等\n待计时器计时完成后，客户端状态变为 CLOSED7、浏览器解析文档资源并渲染页面浏览器解析文档资源并渲染页面流程：（1）解析 html 资源，构建 DOM Tree（2）解析 css 资源，构建 CSS Rule Tree（3）JS 通过 DOM API 和 CSS OM API 来操作 DOM Tree 和 CSS Tree（4）解析完成后综合 DOM Tree 和 CSS Tree 会生成 Render Tree，计算每个元素的位置，这个过程就是回流\n（layout or reflow）（5）调用操作系统 Native GUI 的绘制（6）页面绘制完成","网络模型#网络模型":"OSI （理论）\n模型武术忘传悔表赢\n应用层\n表示层\n会话层\n传输层\n网络层\n数据链路层\n物理层\nTCP/IP （标准）\n模型鼠王传音\n应用层\n传输层\n网络层\n数据链路层","http-头部#http 头部":"http 协议主要组成部分：状态行 - General 请求头 - Request Headers 响应头 - Respones Headers 状态行\n在状态行中我们其实一般来说只需要关注Request Method和Status Code就可以了。请求头\n一般来说前端开发需要关注请求头数据大概如下：Accept - 客户端喜欢接受的数据类型 Accept-Encoding - 一般我们需要看的值就是 gzip，一般我们的资源都会\n进行 gzip Accept-Language - 客户端支持的语言，按顺序使用 Cache-Control - 浏览器请求资源的缓存设置\n，no-cache 会比较常用，意思就是在使用缓存资源的时候必须先请求服务器进行验证 Pragme - 中间服务器不返\n还资源标识，为兼容 http1.0 Connection - 开启持久链接，默认是 keep-alive(http1.1 才有哟) Cookie - 就\n是将你浏览器中符合 cookie 的 path 中的 cookie 字段组成字符串提交给服务器 Referer - 页面来源，就是跳\n转进当前页面的上一个页面路径 Content-Type - 告诉服务器提交的数据体是那种格式。响应头\n响应头对于前端来说就十分重要了，无论是js或者css静态资源，或者是接口返回数据，里面的信息都十分重要。Access-Control-Allow-Credentials - 跨域允许提交 cookie Access-Control-Allow-Methods - 跨域允许提交方\n式 Access-Control-Allow-Origin - 跨域允许的域名路径（如果你的接口跨域可以检查一下这个哟，一般设置*\n即可） Cache-Control - http 缓存策略 Connection - 开启持久链接，默认是 keep-alive(http1.1 才有哟)\nContent-Encoding - 一般我们需要看的值就是 gzip，一般我们的资源都会进行 gzip Content-Type - 告诉浏览\n器以何种方式接收数据。 Set-Cookie - 服务器对浏览器设置 cookie 字段补充几个属性Expires - 缓存到期时间 X-Cache - CDN 标识，有时候我们看 CDN 资源是否回源了，可以通过这个标识知道是否\n命中到 CDN Content-Type 类型一般前端使用的 Content-Type 的类型有 3 种：application/x-www-form-urlencoded - 默认方式，原生 ajax，jquery 都默认使用这种方式提交，该方式会将请\n求的 json 数据格式序列化变成 key=value&key=value。 multipart/form-data - 这种方式一般是 form 表单提\n交文件必须使用这种方式 application/json - 其实就是不进行序列化，直接以 JSON 方式提交，个人十分喜欢\ncontent-type 属性在 request 头中是代表以何种数据格式进行提交，response 头中是代表浏览器需要以何种方\n式接收数据以及解析数据。keep-alive(TCP 链接持久化) 在 HTTP/1.0 里，为了实现 client 到 web-server 能支持长连接，必须在 HTTP\n请求头里显示指定 Connection:keep-alive。在 HTTP/1.1 里，就默认是开启了 keep-alive，要关闭 keep-alive 需要在 HTTP 请求头里显示指定\nConnection:close。如果不开启 keep-alive 的情况下，那么每一次请求都会重复 3 次握手，如果开启了的话，在一定时间内（这个\n时间是服务器配置的）可以复用同一个 TCP。从而达到了性能的优化。","图像加载优化#图像加载优化":"图像延迟加载图片延时加载，是真实项目中的一个非常重要的性能优化手段。如果不做图片的延时加载，那也页面\n渲染的时候，同时也要把图片资源请求回来，进行渲染，这样会阻碍页面的渲染进度，导致首次加载页面的速度很\n慢，延迟加载一方面可以提要页面的加载速度，另一方面可以减少没必要的网络消耗这里推荐使用 IntersectionObserver\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      http-equiv=\"X-UA-Compatible\"\n      content=\"IE=edge\"\n    />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\"\n    />\n    <title>Document</title>\n  </head>\n  <style>\n    * {\n      margin: 0;\n    }\n    .imageLazyBox {\n      width: 236px;\n      height: 420px;\n      background: url(./images/loading.gif) no-repeat center center #eee;\n      background-size: 100px 100px;\n      margin: 1000px 0px;\n    }\n    .imageLazyBox img {\n      width: 100%;\n      height: 100%;\n      /* 开始图片隐藏：因为在ie 浏览器中，如果图片src 是空的，或者加载图片是错误的，图片不隐藏 ,会显示一个X \n        效果，很难看，所以图片没有加载之前还是让他隐藏比较好\n        办法一: display:none;这种办法加载完成真实的图片后，还需让他display:blok;这样触发dom的回流重汇，性能消耗比较大\n        办法二 ：opacity:0 ;transition:opacity: .3s; ->推荐方案，一方面加载真实图片后，我们只需要设置opacity:1;\n        这样一方面不会引发dom的回流重汇，一方面可以css3实现出渐现的效果\n        */\n      opacity: 0;\n      transition: opacity 1s;\n      /* display: none; */\n    }\n  </style>\n  <body>\n    <div class=\"imageLazyBox\">\n      <img\n        src=\"\"\n        alt=\"\"\n        lazy-image=\"./images/img1.jpeg\"\n      />\n    </div>\n  </body>\n</html>\n<script>\n  function imageLazyFun(imageLazyBox) {\n    let imageItem = imageLazyBox.querySelector(\"img\"),\n      lazy_image = imageItem.getAttribute(\"lazy-image\");\n    imageItem.src = lazy_image;\n    imageItem.onload = function () {\n      imageItem.style.opacity = 1;\n    };\n    imageItem.removeAttribute(\"lazy-image\");\n    imageItem.isLoad = true;\n  }\n  let imageLazyBox = document.querySelector(\".imageLazyBox\");\n  let ob = new IntersectionObserver((changes) => {\n    // 我们监听的dom元素与可视窗口的交叉信息\n    let item = changes[0];\n    target = item.target;\n    // 符合条件:盒子已经完全出现在视口中\n    if (item.isIntersecting) {\n      // 符合条件：盒子已经完全出现在视口中\n      imageLazyFun(target);\n      // 处理过一次延迟加载，以后这个元素出现无需要再次监听处理\n      ob.unobserve(target);\n    }\n  });\n  // 监听dom元素\n  ob.observe(imageLazyBox);\n  // 解除监听\n  // ob.unobserve(imageLazyBox)\n</script>","构建优化#构建优化":"并行构建（thread-loader、happypack）构建缓存（cache-loader、hard-source-webpack-plugin）代码切割（splitChunks）：按需加载，分离基础库和公共代码库。通过分割打包，可以将公共代码或外包依赖项\n单独打包，并从客户端缓存中受益。在此过程中，整个的包体积没有变小，且需要执行的请求可能会变多，但缓存\n的好处可以弥补这一成本。Hash 缓存减少构建（external、DllPlugin）Tree Shaking预渲染分离样式：通过 css-loader、style-loader 等一系列 loader 打包好了的 css，如果是通过内联到 js 中，就会\n存在 css 无法缓存、增加了 js 文件体积和未样式化元素闪动（FOUC）问题。静态资源、图片内联： 使用 url-loader 内联资源，将小图像转换为 base64 形式的字符串，从而减少 http 请\n求。第三方库 external第三方库按需加载","渲染优化#渲染优化":"","减少不必要的回流#减少不必要的回流":"js 处理 -> 计算样式 -> 页面布局 -> 绘制 -> 合成\n渲染过程\n解析获取到的 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树\n将 DOM 树和 CSSOM 树进行结合，生成渲染树（render tree）\n3.根据生成的渲染树，进行回流（Layout）,得到节点的几何信息（位置，大小）4.重绘（Painting）：根据渲染树以及回流得到的几何信息，得到节点的绝对像素（像素，背景色，外观等）5.Display 将像素发送给 GPU，展示在页面上。\n回流\n浏览器会把获取到的 HTML 代码解析成一个 DOM 树，html 中的每一个元素都是 DOM 树的一个节点，根节 点也就\n是我们说的 document 对象。在渲染树中的一部分（或者全部）因为元素的规模尺寸、布局 、显隐等改 变而需要\n重新构建，这就称为回流。每次页面至少会发生一次回流，就是在页面第一次渲染的时候。\n何时发生回流?\n添加或者删除可见的 DOM 元素元素的位置发生变化元素的尺寸发生变化（包括外边距、内边 距 、边框大小、高\n度和宽度等）内容发生变化，文本或者图片被另一个不同尺寸的图片所代替页面开始渲染的 时 候浏览器的窗口尺\n寸变化（回流是根据视口的大小来计算元素的位置和大小的）\n重绘 在渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，不影响布局，就称为重绘\n。\n什么时候发生重绘？\n背景色改变样式发生改变的时候\n区别\n回流必定会引起重绘，重绘一定不会引起回流回流会导致页面重排，影响性能","恰当的使用-web-worker#恰当的使用 web worker":"由于设计原因，长期以来浏览器中 JS 都是单线程工作的，我们通过 EventLoop 驱动异步事件完成工作。然而随\n着前端页面越来越复杂，有些应用不可避免的要在前端执行大量的计算，这种情况会较长一段时间占用主线程，用\n户会感觉到明显的页面卡顿。在这种场景下我们可以使用 WebWorker 来解决问题。\n// main.js\nconst worker = new Worker(\"./worker.js\");\nworker.onmessage = (e) => {\n  console.log(e.data);\n};\nworker.postMessage(\"hello worker\");\n// worker.js\nonmessage = (e) => {\n  console.log(e.data);\n  postMessage(\"hi from worker\");\n};\n// worker.js\nself.onmessage = (e) => {\n  console.log(e.data);\n  self.postMessage(\"hi from worker\");\n};","将一个大任务拆分成多个微任务#将一个大任务拆分成多个微任务":"const taskList = splitTask(BigTask);\nfunction processTaskList(taskStartTime) {\n  let taskFinishTime;\n  do {\n    const nextTask = taskList.pop();\n    processTask(nextTask);\n    taskFinishTime = window.performance.now();\n  } while (taskFinishTime - taskStartTime < 3);\n  if (taskList.length > 0) {\n    requestAnimationFrame(processTaskList);\n  }\n}\nrequestAnimationFrame(processTaskList);","缓存技术#缓存技术":"","强缓存#强缓存":"浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回 Status Code: 200 OK200 form memory cache : 不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。\n浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现 from memory cache。200 from disk cache： 不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览\n器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是 from disk cache。优先访问 memory cache,其次是 disk cache，最后是请求网络资源Expires：过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求 Cache-Control：当值设为\nmax-age=300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中\n强缓存。 cache-control：除了该字段外，还有下面几个比较常用的设置值：\n（1） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；\n（2） s-maxage：和\nmax-age 是一样的，不过它只针对代理服务器缓存而言；\n（3）public：指示响应可被任何缓存区缓存；\n（4）private：只能针对个人用户，而不能被代理服务器缓存；\n（5）no-cache：强制客户端直接向服务器发送请\n求,也就是说每次请求都必须向服务器发送。服务器接收到 请求，然后判断资源是否变更，是则返回新内容，否则\n返回 304，未变更。这个很容易让人产生误解，使人误 以为是响应不被缓存。实际上 Cache-Control: no-cache\n是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。\n（6）no-store：禁止一切缓存（这个才是响应不被缓存的意思）。\ncache-control是 http1.1 的头字段，expires 是 http1.0 的头字段,如果 expires 和 cache-control 同时存在，cache-control 会覆盖 expires，建议两个都写。","协商缓存#协商缓存":"向服务器发送请求，服务器会根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中，\n则返回 304 状态码并带上新的 response header 通知浏览器从缓存中读取资源；Last-Modifed/If-Modified-Since 和 Etag/If-None-Match 是分别成对出现的，呈一一对应关系\nEtag/If-None-Match：\nEtag：Etag 是属于 HTTP 1.1 属性，它是由服务器（Apache 或者其他工具）生成返回给前端，用来帮助服务器控制 Web\n端的缓存验证。 Apache 中，ETag 的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间\n（MTime）进行 Hash 后得到的。If-None-Match:当资源过期时，浏览器发现响应头里有 Etag,则再次像服务器请求时带上请求头 if-none-match(值是 Etag 的值\n)。服务器收到请求进行比对，决定返回 200 或 304\nLast-Modifed/If-Modified-Since：\nLast-Modified：浏览器向服务器发送资源最后的修改时间If-Modified-Since：当资源过期时（浏览器判断 Cache-Control 标识的 max-age 过期），发现响应头具有 Last-Modified 声明，则\n再次向服务器请求时带上头 if-modified-since，表示请求时间。服务器收到请求后发现有 if-modified-since\n则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则\n返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。Last-Modifed/If-Modified-Since 的时间精度是秒，而 Etag 可以更精确。Etag 优先级是高于 Last-Modifed 的，所以服务器会优先验证 EtagLast-Modifed/If-Modified-Since 是 http1.0 的头字段","性能检测#性能检测":"Performance 是 Chrome 浏览器自带的性能监测工具。根据我的使用，简单理解就是我们可以通过它录制一段时间\n的浏览器活动，通过活动的数据去分析页面是否存在提升的空间。想要获取页面的活动数据，那我们的第一步便是\n录制浏览器的活动。具体做法可参考 https://www.cnblogs.com/mushanya/p/16827522.html"}},"/posts/engin/point-report":{"title":"监控埋点方案","data":{"":"图：Mako Tsereteli","代码埋点#代码埋点":"代码埋点是最灵活，同时也是最耗时的一种方式。一般会封装自己的一套埋点上报的npm包, 提供给各业务线使用。一般我们需要上报什么信息呢？\n埋点的标识信息, 比如eventId, eventType\n业务自定义的信息, 比如电商, 点击一个按钮, 我们要上报用户点击的是哪个商品\n通用的设备信息, 比如用户的userId, useragent, deviceId, timestamp, locationUrl等等\n一般怎么上报？\n实时上报, 业务方调用发送埋点的api后, 立即发出上报请求\n延时上报, sdk内部收集业务方要上报的信息, 在浏览器空闲时间或者页面卸载前统一上报，上报失败会做补偿措施。","实现#实现":"// async-task-queue.ts\nimport { debounce } from 'lodash';\ninterface RequiredData {\n    timestamp: number | string;\n}\nclass TaskQueueStorableHelper<T extends RequiredData = any> {\n    public static getInstance<T extends RequiredData = any>() {\n        if (!this.instance) {\n            this.instance = new TaskQueueStorableHelper<T>();\n        }\n        return this.instance;\n    }\n    private static instance: TaskQueueStorableHelper | null = null;\n    protected store: any = null;\n    private STORAGE_KEY = 'my_store';\n    constructor() {\n        const localStorageValue = localStorage.getItem(this.STORAGE_KEY);\n        if (localStorageValue) {\n            this.store = JSON.parse(localStorageValue);\n        }\n    }\n    get queueData() {\n        return this.store?.queueData || [];\n    }\n    set queueData(queueData: T[]) {\n        this.store = {\n            ...this.store,\n            queueData: queueData.sort((a, b) => Number(a.timestamp) - Number(b.timestamp)),\n        };\n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.store));\n    }\n}\nexport abstract class AsyncTaskQueue<T extends RequiredData = any> {\n    private get storableService() {\n        return TaskQueueStorableHelper.getInstance<T>();\n    }\n    private get queueData() {\n        return this.storableService.queueData;\n    }\n    private set queueData(value: T[]) {\n        this.storableService.queueData = value;\n        if (value.length) {\n            this.debounceRun();\n        }\n    }\n    protected debounceRun = debounce(this.run.bind(this), 500);\n    protected abstract consumeTaskQueue(data: T[]): Promise<any>;\n    protected addTask(data: T | T[]) {\n        this.queueData = this.queueData.concat(data);\n    }\n    private run() {\n        const currentDataList = this.queueData;\n        if (currentDataList.length) {\n            this.queueData = [];\n            this.consumeTaskQueue(currentDataList); // .catch(() => this.addTask(currentDataList))\n        }\n    }\n}\n// track.ts\nimport axios from \"axios\";\nimport { AsyncTaskQueue } from \"./async-task-queue\";\nimport queryString from \"query-string\";\nimport { v4 as uuid } from \"uuid\";\ninterface TrackData {\n    seqId: number;\n    id: string;\n    timestamp: number;\n}\ninterface UserTrackData {\n    msg?: string;\n}\nexport class BaseTrack extends AsyncTaskQueue<TrackData> {\n    private seq: number = 0;\n    public track(data: UserTrackData) {\n        this.addTask({\n            id: uuid(),\n            seqId: this.seq++,\n            timestamp: Date.now(),\n            ...data,\n        });\n    }\n    public consumeTaskQueue(data: any) {\n        return axios.post(`https://xxx.com`, { data });\n    }\n}","无埋点#无埋点":"","概念#概念":"无埋点并不是真正的字面意思，其真实含义其实是，不需要研发去手动埋点。一般会有一个 sdk 封装好各种逻辑, 然后业务方直接引用即可。sdk中做的事情一般是监听所有页面事件, 上报所有点击事件以及对应的事件所在的元素，然后通过后台去分析这些数据。业界有GrowingIO, 神策, 诸葛IO, Heap, Mixpanel等等商业产品","实现-1#实现":"监听window元素\nwindow.addEventListener(\"click\", function(event){\n    let e = window.event || event;\n    let target = e.srcElement || e.target;\n}, false);\n    \n获取元素唯一标识 xPath\nfunction getXPath(element) {\n    // 如果元素有id属性，直接返回//*[@id=\"xPath\"]\n    if (element.id) {\n        return '//*[@id=\\\"' + element.id + '\\\"]';\n    }\n    // 向上查找到body，结束查找, 返回结果\n    if (element == document.body) {\n        return '/html/' + element.tagName.toLowerCase();\n    }\n    let currentIndex = 1, // 默认第一个元素的索引为1\n        siblings = element.parentNode.childNodes;\n    for (let sibling of siblings) {\n        if (sibling == element) {\n            // 确定了当前元素在兄弟节点中的索引后, 向上查找\n            return getXPath(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + (currentIndex) +\n                ']';\n        } else if (sibling.nodeType == 1 && sibling.tagName == element.tagName) {\n            // 继续寻找当前元素在兄弟节点中的索引\n            currentIndex++;\n        }\n    }\n};","获取元素的位置#获取元素的位置":"function getOffset(event) {\n    const rect = getBoundingClientRect(event.target);\n    if (rect.width == 0 || rect.height == 0) {\n        return;\n    }\n    let doc = document.documentElement || document.body.parentNode;\n    const scrollX = doc.scrollLeft;\n    const scrollY = doc.scrollTop;\n    const pageX = event.pageX || event.clientX + scrollX;\n    const pageY = event.pageY || event.clientY + scrollY;\n    const data = {\n        offsetX: ((pageX - rect.left - scrollX) / rect.width).toFixed(4),\n        offsetY: ((pageY - rect.top - scrollY) / rect.height).toFixed(4),\n    };\n    return data;\n}","上报#上报":"window.addEventListener(\"click\", function(event){\n    const e = window.event || event;\n    const target = e.srcElement || e.target;\n    const xPath = getXPath(target);\n    const offsetData = getOffset(event);\n    report({ xPath,  ...offsetData});\n}, false);\n// performance.ts\nimport { VueRouter } from 'vue-router/types/router';\nimport { BaseTrack } from './track';\nexport class Performance {\n    // TODO 注意上报的单位 现在是毫秒\n    public static readonly timing = window.performance && window.performance.timing;\n    public static init() {\n        if (!this.timing) {\n            console.warn('当前浏览器不支持performance API');\n            return;\n        }\n        window.addEventListener('load', () => {\n            new BaseTrack().track(this.getTimings());\n        });\n    }\n    public static record(router?: VueRouter) {\n        const setFPT = () => {\n            if (window.performance && window.performance.now) {\n                this.customFPT = window.performance.now();\n            }\n        };\n        return {\n            created: () => {\n                if (router) {\n                    router.onReady(() => {\n                        setFPT();\n                    });\n                } else {\n                    setFPT();\n                }\n            },\n        };\n    }\n    public static getTimings(): { [key in string]: number } {\n        if (!this.timing) {\n            console.warn('当前浏览器不支持performance API');\n            return {};\n        }\n        return {\n            redirect: this.getRedirectTime(),\n            dns: this.getDnsTime(),\n            tcp: this.getTcpTime(),\n            ttfb: this.getTimeOfFirstByte(),\n            req: this.getReqTime(),\n            ppdt: this.getParsePureDomTime(),\n            dclt: this.getDomContentLoadTime(),\n            fpt: this.getFirstPaintTime(),\n            load: this.getLoadTime(),\n        };\n    }\n    private static customFPT: number = 0;\n    private static getRedirectTime() {\n        // 重定向耗时\n        return Performance.timing.redirectEnd - Performance.timing.redirectStart;\n    }\n    private static getDnsTime() {\n        // dns查询耗时\n        return Performance.timing.domainLookupEnd - Performance.timing.domainLookupStart;\n    }\n    private static getTcpTime() {\n        // tcp连接耗时\n        return Performance.timing.connectEnd - Performance.timing.connectStart;\n    }\n    private static getTimeOfFirstByte() {\n        // 读取页面第一个字节耗时\n        return Performance.timing.responseStart - Performance.timing.navigationStart;\n    }\n    private static getReqTime() {\n        // request请求耗时\n        return Performance.timing.responseEnd - Performance.timing.responseStart;\n    }\n    private static getParsePureDomTime() {\n        // 解析纯DOM树耗时, 不包含js css等资源的加载和执行\n        return Performance.timing.domInteractive - Performance.timing.domLoading;\n    }\n    private static getDomContentLoadTime() {\n        // 页面资源加载耗时, 包含vue, js css等资源的加载和执行\n        return Performance.timing.domComplete - Performance.timing.domInteractive;\n    }\n    private static getFirstPaintTime() {\n        // first paint time, 首次渲染时间, 即白屏时间\n        return Math.round(\n            (window.performance.getEntriesByName &&\n                window.performance.getEntriesByName('first-paint') &&\n                window.performance.getEntriesByName('first-paint')[0] &&\n                window.performance.getEntriesByName('first-paint')[0].startTime) ||\n                this.customFPT,\n        );\n    }\n    private static getLoadTime() {\n        // 页面load总耗时\n        return Performance.timing.loadEventStart - Performance.timing.navigationStart;\n    }\n    private static toSeconds(time: number) {}\n}"}},"/posts/engin/webpack-plugin":{"title":"Webpack Plugin 开发","data":{"":"图：Amrit Pal Singh","webpack-插件概念#Webpack 插件概念":"在 Webpack 构建流程中的各个阶段、特定时机中劫持做一些代码处理、注入扩展逻辑来改变构建结果或做你想要的事情。","webpack-插件基本架构#Webpack 插件基本架构":"插件由一个构造函数实例化出来。构造函数定义 apply 方法，在安装插件时，apply 方法会被 Webpack compiler 调用一次。apply 方法可以接收一个 Webpack compiler 对象的引用\nclass HelloWorldPlugin {\n  apply(compiler) {\n    compiler.hooks.done.tap(\n      \"Hello World Plugin\",\n      (stats /* 在 hook 被触及时，会将 stats 作为参数传入。 */) => {\n        console.log(\"Hello World!\");\n      }\n    );\n  }\n}\nmodule.exports = HelloWorldPlugin;\n使用插件\n// webpack.config.js\nvar HelloWorldPlugin = require(\"hello-world\");\nmodule.exports = {\n  // ... 这里是其他配置 ...\n  plugins: [new HelloWorldPlugin({ options: true })],\n};","compiler-编译器#compiler 编译器":"这个对象包含了 webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 webpack 实例。","hook-生命周期钩子#hook 生命周期钩子":"compiler 暴露了一些钩子https://webpack.js.org/api/compiler-hooks/#environment","常用的钩子#常用的钩子":"beforeRun // compiler.run() 之前处理逻辑\nrun  //在开始读取记录之前\nbeforeCompile  //创建编译参数后执行插件\ncompile //在创建新编译之前立即调用\nmake  //在完成编译之前执行\nafterCompile //在完成编译之后执行\nentryOption //在 webpack 选项中的 entry 配置项处理过之后\n...","同步钩子的种类#同步钩子的种类":"SyncHook(同步钩子) - SyncHook\nBail Hooks(保释钩子) - SyncBailHook\nWaterfall Hooks(瀑布钩子) - SyncWaterfallHook","异步钩子的种类#异步钩子的种类":"Async Series Hook(异步串行钩子) - AsyncSeriesHook\nAsync waterfall(异步瀑布钩子) - AsyncWaterfallHook\nAsync Series Bail - AsyncSeriesBailHook\nAsync Parallel - AsyncParallelHook\nAsync Series Bail - AsyncSeriesBailHook","compilation-子编译器#compilation 子编译器":"compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 compilation 将被创建。compilation 对象也提供了很多事件回调供插件做扩展。通过 compilation 也能读取到 compiler 对象","compiler-和-compilation-区别#compiler 和 compilation 区别":"compiler代表了整个 webpack 从启动到关闭的生命周期，而 compilation 只代表一次单独的编译。\ncompilation 是 SyncHook 同步钩子","tap#tap":"对不同钩子进行 tap 处理即可，其中 tap 方法用于同步处理，异步方式则可以调用 tapAsync 方法或 tapPromise 方法。\n// tapAsync\nclass HelloAsyncPlugin {\n  apply(compiler) {\n    compiler.hooks.emit.tapAsync(\n      'HelloAsyncPlugin',\n      (compilation, callback) => {\n        // Do something async...\n        setTimeout(function () {\n          console.log('Done with async work...');\n          callback();\n        }, 1000);\n      }\n    );\n  }\n}\nmodule.exports = HelloAsyncPlugin;\n//tapPromise\nclass HelloAsyncPlugin {\n  apply(compiler) {\n    compiler.hooks.emit.tapPromise('HelloAsyncPlugin', (compilation) => {\n      // return a Promise that resolves when we are done...\n      return new Promise((resolve, reject) => {\n        setTimeout(function () {\n          console.log('Done with async work...');\n          resolve();\n        }, 1000);\n      });\n    });\n  }\n}\nmodule.exports = HelloAsyncPlugin;","我开发的输出一个编译文件列表markdown的插件#我开发的输出一个编译文件列表MarkDown的插件":"const pluginName = 'FileList';\nclass FileListPlugin {\n  apply(compiler) {\n    compiler.hooks.emit.tap(pluginName, (compilation) => {\n      var filelist = '生成的文件:\\n\\n';\n      for (var filename in compilation.assets) {\n        filelist += '- ' + filename + '\\n';\n      }\n      compilation.assets['filelist.md'] = {\n        source: function () {\n          return filelist;\n        },\n        size: function () {\n          return filelist.length;\n        },\n      };\n    });\n  }\n}\nmodule.exports = FileListPlugin;\n至此，我们就开发了一个简单的webpack插件"}},"/posts":{"title":"Index","data":{}},"/posts/engin/webpack":{"title":"webpack","data":{"":"图：Nguyen Nhut","功能#功能":"代码转换 (loaders)\n文件优化，压缩代码，压缩图片\n代码分割，提取公共代码\n模块合并\n自动刷新","常见配置#常见配置":"Entry\noutput\nmode\nModule\nChunk\nLoader\nPlugin","原理工作流程#原理/工作流程":"参数解析：从配置文件和 shell 语句中读取与合并参数，得出最终的参数\n找到入口文件：从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module,生成 map 对象\n调用 Loader 编译文件，每找到一个 Module,就会根据配置的 Loader 去找出对应的转换规则\n遍历 AST，收集依赖：对 Module 进行转换后，再解析出当前 Module 依赖的 Module\n生成 Chunk: 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk\n输出文件：最后 Webpack 会把所有 Chunk 转换成文件输出\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: \"vue-loader\",\n      },\n      { test: /\\.js$/, use: \"babel-loader\" },\n      {\n        test: /\\.css$/,\n        use: [\n          { loader: \"style-loader\" },\n          { loader: \"css-loader\" },\n          { loader: \"postcss-loader\" },\n        ],\n      },\n    ],\n  },\n};","loader-工作流#Loader 工作流":"webpack.config.js 里配置了一个 模块 的 Loader；\n遇到 相应模块 文件时，触发了 该模块的 loader;\nloader 接受了一个表示该 模块 文件内容的 source;\nloader 使用 webapck 提供的一系列 api 对 source 进行转换，得到一个 result;\n将 result 返回或者传递给下一个 Loader，直到处理完毕。","plugin#Plugin":"插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在编译过代码程中，会触发一系列 Tapable 钩子事件，插件所做的，就是找到相应的钩子，往上面挂上自己的任务，也就是注册事件，这样，当 webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行了。webpack 插件由以下组成：\n一个 JavaScript 命名函数。\n在插件函数的 prototype 上定义一个 apply 方法。\n指定一个绑定到 webpack 自身的事件钩子。\n处理 webpack 内部实例的特定数据。\n功能完成后调用 webpack 提供的回调\n插件示例：\n// 一个 JavaScript 命名函数。\nfunction MyExampleWebpackPlugin() {}\n// 在插件函数的 prototype 上定义一个 apply 方法。\nMyExampleWebpackPlugin.prototype.apply = function (compiler) {\n  // 指定一个挂载到 webpack 自身的事件钩子。\n  compiler.plugin(\n    \"webpacksEventHook\",\n    function (compilation /* 处理 webpack 内部实例的特定数据。*/, callback) {\n      console.log(\"This is an example plugin!!!\");\n      // 功能完成后调用 webpack 提供的回调。\n      callback();\n      复制代码;\n    }\n  );\n};","webpack-如何优化前端性能#webpack 如何优化前端性能":"第三方库按需加载、路由懒加载\n代码分割\n提取第三方库「vendor」依赖库分离「splitChunks」\noptimization: {\n  splitChunks: {\n    chunks: \"async\", // 必须三选一： \"initial\" | \"all\"(推荐) | \"async\" (默认就是async)\n    minSize: 30000, // 最小尺寸，30000\n    minChunks: 1, // 最小 chunk ，默认1\n    maxAsyncRequests: 5, // 最大异步请求数， 默认5\n    maxInitialRequests : 3, // 最大初始化请求书，默认3\n    automaticNameDelimiter: '~',// 打包分隔符\n    name: function(){}, // 打包后的名称，此选项可接收 function\n    cacheGroups:{ // 这里开始设置缓存的 chunks\n        priority: 0, // 缓存组优先级\n        vendor: { // key 为entry中定义的 入口名称\n            chunks: \"initial\", // 必须三选一： \"initial\" | \"all\" | \"async\"(默认就是async)\n            test: /react|lodash/, // 正则规则验证，如果符合就提取 chunk\n            name: \"vendor\", // 要缓存的 分隔出来的 chunk 名称\n            minSize: 30000,\n            minChunks: 1,\n            enforce: true,\n            maxAsyncRequests: 5, // 最大异步请求数， 默认1\n            maxInitialRequests : 3, // 最大初始化请求书，默认1\n            reuseExistingChunk: true // 可设置是否重用该chunk\n        }\n    }\n  }\n}"}},"/posts/js/ajax":{"title":"手写Ajax实现","data":{"":"图：Nguyen Nhut\ninterface IOptions {\n    url: string;\n    type?: string;\n    data: any;\n    timeout?: number;\n}\nfunction formatUrl(json) {\n    let dataArr = [];\n    json.t = Math.random();\n    for (let key in json) {\n        dataArr.push(`${key}=${encodeURIComponent(json[key])}`)\n    }\n    return dataArr.join('&');\n}\nexport function ajax(options: IOptions) {\n    return new Promise((resolve, reject) => {\n        if (!options.url) return;\n        options.type = options.type || 'GET';\n        options.data = options.data || {};\n        options.timeout = options.timeout || 10000;\n    \n        let dataToUrlstr = formatUrl(options.data);\n        let timer;\n    \n        // 1.创建\n        let xhr;\n        if ((window as any).XMLHttpRequest) {\n            xhr = new XMLHttpRequest();\n        } else {\n            xhr = new ActiveXObject('Microsoft.XMLHTTP');\n        }\n    \n        if (options.type.toUpperCase() === 'GET') {\n            // 2.连接\n            xhr.open('get', `${options.url}?${dataToUrlstr}`, true);\n            // 3.发送\n            xhr.send();\n        } else if (options.type.toUpperCase() === 'POST') {\n            // 2.连接\n            xhr.open('post', options.url, true);\n            xhr.setRequestHeader('ContentType', 'application/x-www-form-urlencoded');\n            // 3.发送\n            xhr.send(options.data);\n        }\n    \n        // 4.接收\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState === 4) {\n                clearTimeout(timer);\n                if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n                    resolve(xhr.responseText);\n                } else {\n                    reject(xhr.status);\n                }\n            }\n        }\n    \n        if (options.timeout) {\n            timer = setTimeout(() => {\n                xhr.abort();\n                reject('超时');\n            }, options.timeout)\n        }\n        // xhr.timeout = options.timeout;\n        // xhr.ontimeout = () => {\n        //     reject('超时');\n        // }\n    });\n}"}},"/posts/js/browser":{"title":"浏览器原理问题","data":{"":"图：Mako Tsereteli","地址栏输入一个-url-开始浏览器都做了什么工作#地址栏输入一个 url 开始，浏览器都做了什么工作？":"1.URL 解析浏览器先去判断这个 URL 是否是正确的 URL，若是正确合法的 url, 那么浏览器进程会根据输入的内容进行下一步操作。2.DNS 查询通过根域名服务器->顶级域名服务器->二级权限域名服务器逐级进行迭代查询，到达最终的服务器3、TCP 连接在确定目标服务器的 IP 地址后，则经历三次握手建立 TCP 连接4、发起 HTTP 请求当建立 tcp 连接之后，就可以发送 http 请求到目标服务器\n请求的内容包括：请求行、请求头、请求主体5、收到 http 响应请求服务器收到请求后进行逻辑操作，处理完成之后返回一个 http 响应消息，包括：状态行、响应头、响应正文\n服务器响应之后，由于现在 http 默认开启长链接 keep-alive,当页面关闭之后，tcp 链接则会经过四次挥手完成断开6、页面渲染当浏览器接收到服务器响应的资源后，首先会对资源进行解析：\n查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储 cookie,解压 gzip,缓存资源等等\n查看响应头的 Content-Type 的值，根据不同的资源类型采用不同的解析方式\n解析 HTML,构建 DOM 树\n解析 CSS, 生成 CSS 规则树\n合并 DOM 树和 CSS 规则，生成 render 树\n布局 render 树（Layout/reflow）,负责各元素尺寸、位置的计算\n绘制 render 树（paint）,绘制页面像素信息\n浏览器会将各层的信息发送给 GPU,GPU 会将各层合成（composite）,显示在屏幕上","js-会阻塞-html-的解析过程吗为什么#js 会阻塞 HTML 的解析过程吗？为什么？":"会，当 HTML 解析器碰到 script 标签的时候，它会停止 HTML 文档的解析从而转向 JavaScript 代码的加载，解析以及执行。因为 js 里会执行 document.wirte 等能改变 dom 的动作，html 的解析不得不等 js 执行完毕之后再进行解析","什么情况下会触发回流重排浏览器本身会有什么优化动作吗#什么情况下会触发回流/重排？浏览器本身会有什么优化动作吗？":"添加或删除元素\n元素的尺寸大小\n位置发生改变\n内容改变\n一开始渲染时\n浏览器窗口大小改变时\n时会发生重排，当颜色变化时会发生回流，还有当 js 获取诸如\noffsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight\n也会发生重排和回流，原因是浏览器对于重排和回流做的优化的副作用引起的\n浏览器为了减少重排发生的频率，把重排的动作放在一个队列里，直到过了一段时间或者操作达到了一个阈值进行一次性清空队列的操作，而我们获取 offsetTop 肯定是希望拿到最新的值，所以浏览器不得不清空重绘和回流的队列","如何尽量避免回流的出现#如何尽量避免回流的出现？":"如果想设定元素的样式，通过改变元素的 class 类名 (尽可能在 DOM 树的最里层)\n避免设置多项内联样式\n应用元素的动画，使用 position 属性的 fixed 值或 absolute 值(如前文示例所提)\n避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算\n对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响\n使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘，比如做动画时，尽量不要使用 top,left，width , 尺寸大小，位置等属性的改变来做，而使用 transform 属性来做\n避免使用 CSS 的 JavaScript 表达式\n需要获取 offset 等属性的时候, 最好用一个变量缓存起来, 不要每次都去获取","浏览器多进程架构的好处是什么#浏览器多进程架构的好处是什么?":"","容错性#容错性":"Chrome 会为每个 tab 单独分配一个属于它们的渲染进程（render process）。举个例子，假如你有三个 tab，你就会有三个独立的渲染进程。当其中一个 tab 的崩溃时，你可以随时关闭这个 tab 并且其他 tab 不受到影响。可是如果所有的 tab 都跑在同一个进程的话，它们就会有连带关系，一个挂全部挂。","安全性和沙盒性#安全性和沙盒性":"因为操作系统可以提供方法让你限制每个进程拥有的能力，所以浏览器可以让某些进程不具备某些特定的功能。例如，由于 tab 渲染进程可能会处理来自用户的随机输入，所以 Chrome 限制了它们对系统文件随机读写的能力。","每个进程可以拥有更多内存#每个进程可以拥有更多内存":"因为每个进程都会分配一块独立的内存空间, 所以理所当然的, 每个进程都会有更多的内存。","z-index-的生效规则#z-index 的生效规则":"","只有定位元素才会生效#只有定位元素才会生效":"z-index 这个属性并不是在所有的元素上都有效果。它仅仅只在定位元素（定义了 position 属性，且属性的值为非 static 值的元素）上有效果","层叠顺序#层叠顺序":"background/border —— 形成层叠上下文的元素的背景和边框，也是层叠上下文中的最低等级。z-index —— 层叠上下文内有着 负 z-index 值 的子元素。block 块级盒 —— 文档流中非行内非定位子元素。float 浮动盒 —— 非定位浮动元素。inline/inline-block 行内盒 —— 文档流中行内级别非定位子元素。z-index: 0 —— 定位元素，这些元素将形成了新的层叠上下文。z-index > 0 —— 定位元素。 层叠上下文中的最高等级。所有的元素层级是按照上面的排序进行的, 也就是说 z-index > 0 的层级最高, 最靠近屏幕前的我们, 也就是观察者.","同级比较#同级比较":"有的时候我们发现 z-index9999 居然比 z-index 100 更低? 为什么??这时候我们要知道 z-index 是同级比较, 比如下面的例子\ndiv1 z-index:10\n    div2 z-index:200\n    div3 z-index:999\ndiv4 z-index:20\n展示的层级高度是怎样的顺序?是 div4 > div3 > div2 > div1因为 div1 和 div4 是同级的, div4 比整体的 div1 高.完整的写一下高度, 效果类似于：\ndiv1: 10;\ndiv2: 10 - 200;\ndiv3: 10 - 999;\ndiv4: 20;"}},"/posts/js/callbindapply":{"title":"call、apply、bind的极简实现","data":{"":"图：Nguyen Nhut","call#Call":"Function.prototype.call = function (context, args) {\n  let symbolFn = Symbol(\"fn\");\n  symbolFn = this;\n  context[symbolFn](args);\n  delete context[symbolFn];\n};","apply#Apply":"Function.prototype.apply = function (context, args) {\n  let symbolFn = Symbol(\"fn\");\n  symbolFn = this;\n  context[symbolFn](...args);\n  delete context[symbolFn];\n};","bind#Bind":"Function.prototype.bind = function (context) {\n  let symbolFn = Symbol(\"fn\");\n  symbolFn = this;\n  return function () {\n    let result = context[symbolFn](...arguments);\n    delete context[symbolFn];\n    return result;\n  };\n};"}},"/posts/js/debounce":{"title":"极简代码实现节流Throttle和防抖Debounce","data":{"":"图：Nguyen Nhut","debounce防抖#debounce防抖":"function debounce(fn, delay) {\n  let timmer = null;\n  return function () {\n    timmer && clearInterval(timmer);\n    timmer = setTimeout(() => {\n      fn.call(this, arguments);\n    }, delay);\n  };\n}","throttle节流#throttle节流":"function throttle(fn, delay) {\n  let startTime = 0;\n  return function () {\n    let currentTime = new Date();\n    if (currentTime - startTime > delay) {\n      fn.call(this, arguments);\n      startTime = currentTime;\n    }\n  };\n}","codepen示例#CodePen示例":""}},"/posts/js/debugger":{"title":"debug和内存泄露","data":{"":"图：Nguyen Nhut","vscode-中-debug#vscode 中 debug":"","可以使用-vscode-的-debug-工具#可以使用 vscode 的 debug 工具":"","可以装-vscode-插件code-runner#可以装 vscode 插件，code runner":"右键run code","浏览器原生-debug#浏览器原生 debug":"node --inspect --inspect-brk xx/xx.js\n浏览器输入 chrome://inspectmemory 打快照查找内存泄露","内存泄露示例代码#内存泄露示例代码":"let index = 0;\nlet cache = {\n  method: function () {\n    debugger;\n    console.log(\"this is cache\", index);\n  },\n};\nfunction cacheInfo(info) {\n  index += 1;\n  const prevCache = cache;\n  const method = function () {\n    if (prevCache) {\n      prevCache.method();\n    }\n  };\n  cache = {\n    info: info,\n    method() {\n      method();\n      console.log(\"this\", index);\n    },\n  };\n}\nfor (var i = 0; i < 100000; i++) {\n  const info = new Array(1000000);\n  cacheInfo(info);\n  debugger;\n}"}},"/posts/js/design-pattern":{"title":"设计模式","data":{"":"图：Peter Tarka\n1.Single Responsibility Principle，单一职责原则，简称SRP\n实现类要职责单一。\n2.Open Close Principle，开闭原则，简称OCP\n对扩展开放，对修改关闭。\n3.Liskov Substitution Principle，里氏替换原则，简称LSP\n不要破坏继承体系。\n4.Interface Segregation Principle，接口隔离原则，简称ISP\n设计接口的时候要精简单一。\n5.Dependence Inversion Principle，依赖倒置原则，简称DIP","设计原则#设计原则":"","1开放-封闭原则ocp#1、开放-封闭原则（OCP）":"软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定","2单一职责原则-srp#2、单一职责原则 （SRP）":"不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。\n如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。","3最少知道原则-lkp-迪米特原则#3、最少知道原则 （LKP 迪米特原则）":"一个对象应该对其他对象有最少的了解, 类中只暴露不得不暴露的，其内部实现不暴露出去。","4接口隔离原则#4、接口隔离原则":"如果一个类实现一个接口，但这个接口中有它不需要的方法，那么就需要把这个接口拆分，把它需要的方法提取出来，组成一个新的接口让这个类去实现，一个接口对实现它的类都是有用的。接口足够小","5依赖倒置原则#5、依赖倒置原则":"举例人吃苹果，我想吃苹果，但是我还想吃橘子，如果按照程序思维的话。就是三个类型，人 Class，苹果 Class，橘子 Class，这种方式冗杂不好维护，不易理解，用水果来抽象化，苹果类继承并实现吃的动作。\n使用接口或抽象类\n上层不应依赖下层实现","6里氏替换原则#6、里氏替换原则":"是对开闭原则的补充，子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\n子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法\n子类中可以增加自己特有的方法","模式分类#模式分类":"模式分类\t名称\t创建型\t工厂模式\t\t单例模式\t\t建造者模式\t\t原型模式\t结构型\t适配器模式\t\t装饰器模式\t\t代理模式\t行为型\t策略模式\t\t迭代器模式\t\t观察者模式\t\t命令模式\t\t状态模式\t\t模板模式\t\t职责链模式\t\t享元模式","工厂模式#工厂模式":"工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象，用工厂方法代替 new 操作的一种模式。\n构造函数和创建者分离，对 new 操作进行封装，隐藏创建过程、暴露共同接口，\n符合开放封闭原则\nclass Creator {\n  create(name) {\n    return new Animal(name);\n  }\n}\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n}\nvar creator = new Creator();\nvar duck = creator.create(\"Duck\");\nconsole.log(duck.name); // Duck\nvar chicken = creator.create(\"Chicken\");\nconsole.log(chicken.name); // Chicken\n实际应用：Button Producer：生产不同类型的按钮 => 生产多个本质相同，利用传参区分不同属性的元素 => 工厂","单例模式#单例模式":"保证一个类仅有一个实例，并提供一个访问它的全局访问点\nclass PlayStation {\n  constructor() {\n    this.state = 'off';\n  }\n  play() {\n    if (this.state === 'on') {\n      console.log('别闹，已经在happy了');\n      return;\n    }\n    this.state = 'on';\n    console.log('开始happy');\n  }\n  shutdown() {\n    if (this.state === 'off') {\n      console.log('已经关闭');\n      return;\n    }\n    this.state = 'off';\n    console.log('已经关机，请放心');\n  }\n}\nPlayStation.instance = undefined;\nPlayStation.getInstance = (function() {\n  return function() {\n    if(!PlayStation.instance) {\n      PlayStation.instance = new PlayStation();\n    }\n    return PlayStation.instance;\n  }()\n}\n实际应用：全局应用 router store => 只需要一个实例 => 单例","建造者模式#建造者模式":"拆分简单模块、独立执行 => 注重过程与搭配\nclass Product {\n  constructor(name) {\n    this.name = name;\n  }\n  init() {\n    console.log(\"Product init\");\n  }\n}\nclass Skin {\n  constructor(name) {\n    this.name = name;\n  }\n  init() {\n    console.log(\"Skin init\");\n  }\n}\nclass Shop {\n  constructor() {\n    this.package = \"\";\n  }\n  create(name) {\n    this.package = new PackageBuilder(name);\n  }\n  getGamePackage() {\n    return this.package.getPackage();\n  }\n}\nclass PackageBuilder {\n  constructor(name) {\n    this.game = new Product(name);\n    this.skin = new Skin(name);\n  }\n  getPackage() {\n    return this.game.init() + this.skin.init();\n  }\n}\n实际应用：页头组件 Header: 包含了 title、button、breadcum => 生产多重不同类型的元素 => 建造者","原型模式#原型模式":"用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。在 JavaScript 中，实现原型模式是在 ECMAScript5 中，提出的 Object.create 方法，使用现有的对象来提供新创建的对象的proto。\nvar prototype = {\n  name: \"Jack\",\n  getName: function () {\n    return this.name;\n  },\n};\nvar obj = Object.create(prototype, {\n  job: {\n    value: \"IT\",\n  },\n});\nconsole.log(obj.getName()); // Jack\nconsole.log(obj.job); // IT\nconsole.log(obj.__proto__ === prototype); //true","适配器模式#适配器模式":"适配器的作用是解决两个软件实体间接口不兼容的问题，使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。适配独立模块，保证模块间的独立解耦且连接兼容\n//假如BaiduMap类的原型方法不叫show，而是叫display，这时候就可以使用适配器模式了，因为我们不能轻易的改变第三方的内容。在BaiduMap的基础上封装一层，对外暴露show方法。\nclass GooleMap {\n  show() {\n    console.log(\"渲染谷歌地图\");\n  }\n}\nclass BaiduMap {\n  display() {\n    console.log(\"渲染百度地图\");\n  }\n}\n// 定义适配器类, 对BaiduMap类进行封装\nclass BaiduMapAdapter {\n  show() {\n    var baiduMap = new BaiduMap();\n    return baiduMap.display();\n  }\n}\nfunction render(map) {\n  if (map.show instanceof Function) {\n    map.show();\n  }\n}\nrender(new GooleMap()); // 渲染谷歌地图\nrender(new BaiduMapAdapter()); // 渲染百度地图\n场景：中间转换参数、保持模块间独立的时候实际应用：两个模块：筛选器和表格，需要做一个联动。但筛选器的数据不能直接传入表格，需要做数据结构转换 ，模块之间独立，需要做数据结构转换","装饰器模式#装饰器模式":"以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。\n是一种“即用即付”的方式，能够在不改变对 象自身的基础上，在程序运行期间给对象动态地 添加职责是为对象动态加入行为，经过多重包装，可以形成一条装饰链\n// 动态将责任附加到对象上\n// 设备创建->设备创建时升级\nclass Device {\n  create() {\n    console.log(\"PlayStation4\");\n  }\n}\nclass Phone {\n  create() {\n    console.log(\"iphone18\");\n  }\n}\nclass Decorator {\n  constructor(device) {\n    this.device = device;\n  }\n  create() {\n    this.device.create();\n    this.update(device);\n  }\n  update(device) {\n    console.log(device + \"pro\");\n  }\n}\nconst device = new Device();\ndevice.create();\nconst newDevice = new Decorator(device);\nnewDevice.create();\n场景：附着于多个组件上，批量动态赋予功能的时候实际应用：目前有按钮、title、icon 三个组件。希望开发一个模块，让三个组件同时具备相同功能","代理模式#代理模式":"代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问\nclass MyImage {\n  constructor() {\n    this.img = new Image();\n    document.body.appendChild(this.img);\n  }\n  setSrc(src) {\n    this.img.src = src;\n  }\n}\nclass ProxyImage {\n  constructor() {\n    this.proxyImage = new Image();\n  }\n  setSrc(src) {\n    let myImageObj = new MyImage();\n    myImageObj.img.src = \"file://xxx.png\"; //为本地图片url\n    this.proxyImage.src = src;\n    this.proxyImage.onload = function () {\n      myImageObj.img.src = src;\n    };\n  }\n}\nvar proxyImage = new ProxyImage();\nproxyImage.setSrc(\"http://xxx.png\"); //服务器资源url\n场景：将代理对象与调用对象分离，不直接调用目标对象实际应用：ul 中多个 li，每个 li 上的点击事件 => 利用冒泡做委托，事件绑定在 ul 上","策略模式#策略模式":"定义有一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。将算法的使用和算法的实现分离开来。一个基于策略模式的程序至少由两部分组成：第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用\n// 绩效为S 的人年终奖有4 倍工资，绩效为A 的人年终奖有3 倍工资，而绩效为B 的人年终奖是2 倍工资。\nvar strategies = {\n  S: function (salary) {\n    return salary * 4;\n  },\n  A: function (salary) {\n    return salary * 3;\n  },\n  B: function (salary) {\n    return salary * 2;\n  },\n};\nvar cacularBonus = function (level, salary) {\n  return strategies[level](salary);\n};\nvar level2 = cacularBonus(\"A\", 200);\n//我们将计算年终奖的算法，放在一个对象内部，封装起来，在调用的时候可以通过不同的等级获得不同的计算方式。而我们有新的等级或者新的计算方式的时候，我们对该对象进行更改就可以了。避免了在一个函数内部进行计算，提高了可维护性。","迭代器模式#迭代器模式":"迭代器模式是指提供一种方法顺序访问一个有序聚合对象中的各个元素，而又不需要暴露该对象的内部表示。在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素\nclass Creater {\n  constructor(list) {\n    this.list = list;\n  }\n  // 创建一个迭代器，也叫遍历器\n  createIterator() {\n    return new Iterator(this);\n  }\n}\nclass Iterator {\n  constructor(creater) {\n    this.list = creater.list;\n    this.index = 0;\n  }\n  // 判断是否遍历完数据\n  isDone() {\n    if (this.index >= this.list.length) {\n      return true;\n    }\n    return false;\n  }\n  next() {\n    return this.list[this.index++];\n  }\n}\nvar arr = [1, 2, 3, 4];\nvar creater = new Creater(arr);\nvar iterator = creater.createIterator();\nconsole.log(iterator.list); // [1, 2, 3, 4]\nwhile (!iterator.isDone()) {\n  console.log(iterator.next());\n  // 1\n  // 2\n  // 3\n  // 4\n}\njavascript 中有序数据集合包括\nArray\nMap\nSet\nString\ntypeArray\narguments\nNodeList\nvar arr = [1, 2, 3, 4];\nvar iterator = arr[Symbol.iterator]();\nconsole.log(iterator.next()); // {value: 1, done: false}\nconsole.log(iterator.next()); // {value: 2, done: false}\nconsole.log(iterator.next()); // {value: 3, done: false}\nconsole.log(iterator.next()); // {value: 4, done: false}\nconsole.log(iterator.next()); // {value: undefined, done: true}","观察者模式-订阅发布模式#观察者模式 （订阅发布模式）":"也称作观察者模式，定义了对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。与传统的发布-订阅模式实现方式（将订阅者自身当成引用传入发布者）不同，在 JS 中通常使用注册回调函数的形式来订阅\n// 当一个属性发生状态改变时，观察者会连续引发所有的相关状态改变\n// 通过智能家居一键开始游戏\nclass MediaCenter {\n  constructor() {\n    this.state = \"\";\n    this.observers = [];\n  }\n  attach(observer) {\n    this.observers.push(observer);\n  }\n  getState() {\n    return this.state;\n  }\n  setState(state) {\n    this.state = state;\n    this.notifyAllobservers();\n  }\n  notifyAllobservers() {\n    this.observers.forEach((ob) => {\n      ob.update();\n    });\n  }\n}\nclass observer {\n  constructor(name, center) {\n    this.name = name;\n    this.center = center;\n    this.center.attach(this);\n  }\n  update() {\n    console.log(`${this.name} update, state: ${this.center.getState()}`);\n  }\n}\nconst center = new MediaCenter();\nconst ps = new Observer(\"ps\", center);\nconst tv = new Observer(\"tv\", center);\ncenter.setState(\"on\");\n发布订阅模式可以使代码解耦，满足开放封闭原则\n当过多的使用发布订阅模式，如果订阅消息始终都没有触发，则订阅者一直保存在内存中。","命令模式#命令模式":"用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系命令中带有 execute 执行、undo 撤销、redo 重做等相关命令方法，建议显示地指示这些方法名\n//一个自增命令，提供执行、撤销、重做功能\n// 自增\nfunction IncrementCommand() {\n  // 当前值\n  this.val = 0;\n  // 命令栈\n  this.stack = [];\n  // 栈指针位置\n  this.stackPosition = -1;\n}\nIncrementCommand.prototype = {\n  constructor: IncrementCommand,\n  // 执行\n  execute: function () {\n    this._clearRedo();\n    // 定义执行的处理\n    var command = function () {\n      this.val += 2;\n    }.bind(this);\n    // 执行并缓存起来\n    command();\n    this.stack.push(command);\n    this.stackPosition++;\n    this.getValue();\n  },\n  canUndo: function () {\n    return this.stackPosition >= 0;\n  },\n  canRedo: function () {\n    return this.stackPosition < this.stack.length - 1;\n  },\n  // 撤销\n  undo: function () {\n    if (!this.canUndo()) {\n      return;\n    }\n    this.stackPosition--;\n    // 命令的撤销，与执行的处理相反\n    var command = function () {\n      this.val -= 2;\n    }.bind(this);\n    // 撤销后不需要缓存\n    command();\n    this.getValue();\n  },\n  // 重做\n  redo: function () {\n    if (!this.canRedo()) {\n      return;\n    }\n    // 执行栈顶的命令\n    this.stack[++this.stackPosition]();\n    this.getValue();\n  },\n  // 在执行时，已经撤销的部分不能再重做\n  _clearRedo: function () {\n    this.stack = this.stack.slice(0, this.stackPosition + 1);\n  },\n  // 获取当前值\n  getValue: function () {\n    console.log(this.val);\n  },\n};\nvar incrementCommand = new IncrementCommand();\n// 模拟事件触发，执行命令\nvar eventTrigger = {\n  // 某个事件的处理中，直接调用命令的处理方法\n  increment: function () {\n    incrementCommand.execute();\n  },\n  incrementUndo: function () {\n    incrementCommand.undo();\n  },\n  incrementRedo: function () {\n    incrementCommand.redo();\n  },\n};\neventTrigger[\"increment\"](); // 2\neventTrigger[\"increment\"](); // 4\neventTrigger[\"incrementUndo\"](); // 2\neventTrigger[\"increment\"](); // 4\neventTrigger[\"incrementUndo\"](); // 2\neventTrigger[\"incrementUndo\"](); // 0\neventTrigger[\"incrementUndo\"](); // 无输出\neventTrigger[\"incrementRedo\"](); // 2\neventTrigger[\"incrementRedo\"](); // 4\neventTrigger[\"incrementRedo\"](); // 无输出\neventTrigger[\"increment\"](); // 6","状态模式#状态模式":"状态模式允许一个对象在其内部状态改变的时候改变行为，这个对象看上去像是改变了它的类一样，状态模式把所研究对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。区分事物内部的状态，把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>state-demo</title>\n  </head>\n  <body>\n    <button id=\"btn\">开关</button>\n    <script>\n      // 定义一个关闭状态的类\n      class OffLightState {\n        constructor(light) {\n          this.light = light;\n        }\n        // 每个类都需要这个方法，在不同状态下按都需要触发这个方法\n        pressBtn() {\n          this.light.setState(this.light.weekLightState);\n          console.log(\"开启弱光\");\n        }\n      }\n      // 定义一个弱光状态的类\n      class WeekLightState {\n        constructor(light) {\n          this.light = light;\n        }\n        pressBtn() {\n          this.light.setState(this.light.strongLightState);\n          console.log(\"开启强光\");\n        }\n      }\n      // 定义一个强光状态的类\n      class StrongLightState {\n        constructor(light) {\n          this.light = light;\n        }\n        pressBtn() {\n          this.light.setState(this.light.offLightState);\n          console.log(\"关闭电灯\");\n        }\n      }\n      class Light {\n        constructor() {\n          this.offLightState = new OffLightState(this);\n          this.weekLightState = new WeekLightState(this);\n          this.strongLightState = new StrongLightState(this);\n          this.currentState = null;\n        }\n        setState(newState) {\n          this.currentState = newState;\n        }\n        checkState(state) {\n          this.currentState = this[state];\n        }\n      }\n      let light = new Light();\n      light.checkState(\"strongLightState\");\n      var btn = document.getElementById(\"btn\");\n      btn.onclick = function () {\n        light.currentState.pressBtn();\n      };\n    </script>\n  </body>\n</html>","模板模式#模板模式":"模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。在抽象父类中封装子类的算法框架，它的 init 方法可作为一个算法的模板，指导子类以何种顺序去执行哪些方法。由父类分离出公共部分，要求子类重写某些父类的（易变化的）抽象方法模板方法模式一般的实现方式为继承以运动作为例子，运动有比较通用的一些处理，这部分可以抽离开来，在父类中实现。具体某项运动的特殊性则有自类来重写实现。最终子类直接调用父类的模板函数来执行\n// 体育运动\nfunction Sport() {}\nSport.prototype = {\n  constructor: Sport,\n  // 模板，按顺序执行\n  init: function () {\n    this.stretch();\n    this.jog();\n    this.deepBreath();\n    this.start();\n    var free = this.end();\n    // 运动后还有空的话，就拉伸一下\n    if (free !== false) {\n      this.stretch();\n    }\n  },\n  // 拉伸\n  stretch: function () {\n    console.log(\"拉伸\");\n  },\n  // 慢跑\n  jog: function () {\n    console.log(\"慢跑\");\n  },\n  // 深呼吸\n  deepBreath: function () {\n    console.log(\"深呼吸\");\n  },\n  // 开始运动\n  start: function () {\n    throw new Error(\"子类必须重写此方法\");\n  },\n  // 结束运动\n  end: function () {\n    console.log(\"运动结束\");\n  },\n};\n// 篮球\nfunction Basketball() {}\nBasketball.prototype = new Sport();\n// 重写相关的方法\nBasketball.prototype.start = function () {\n  console.log(\"先投上几个三分\");\n};\nBasketball.prototype.end = function () {\n  console.log(\"运动结束了，有事先走一步\");\n  return false;\n};\n// 马拉松\nfunction Marathon() {}\nMarathon.prototype = new Sport();\nvar basketball = new Basketball();\nvar marathon = new Marathon();\n// 子类调用，最终会按照父类定义的顺序执行\nbasketball.init();\nmarathon.init();","职责链#职责链":"使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链 传递该请求，直到有一个对象处理它为止请求发送者只需要知道链中的第一个节点，弱化发送者和一组接收者之间的强联系，可以便捷地在职责链中增加或删除一个节点，同样地，指定谁是第一个节点也很便捷\nclass Action {\n  constructor(name) {\n    this.name = name;\n    this.nextAction = null;\n  }\n  setNextAction(action) {\n    this.nextAction = action;\n  }\n  handle() {\n    console.log(`${this.name}请审批，是否可以打游戏`);\n    if (this.nextAction !== null) {\n      this.nextAction.handle();\n    }\n  }\n}\nconst dad = new Action(\"爸\");\nconst mom = new Action(\"妈\");\nconst wife = new Action(\"夫人\");\ndad.setNextAction(mom);\nmom.setNextAction(wife);\ndad.handle();","享元模式#享元模式":"是一种用于性能优化的模式，它的目标是尽量减少共享对象的数量运用共享技术来有效支持大量细粒度的对象。调将对象的属性划分为内部状态（属性）与外部状态（属性）。内部状态用于对象的共享，通常不变；而外部状态则剥离开来，由具体的场景决定。在程序中使用了大量的相似对象时，可以利用享元模式来优化，减少对象的数量\n// 举个栗子，要对某个班进行身体素质测量，仅测量身高体重来评判\n// 健康测量\nfunction Fitness(name, sex, age, height, weight) {\n  this.name = name;\n  this.sex = sex;\n  this.age = age;\n  this.height = height;\n  this.weight = weight;\n}\n// 开始评判\nFitness.prototype.judge = function () {\n  var ret = this.name + \": \";\n  if (this.sex === \"male\") {\n    ret += this.judgeMale();\n  } else {\n    ret += this.judgeFemale();\n  }\n  console.log(ret);\n};\n// 男性评判规则\nFitness.prototype.judgeMale = function () {\n  var ratio = this.height / this.weight;\n  return this.age > 20 ? ratio > 3.5 : ratio > 2.8;\n};\n// 女性评判规则\nFitness.prototype.judgeFemale = function () {\n  var ratio = this.height / this.weight;\n  return this.age > 20 ? ratio > 4 : ratio > 3;\n};\nvar a = new Fitness(\"A\", \"male\", 18, 160, 80);\nvar b = new Fitness(\"B\", \"male\", 21, 180, 70);\nvar c = new Fitness(\"C\", \"female\", 28, 160, 80);\nvar d = new Fitness(\"D\", \"male\", 18, 170, 60);\nvar e = new Fitness(\"E\", \"female\", 18, 160, 40);\n// 开始评判\na.judge(); // A: false\nb.judge(); // B: false\nc.judge(); // C: false\nd.judge(); // D: true\ne.judge(); // E: true"}},"/posts/js/es6class":{"title":"ES6之Class","data":{"":"图：Mako Tsereteli","class-助力-js-更加面向对象了#Class 助力 js 更加面向对象了":"","传统对象---function构造函数#传统对象 - function构造函数":"function Course(teacher, course) {\n  this.teacher = teacher;\n  this.course = course;\n}\nCourse.prototype.getCourse = function () {\n  return `teacher: ${this.teacher}, course: ${this.course}`;\n};\nconst course = new Course(\"YY\", \"ES6\");","es6#ES6":"class Course {\n  constructor(teacher, course) {\n    this.teacher = teacher;\n    this.course = course;\n  }\n  getCourse() {\n    return `teacher: ${this.teacher}, course: ${this.course}`;\n  }\n}\nconst course = new Course(\"YY\", \"ES6\");","faq#FAQ":"","本质#本质？":"语法糖","class-是什么类型#class 是什么类型？":"console.log(typeof Course); //function","class-是否有-prototype#class 是否有 prototype?":"console.log(Course.prototype); //{constructor: ƒ, getCourse: ƒ}","class-可以使用对象方法属性么#class 可以使用对象方法&属性么":"console.log(course.hasOwnProperty(\"teacher\")); //true","属性定义#属性定义?":"两种定义属性的方式： 构造器 & 顶层定义\nclass Course {\n  constructor(teacher, course) {\n    this._teacher = teacher;\n    this.course = course;\n  }\n  getCourse() {\n    return `teacher: ${this._teacher}, course: ${this.course}`;\n  }\n  get teacher() {\n    return this._teacher;\n  }\n  set teacher(val) {\n    this._teacher = val;\n  }\n}\nconst course = new Course('YY', 'ES6');\n// 意义何在？\n// 1. 建立只读变量， *js如何建立只读变量\nclass Course1 {\n  constructor(teacher, course) {\n    this._teacher = teacher;\n    this.course = course;\n  }\n  getCourse() {\n    return `teacher: ${this._teacher}, course: ${this.course}`;\n  }\n  get teacher() {\n    return this._teacher;\n  }\n}\nconst course1 = new Course1('YY', 'ES6');\n//修改只读变量会报错么？\ncourse1.teacher = '222'; //  - 无法改变，但不会报错\n// 2. *js中如何实现一个私有属性 - 闭包\nclass Course2 {\n  constructor(teacher, course) {\n    this._teacher = teacher;\n    // 在constructor作用域中定义局部变量，内部通过闭包的形式对外暴露该变量\n    let _course = 'es6';\n    this.getCourse = () => {\n      return _course;\n    }\n  }\n}\nclass Course3 {\n  #course = 'es6';\n  constructor(teacher, course) {\n    this._teacher = teacher;\n    }\n  }\n  get course() {\n    return `${#course}~`;\n  }\n  set course(val) {\n    if (val) {\n      this.#course = val;\n    }\n  }\n}\n// 3. 封装核心 - 适配器模式\n// 底层封装好通用core服务\nclass Utils {\n  constructor(core) {\n    this._main = core;\n    this._name = 'myName';\n  }\n  get name() {\n    ...this._main.name,\n    name: ${this._name}\n  }\n  set name(val) {\n    this._name = val;\n  }\n}","静态方法#静态方法":"直接挂载，无需实例化即可获取\n// ES5\nfunction Course(teacher, course) {\n  this._teacher = teacher;\n  this.course = course;\n}\nCourse.call = function () {\n  console.log(\"calling\");\n};\n// ES6\nclass Course {\n  constructor(teacher, course) {\n    this._teacher = teacher;\n  }\n  static call() {\n    console.log(\"calling\");\n  }\n}","继承#继承":"","es5-继承#ES5 继承":"// 父构造函数\nfunction Course(teacher, course) {\n  this._teacher = teacher;\n  this.course = course;\n}\nCourse.call = function () {\n  console.log(\"calling\");\n};\nCourse.prototype.send = function () {\n  console.log(\"sending\");\n};\n// 子构造函数\nfunction Child() {\n  // 初始化父类\n  Course.call(this, \"xx\", \"ES6\");\n  this.start = function () {\n    console.log(\"starting\");\n  };\n}\nChild.prototype = Course.prototype;","es6-继承#ES6 继承":"// 父类\nclass Course {\n  constructor(teacher, course) {\n    this._teacher = teacher;\n    this.course = course;\n  }\n  send() {\n    console.log(\"sending\");\n  }\n  static call() {\n    console.log(\"calling\");\n  }\n}\n// 子类\nclass Child extends Course {\n  constructor() {\n    super(\"xx\", \"ES6\");\n  }\n  start() {\n    console.log(\"starting\");\n  }\n}"}},"/posts/js/eventloop":{"title":"Javascript 事件循环 EventLoop","data":{"":"图：Nguyen Nhut","浏览器中-js-事件循环#浏览器中 js 事件循环":"一图胜千言\nJS 引擎常驻于内存中，等待宿主将 JS 代码或函数传递给它。\n也就是等待宿主环境分配宏观任务，反复等待 - 执行即为事件循环。\nEvent Loop 中，每一次循环称为 tick，每一次 tick 的任务如下：\n执行栈选择最先进入队列的宏任务（一般都是 script），执行其同步代码直至结束；\n检查是否存在微任务，有则会执行至微任务队列为空；\n如果宿主为浏览器，可能会渲染页面；\n开始下一轮 tick，执行宏任务中的异步代码（setTimeout 等回调）。","宏任务微任务循环#宏任务、微任务循环":"ES6 规范中，microtask 称为 jobs，macrotask 称为 task\n宏任务是由宿主发起的，而微任务由 JavaScript 自身发起。\n\t宏任务（macrotask）\t微任务（microtask）\t谁发起的\t宿主（Node、浏览器）\tJS 引擎\t具体事件\t1. script (可以理解为外层同步代码) 2. setTimeout/setInterval 3. UI rendering/UI 事件 4. postMessage，MessageChannel 5. setImmediate，I/O（Node.js）\t1. Promise 2. MutaionObserver 3. Object.observe（已废弃；Proxy 对象替代） 4. process.nextTick（Node.js）\t谁先运行\t后运行\t先运行\t会触发新一轮 Tick 吗\t会\t不会","分析代码#分析代码":"console.log(\"1\");\nsetTimeout(function () {\n  console.log(\"2\");\n  process.nextTick(function () {\n    console.log(\"3\");\n  });\n  new Promise(function (resolve) {\n    console.log(\"4\");\n    resolve();\n  }).then(function () {\n    console.log(\"5\");\n  });\n});\nprocess.nextTick(function () {\n  console.log(\"6\");\n});\nnew Promise(function (resolve) {\n  console.log(\"7\");\n  resolve();\n}).then(function () {\n  console.log(\"8\");\n});\nsetTimeout(function () {\n  console.log(\"9\");\n  process.nextTick(function () {\n    console.log(\"10\");\n  });\n  new Promise(function (resolve) {\n    console.log(\"11\");\n    resolve();\n  }).then(function () {\n    console.log(\"12\");\n  });\n});\n整段代码，共进行了三次事件循环，完整的输出为 1，7，6，8，2，4，3，5，9，11，10，12。 (请注意，node 环境下的事件监听依赖 libuv 与前端环境不完全相同，输出顺序可能会有误差)"}},"/posts/js/hoist":{"title":"JS中的变量提升","data":{"":"图：Amrit Pal Singh\n正如 Stoyan Stefanov 在“JavaScript 模式”一书中所解释的，提升是 JavaScript 解释器实现的结果。\nJS 代码解释分两遍执行。在第一遍期间，解释器处理变量和函数声明。\n第二遍是实际的代码执行步骤。解释器处理函数表达式和未声明的变量。\n因此，我们可以使用“提升”的概念来描述这种行为。","变量提升#变量提升":"JavaScript 是单线程语言，所以执行肯定是按顺序执行。但是并不是逐行的分析和执行，而是一段一段地分析执行，会先进行编译阶段然后才是执行阶段。在编译阶段阶段，代码真正执行前的几毫秒，会检测到所有的变量和函数声明，所有这些函数和变量声明都被添加到名为 Lexical Environment 的 JavaScript 数据结构内的内存中。所以这些变量和函数能在它们真正被声明之前使用。\na = 2;\nvar a;\nconsole.log(a); //2\n会将当前作用域的所有变量的声明，提升到程序的顶部，因此，上面的代码等价于以下代码\nvar a;\na = 2;\nconsole.log(a);","变量声明#变量声明":"js 的变量声明应该大体上可以分三种：var 声明、let 与 const 声明和函数声明。 函数声明与其他声明一起出现的时候，就可能会引起一些冲突。我们接着往下看：\nfn();\nfunction fn() {\n  console.log(\"fn\");\n}\nvar fn = 2;\n你觉得会输出什么？这么写会报错吗？ 其实输出的结果是 fn。这就解释了我们刚刚的问题，当函数声明与其他声明一起出现的时候，是以谁为准呢？答案就是，函数声明高于一切，毕竟函数是 js 的贵族阶级。那么多个函数声明怎么办呢？\nfn();\nfunction fn() {\n  console.log(\"1\");\n}\nfunction fn() {\n  console.log(\"2\");\n}\n以上代码输出结果为 2。这是因为有多个函数声明的时候，是由最后的函数声明来替代前面的。\nfn();\nvar fn = function () {\n  console.log(\"fn\");\n};\n它其实也分为两部分：\nvar fn;\nfn = function() ;\n参考例 2，我们可以知道，这个的结果应该是报错了(因为 fn 声明但未赋值，因此 fn 是 undefined)。\njs 会将变量的声明提升到 js 顶部执行，对于 var a = 2 这种语句，会拆分开，将 var a 这步进行提升。\n变量提升的本质其实是 js 引擎在编译的时候，就将所有的变量声明了，因此在执行的时候，所有的变量都已经完成声明。\n当有多个同名变量的时候，函数声明会覆盖其他的声明。如果有多个函数声明，则由最后一个函数声明覆盖之前的所有声明。","为什么要设计成这样#为什么要设计成这样？":"解决变量声明优先级,让函数优先\n提前分配好内存（个人猜测）\n提前构造出函数，不用等到执行时再构造\n真实原因：JS 创造者 Brendan Eich 曾经说过（在 Twitter 上）：\n“因此，var 提升是函数提升、没有块范围和 JS 作为 1995 年的紧急工作的 [an] 意外结果。”\nvar hoisting was thus unintended consequence of function hoisting, no block scope, JS as a 1995 rush job. ES6 'let' may help.","暂时性死区#暂时性死区":"在代码块内，使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n// 源代码\n{\n    a = 2;\n    let a ;\n    a = 3\n}\n// 加入TDZ后的代码\n{\n    // 变量提升，创建\n    let a ;\n    // TDZ 区开始---\n    a = 2；\n    a ;//此时等同于a 初始化为undefined\n    // TDZ 区结束---\n    // 此时可以访问a\n    a = 3\n}"}},"/posts/js/oop":{"title":"OOP 面向对象编程","data":{"":"图：Nguyen Nhut","对象是什么为什么要面向对象#对象是什么？为什么要面向对象？":"OOP(Object Oriented Programming)逻辑迁移灵活，代码可复用性高，高度模块化","对象的理解#对象的理解":"对象是对于单个物体的简单抽象\n对象是一个容器，封装了属性&方法\n属性： 对象的状态\n方法： 对象的行为\n// 简单对象\nconst Course = {\n  teacher: \"john\",\n  leader: \"tom\",\n  startCourse: function (name) {\n    return \"oop\";\n  },\n};\n// 函数对象\nfunction Course() {\n  this.teacher = \"john\";\n  this.leader = \"tom\";\n  this.startCourse = function (name) {\n    return \"oop\";\n  };\n}","构造函数#构造函数":"生成对象\n需要一个模板，表征了一类物体的共同特征，从而生成对象\n类即对象模板js 本质不是基于类，而是基于构造函数+原型链\n(constructor + prototype)\nfunction Course() {\n  this.teacher = \"john\";\n  this.leader = \"tom\";\n}\nconst course = new Course();\nCourse 本质就是构造函数\n函数体内是用的 this, 代表所要生成的实例\n生成对象通过 new 来实例化\n可以做初始化参数\n构造函数不初始化无法使用，如果需要使用，做如下兼容\nfunction Course() {\n  const _isClass = this instanceof Course;\n  if (!isClass) {\n    return new Course();\n  }\n  this.teacher = \"john\";\n  this.leader = \"tom\";\n}","new-是什么#new 是什么？":"new 的原理？new 做了什么？手写 new?\nfunction Course() {}\nconst course = new Course();\ncourse.__proto__ === Course.prototype;\nCourse.prototype.__proto__ === Object.prototype;\ncourse.constructor === Course;\n创建了一个空对象，作为返回的对象实例\n将生成空对象的原型对象指向了构造函数的 prototype 属性\n将当前实例对象赋给了内部 this\n执行构造函数初始化代码","constructor-是什么#constructor 是什么":"function Course(teacher, leader) {\n  this.teacher = teacher;\n  this.leader = leader;\n}\nconst course = new Course(\"john\", \"tom\");\n每个对象创建时会自动拥有一个构造函数属性 constructor\nconstructor 继承自原型对象，指向构造函数的引用\n使用构造函数的问题\n构造函数中的方法，会存在于每个生成的实例中","原型对象#原型对象":"function Course() {}\nconst course1 = new Course();\nconst course2 = new Course();\n构造函数：用来初始化对象的函数 - Course\n自动给构造函数赋予一个属性 prototype,该属性实际等于实例对象的原型对象\n实例对象：course1 就是实例对象，根据原型创建出来的实例\n每个对象都有个proto\n每个实例都有 constructor 属性\nconstructor 由继承而来，并指向当前构造函数\n原型对象： Course.prototype\nfunction Course() {\n  Course.prototype.teacher = \"john\";\n  const course1 = new Course();\n  const course2 = new Course();\n}","继承#继承":"","原型链继承#原型链继承":"在原型对象的所有属性和方法，都能被实例所共享\n子构造函数的原型是父构造函数的实例\n子构造函数的原型的构造函数是子构造函数\nfunction Game() {\n  this.name = \"lol\";\n}\nGame.prototype.getName = function () {\n  return this.name;\n};\nfunction LOL() {}\nLOL.prototype = new Game();\nLOL.prototype.constructor = LOL;\nconst game = new LOL();","构造函数继承#构造函数继承":"在子类构造函数内部调用父类构造函数\nfunction Game() {\n  this.name = \"lol\";\n  this.skin = [\"s\"];\n}\nGame.prototype.getName = function () {\n  return this.name;\n};\nfunction LOL(arg) {\n  Game.call(this, arg);\n}\nconst game3 = new LOL();\n// 解决共享属性问题，传参问题\n原型链上共享的方法无法被读取继承如何解决？","组合继承#组合继承":"function Game() {\n  this.name = \"lol\";\n  this.skin = [\"s\"];\n}\nGame.prototype.getName = function () {\n  return this.name;\n};\nfunction LOL(arg) {\n  Game.call(this, arg);\n}\nLOL.prototype = new Game();\nLOL.prototype.constructor = LOL;\nconst game3 = new LOL();\n无论何种场景都会调用两次父类构造函数，怎么办？1、初始化子类2、子类构造函数内部call父类的时候","寄生组合继承#寄生组合继承":"function Game() {\n  this.name = \"lol\";\n  this.skin = [\"s\"];\n}\nGame.prototype.getName = function () {\n  return this.name;\n};\nfunction LOL(arg) {\n  Game.call(this, arg);\n} \nLOL.prototype = Object.create(Game.prototype);\nLOL.prototype.constructor = LOL;\nconst game3 = new LOL();"}},"/posts/js/philosophy":{"title":"Javascript中的哲学","data":{"":"图：Ashui","基本哲学--️#基本哲学 —— ☯️":"道生一, 一生二, 二生三, 三生万物……；         道可道，非常道……\njavascript 中万物归一思想和中国古代几千年的道家思想有不谋而合之处，赞叹古人的这种哲学归纳思想在多年的编程生涯中也隐约归纳了下，多多指教\n无极\t太极\t两仪\t四象\tundefined\tnull\tbolean\tstring、number、function、(object | symbol)\t\n无极生太极，太极生两仪，两仪生四象，四象生八卦，八卦生万物\n计算机中的二进制，1和0是不是符合阴阳之说……1和0 <=> true和false <=>阴与阳无极生太极，是不是联想到了对象构造函数、原型链……“卦” 是不是联想到了设计模式……function 和 object 和 卦 等是不是构建出了我们的软件世界…………","设计哲学--设计模式#设计哲学 —— 设计模式":"语法是基本拳脚设计原则是心法而设计模式是功法相当于是一种武功，蛤蟆功，狮子吼，螳螂拳，金钟罩铁布衫，降龙十八掌……所以说会点基本拳脚不成套路不成功法，不掌握心法修炼不好功法。这篇方法论，论的就是这些套路，这些招数 —— javascript设计模式个人感受，🙅🏻‍♀️ 谈对错"}},"/posts/js/promise":{"title":"手写PromiseA+实现","data":{"1使用class#1、使用class":"\b平常用 promise 的时候, 是通过 new 关键字来 new Promise(), 所以咱们应该用构造函数或者 class 来实现. 都 2021 年了, 咱们就用 class 来实现一下吧.\nclass MPromise {\n  constructor() {}\n}","2-定义三种状态类型#2. 定义三种状态类型":"const PENDING = \"pending\";\nconst FULFILLED = \"fulfilled\";\nconst REJECTED = \"rejected\";","3-设置初始状态#3. 设置初始状态":"class MPromise {\n  constructor() {\n    // 初始状态为pending\n    this.status = PENDING;\n    this.value = null;\n    this.reason = null;\n  }\n}","4-resolve-和-reject-方法#4. resolve 和 reject 方法":"4.1. 根据A+的规范, 这两个方法是要更改 status 的, 从 pending 改到 fulfilled/rejected.\n4.2. 注意两个函数的入参分别是 value 和 reason.\nclass MPromise {\n  constructor() {\n    // 初始状态为pending\n    this.status = PENDING;\n    this.value = null;\n    this.reason = null;\n  }\n  resolve(value) {\n    if (this.status === PENDING) {\n      this.value = value;\n      this.status = FULFILLED;\n    }\n  }\n  reject(reason) {\n    if (this.status === PENDING) {\n      this.reason = reason;\n      this.status = REJECTED;\n    }\n  }\n}","5-promise入参#5. promise入参":"5.1. 入参是一个函数, 函数接收 resolve 和 reject 两个参数.\n5.2. 注意在初始化 promise 的时候, 就要执行这个函数, 并且有任何报错都要通过 reject 抛出去\nclass MPromise {\n  constructor(fn) {\n    // 初始状态为pending\n    this.status = PENDING;\n    this.value = null;\n    this.reason = null;\n    try {\n      fn(this.resolve.bind(this), this.reject.bind(this));\n    } catch (e) {\n      this.reject(e);\n    }\n  }\n  resolve(value) {\n    if (this.status === PENDING) {\n      this.value = value;\n      this.status = FULFILLED;\n    }\n  }\n  reject(reason) {\n    if (this.status === PENDING) {\n      this.reason = reason;\n      this.status = REJECTED;\n    }\n  }\n}","6-then-方法#6. then 方法":"6.1. then 接收两个参数, onFulfilled 和 onRejected\nthen(onFulfilled, onRejected) {}\n6.2. 检查并处理参数, 之前提到的如果不是 function, 就忽略. 这个忽略指的是原样返回 value 或者 reason.\nisFunction(param) {\n    return typeof param === 'function';\n}\nthen(onFulfilled, onRejected) {\n    const realOnFulfilled = this.isFunction(onFulfilled) ? onFulfilled : (value) => {\n        return value\n    }\n    const realOnRejected = this.isFunction(onRejected) ? onRejected : (reason) => {\n        throw reason;\n    };\n}\n6.3. 要知道.then 的返回值整体是一个 promise, 所以咱们先用 promise 来包裹一下, 其他逻辑待会再实现.\nthen(onFulfilled, onRejected) {\n    const realOnFulfilled = this.isFunction(onFulfilled) ? onFulfilled : (value) => {\n        return value\n    }\n    const realOnRejected = this.isFunction(onRejected) ? onRejected : (reason) => {\n        throw reason;\n    };\n    const promise2 = new MPromise((resolve, reject) => {})\n    return promise2\n}\n6.4. 根据当前 promise 的状态, 调用不同的函数\nthen(onFulfilled, onRejected) {\n    const realOnFulfilled = this.isFunction(onFulfilled) ? onFulfilled : (value) => {\n        return value\n    }\n    const realOnRejected = this.isFunction(onRejected) ? onRejected : (reason) => {\n        throw reason;\n    };\n    const promise2 = new MPromise((resolve, reject) => {\n        switch (this.status) {\n            case FULFILLED: {\n                realOnFulfilled()\n                break;\n            }\n            case REJECTED: {\n                realOnRejected()\n                break;\n            }\n        }\n    })\n    return promise2\n}\n6.5. 这样写, 是在 then 函数被调用的瞬间就会执行. 那这时候如果 status 还没变成 fulfilled 或者 rejected 怎么办, 很有可能还是 pending 的. 所以我们需要一个状态的监听机制, 当状态变成 fulfilled 或者 rejected 后, 再去执行 callback.6.5.1. 那么我们首先要拿到所有的 callback, 然后才能在某个时机去执行他. 新建两个数组, 来分别存储成功和失败的回调, 调用 then 的时候, 如果还是 pending 就存入数组.\nFULFILLED_CALLBACK_LIST = [];\nREJECTED_CALLBACK_LIST = [];\nthen(onFulfilled, onRejected) {\nconst realOnFulfilled = this.isFunction(onFulfilled) ? onFulfilled : (value) => {\n    return value\n}\nconst realOnRejected = this.isFunction(onRejected) ? onRejected : (reason) => {\n    throw reason;\n};\nconst promise2 = new MPromise((resolve, reject) => {\n    switch (this.status) {\n        case FULFILLED: {\n            realOnFulfilled()\n            break;\n        }\n        case REJECTED: {\n            realOnRejected()\n            break;\n        }\n        case PENDING: {\n            this.FULFILLED_CALLBACK_LIST.push(realOnFulfilled)\n            this.REJECTED_CALLBACK_LIST.push(realOnRejected)\n        }\n    }\n})\nreturn promise2\n}\n6.5.2. 在 status 发生变化的时候, 就执行所有的回调. 这里咱们用一下 es6 的 getter 和 setter. 这样更符合语义, 当 status 改变时, 去做什么事情. (当然也可以顺序执行, 在给 status 赋值后, 下面再加一行 forEach)\n_status = PENDING;\nget status() {\n    return this._status;\n}\nset status(newStatus) {\n    this._status = newStatus;\n    switch (newStatus) {\n        case FULFILLED: {\n            this.FULFILLED_CALLBACK_LIST.forEach(callback => {\n                callback(this.value);\n            });\n            break;\n        }\n        case REJECTED: {\n            this.REJECTED_CALLBACK_LIST.forEach(callback => {\n                callback(this.reason);\n            });\n            break;\n        }\n    }\n}","7-then-的返回值#7. then 的返回值":"上面只是简单说了下, then 的返回值是一个 Promise, 那么接下来具体讲一下返回 promise 的 value 和 reason 是什么.7.1. 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e。(这样的话, 我们就需要手动 catch 代码，遇到报错就 reject)\nthen(onFulfilled, onRejected) {\n    const realOnFulfilled = this.isFunction(onFulfilled) ? onFulfilled : (value) => {\n        return value\n    }\n    const realOnRejected = this.isFunction(onRejected) ? onRejected : (reason) => {\n        throw reason;\n    };\n    const promise2 = new MPromise((resolve, reject) => {\n        const fulfilledMicrotask = () => {\n            try {\n                realOnFulfilled(this.value);\n            } catch (e) {\n                reject(e)\n            }\n        };\n        const rejectedMicrotask = () => {\n            try {\n                realOnRejected(this.reason);\n            } catch (e) {\n                reject(e);\n            }\n        }\n        switch (this.status) {\n            case FULFILLED: {\n                fulfilledMicrotask()\n                break;\n            }\n            case REJECTED: {\n                rejectedMicrotask()\n                break;\n            }\n            case PENDING: {\n                this.FULFILLED_CALLBACK_LIST.push(fulfilledMicrotask)\n                this.REJECTED_CALLBACK_LIST.push(rejectedMicrotask)\n            }\n        }\n    })\n    return promise2\n}\n7.2 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值7.3 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因。需要注意的是，如果 promise1 的 onRejected 执行成功了，promise2 应该被 resolve这里咱们其实已经在参数检查的时候做过了, 也就是这段代码\nconst realOnFulfilled = this.isFunction(onFulfilled)\n  ? onFulfilled\n  : (value) => {\n      return value;\n    };\nconst realOnRejected = this.isFunction(onRejected)\n  ? onRejected\n  : (reason) => {\n      throw reason;\n    };\n7.4 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行 resolvePromise 方法\nthen(onFulfilled, onRejected) {\n    const realOnFulfilled = this.isFunction(onFulfilled) ? onFulfilled : (value) => {\n        return value\n    }\n    const realOnRejected = this.isFunction(onRejected) ? onRejected : (reason) => {\n        throw reason;\n    };\n    const promise2 = new MPromise((resolve, reject) => {\n        const fulfilledMicrotask = () => {\n            try {\n                const x = realOnFulfilled(this.value);\n                this.resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n                reject(e)\n            }\n        };\n        const rejectedMicrotask = () => {\n            try {\n                const x = realOnRejected(this.reason);\n                this.resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n                reject(e);\n            }\n        }\n        switch (this.status) {\n            case FULFILLED: {\n                fulfilledMicrotask()\n                break;\n            }\n            case REJECTED: {\n                rejectedMicrotask()\n                break;\n            }\n            case PENDING: {\n                this.FULFILLED_CALLBACK_LIST.push(fulfilledMicrotask)\n                this.REJECTED_CALLBACK_LIST.push(rejectedMicrotask)\n            }\n        }\n    })\n    return promise2\n}","8-resolvepromise#8. resolvePromise":"resolvePromise(promise2, x, resolve, reject) {\n    // 如果 newPromise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 newPromise\n    // 这是为了防止死循环\n    if (promise2 === x) {\n        return reject(new TypeError('The promise and the return value are the same'));\n    }\n    if (x instanceof MPromise) {\n        // 如果 x 为 Promise ，则使 newPromise 接受 x 的状态\n        // 也就是继续执行x，如果执行的时候拿到一个y，还要继续解析y\n        queueMicrotask(() => {\n            x.then((y) => {\n                this.resolvePromise(promise2, y, resolve, reject);\n            }, reject);\n        })\n    } else if (typeof x === 'object' || this.isFunction(x)) {\n        // 如果 x 为对象或者函数\n        if (x === null) {\n            // null也会被判断为对象\n            return resolve(x);\n        }\n        let then = null;\n        try {\n            // 把 x.then 赋值给 then\n            then = x.then;\n        } catch (error) {\n            // 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise\n            return reject(error);\n        }\n        // 如果 then 是函数\n        if (this.isFunction(then)) {\n            let called = false;\n            // 将 x 作为函数的作用域 this 调用\n            // 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise\n            try {\n                then.call(\n                    x,\n                    // 如果 resolvePromise 以值 y 为参数被调用，则运行 resolvePromise\n                    (y) => {\n                        // 需要有一个变量called来保证只调用一次.\n                        if (called) return;\n                        called = true;\n                        this.resolvePromise(promise2, y, resolve, reject);\n                    },\n                    // 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise\n                    (r) => {\n                        if (called) return;\n                        called = true;\n                        reject(r);\n                    });\n            } catch (error) {\n                // 如果调用 then 方法抛出了异常 e：\n                if (called) return;\n                // 否则以 e 为据因拒绝 promise\n                reject(error);\n            }\n        } else {\n            // 如果 then 不是函数，以 x 为参数执行 promise\n            resolve(x);\n        }\n    } else {\n        // 如果 x 不为对象或者函数，以 x 为参数执行 promise\n        resolve(x);\n    }\n}","9-onfulfilled-和-onrejected-是微任务#9. onFulfilled 和 onRejected 是微任务":"咱们可以用 queueMicrotask 包裹执行函数\nconst fulfilledMicrotask = () => {\n  queueMicrotask(() => {\n    try {\n      const x = realOnFulfilled(this.value);\n      this.resolvePromise(promise2, x, resolve, reject);\n    } catch (e) {\n      reject(e);\n    }\n  });\n};\nconst rejectedMicrotask = () => {\n  queueMicrotask(() => {\n    try {\n      const x = realOnRejected(this.reason);\n      this.resolvePromise(promise2, x, resolve, reject);\n    } catch (e) {\n      reject(e);\n    }\n  });\n};","10-简单写点代码测试一下#10. 简单写点代码测试一下":"const test = new MPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(111);\n  }, 1000);\n}).then(console.log);\nconsole.log(test);\nsetTimeout(() => {\n  console.log(test);\n}, 2000);","11-catch-方法#11. catch 方法":"catch (onRejected) {\n    return this.then(null, onRejected);\n}","12-promiseresolve#12. promise.resolve":"将现有对象转为 Promise 对象，如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为 fulfilled。\n注意这是一个静态方法, 因为咱们是通过 Promise.resolve 调用的, 而不是通过实例去调用的.\nstatic resolve(value) {\n    if (value instanceof MPromise) {\n        return value;\n    }\n    return new MPromise((resolve) => {\n        resolve(value);\n    });\n}","13-promisereject#13. promise.reject":"返回一个新的 Promise 实例，该实例的状态为 rejected。Promise.reject 方法的参数 reason，会被传递给实例的回调函数。\nstatic reject(reason) {\n    return new MPromise((resolve, reject) => {\n        reject(reason);\n    });\n}","14-promiserace#14. promise.race":"const p = Promise.race([p1, p2, p3]);该方法是将多个 Promise 实例，包装成一个新的 Promise 实例。\n只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。\nstatic race(promiseList) {\n    return new MPromise((resolve, reject) => {\n        const length = promiseList.length;\n        if (length === 0) {\n            return resolve();\n        } else {\n            for (let i = 0; i < length; i++) {\n                MPromise.resolve(promiseList[i]).then(\n                    (value) => {\n                        return resolve(value);\n                    },\n                    (reason) => {\n                        return reject(reason);\n                    });\n            }\n        }\n    });\n}\n写段测试代码\nconst test = new MPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(111);\n  }, 1000);\n});\nconst test2 = new MPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(222);\n  }, 2000);\n});\nconst test3 = new MPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(333);\n  }, 3000);\n});\nMPromise.race([test, test2, test3]).then(console.log);\n接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n如果所有Promise都成功，则返回成功结果数组\n如果有一个Promise失败，则返回这个失败结果\nstatic all(promises) {\n    const result = []\n    let count = 0\n    return new MyPromise((resolve, reject) => {\n        const addData = (index, value) => {\n            result[index] = value\n            count++\n            if (count === promises.length) resolve(result)\n        }\n        promises.forEach((promise, index) => {\n            if (promise instanceof MyPromise) {\n                promise.then(res => {\n                    addData(index, res)\n                }, err => reject(err))\n            } else {\n                addData(index, promise)\n            }\n        })\n    })\n}\n接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n哪个Promise最快得到结果，就返回那个结果，无论成功失败\nstatic race(promises) {\n    return new MyPromise((resolve, reject) => {\n        promises.forEach(promise => {\n            if (promise instanceof MyPromise) {\n                promise.then(res => {\n                    resolve(res)\n                }, err => {\n                    reject(err)\n                })\n            } else {\n                resolve(promise)\n            }\n        })\n    })\n}\n接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n把每一个Promise的结果，集合成数组，返回\nstatic allSettled(promises) {\n    return new Promise((resolve, reject) => {\n        const res = []\n        let count = 0\n        const addData = (status, value, i) => {\n            res[i] = {\n                status,\n                value\n            }\n            count++\n            if (count === promises.length) {\n                resolve(res)\n            }\n        }\n        promises.forEach((promise, i) => {\n            if (promise instanceof MyPromise) {\n                promise.then(res => {\n                    addData('fulfilled', res, i)\n                }, err => {\n                    addData('rejected', err, i)\n                })\n            } else {\n                addData('fulfilled', promise, i)\n            }\n        })\n    })\n}\nany与all相反\n接收一个Promise数组，数组中如有非Promise项，则此项当做成功\n如果有一个Promise成功，则返回这个成功结果\n如果所有Promise都失败，则报错\n    static any(promises) {\n        return new Promise((resolve, reject) => {\n            let count = 0\n            promises.forEach((promise) => {\n                promise.then(val => {\n                    resolve(val)\n                }, err => {\n                    count++\n                    if (count === promises.length) {\n                        reject(new AggregateError('All promises were rejected'))\n                    }\n                })\n            })\n        })\n    }\n}"}},"/posts/js/prototype":{"title":"Javascript prototype 原型链","data":{"":"图：Nguyen Nhut","原型原型链#原型+原型链":"prototype是函数特有的属性，__proto__是每个对象都有的属性，而prototype本身也是一个对象\n当我们去获取a.name的时候，会先从对象的自身属性开始查找，如果没有的话，就会从a.__proto__上找\n对象a.__proto__又指向构造器函数test的prototype（原型），所以从a.__proto上找属性其实就是在test.prototype找属性，但是prototype（原型）本身又是一个对象，\n这样的话，会重复上面两个步骤，最终都是找到了Object这个构造器函数，而Object.__proto是一个 null 值，如果中间有值就返回，没有就赋值undefined。\n这样的链式结构就是原型链因为构造器函数原型上的constructor是指向构造器函数自身的，所以\na.constructor === test; // true\na.__proto__ === test.prototype  //true\na.__proto__.constructor === test; // true\na.__proto__.constructor === test.prototype.constructor; // true\ntest.prototype.constructor === test  //true\n// 函数（包括原生构造函数）的原型对象为Function.prototype \ntest.__proto__ === Function.prototype // true\n函数都是由 Function 原生构造函数创建的，所以函数的 proto 属性指向 Function 的 prototype 属性。","测试#测试":"function test() {}\ntest.prototype.then = function () {\n  console.log(\"test => then\");\n};\nFunction.prototype.mythen = function () {\n  console.log(\"Function => mythen\");\n};\ntest.mythen();\ntest.then();"}},"/posts/js/regexp":{"title":"正则表达式","data":{"":"图：Peter Tarka","字符#字符":"表达式\t描述\t[abc]\t字符集。匹配集合中所含的任一字符。\t[ ^abc]\t否定字符集。匹配任何不在集合中的字符。\t[a-z]\t字符范围。匹配指定范围内的任意字符。\t.\t匹配除换行符以外的任何单个字符。\t\\\t转义字符。\t\\w\t匹配任何字母数字，包括下划线（等价于[A-Za-z0-9_]）。\t\\W\t匹配任何非字母数字（等价于[ ^a-za-z0-9_]）。\t\\d\t数字。匹配任何数字。\t\\D\t非数字。匹配任何非数字字符。\t\\s\t空白。匹配任何空白字符，包括空格、制表符等。\t\\S\t非空白。匹配任何非空白字符。","分组和引用#分组和引用":"表达式\t描述\t(expression)\t分组。匹配括号里的整个表达式。\t(?:expression)\t非捕获分组。匹配括号里的整个字符串但不获取匹配结果，拿不到分组引用。\t\\num\t对前面所匹配分组的引用。比如(\\d)\\1 可以匹配两个相同的数字，(Code)(Sheep)\\1\\2 则可以匹配 CodeSheepCodeSheep。","锚点边界#锚点/边界":"表达式\t描述\t^\t匹配字符串或行开头。\t$\t匹配字符串或行结尾。\t\\b\t匹配单词边界。比如 Sheep\\b 可以匹配 CodeSheep 末尾的 Sheep，不能匹配 CodeSheepCode 中的 Sheep\t\\B\t匹配非单词边界。比如 Code\\B 可以匹配 HelloCodeSheep 中的 Code，不能匹配 HelloCode 中的 Code。","数量表示#数量表示":"表达式\t描述\t?\t匹配前面的表达式 0 个或 1 个。即表示可选项。\t+\t匹配前面的表达式至少 1 个。\t*\t匹配前面的表达式 0 个或多个。\t|\t或运算符。并集，可以匹配符号前后的表达式。\t{m}\t匹配前面的表达式 m 个。\t{m,}\t匹配前面的表达式最少 m 个。\t{m,n}\t匹配前面的表达式最少 m 个，最多 n 个。","预查断言#预查断言":"表达式\t描述\t(?=)\t正向预查。比如 Code(?=Sheep)能匹配 CodeSheep 中的 Code，但不能匹配 CodePig 中的 Code。\t(?!)\t正向否定预查。比如 Code(?!Sheep)不能匹配 CodeSheep 中的 Code，但能匹配 CodePig 中的 Code。\t(?<=)\t反向预查。比如(?<=Code)Sheep 能匹配 CodeSheep 中的 Sheep，但不能匹配 ReadSheep 中的 Sheep。\t(?<!)\t反向否定预查。比如(?<!Code)Sheep 不能匹配 CodeSheep 中的 Sheep，但能匹配 ReadSheep 中的 Sheep。","特殊标志#特殊标志":"表达式\t描述\t/.../i\t忽略大小写。\t/.../g\t全局匹配。\t/.../m\t多行修饰符。用于多行匹配。"}},"/posts/js/sandbox":{"title":"JS沙箱sandbox的各种实现","data":{"":"图：Peter Tarka","with-全代理沙箱#with 全代理沙箱":"// 监控执行代码\nfunction compileCode(src) {\n  src = `with (exposeObj){${src}}`;\n  return new Function(\"exposeObj\", src);\n}\n// 代理对象\nfunction proxyObj(originObj) {\n  let exposeObj = new Proxy(originObj, {\n    has: (target, key) => {\n      if ([\"console\", \"Math\", \"Date\"].indexOf(key) >= 0) {\n        return target[key];\n      }\n      if (!target.hasOwnProperty(key)) {\n        throw new Error(`${target}上不存在${key}`);\n      }\n      return target[key];\n    },\n  });\n  return exposeObj;\n}\n// 创建沙盒\nfunction createSandbox(src, obj) {\n  let proxy = proxyObj(obj);\n  compileCode(src).call(proxy, proxy);\n}\nconst testObj = {\n  value: 1,\n  a: {\n    b: 2,\n  },\n  c: \"3\",\n};\nconst c = \"c\";\ncreateSandbox(`value='32323';console.log(c);`, testObj);","快照-snapshot-沙箱#快照 Snapshot 沙箱":"核心原理是激活当前沙箱时把前宿主环境的全局变量备份一下，并把上一次对该沙箱做的更改恢复一下（若存在）失活时找出当次沙箱和备份的全局变量不同的属性，存储一下，并把存储的宿主环境恢复一下哈，双缓存策略\nclass SnapshotSandBox {\n  constructor(name) {\n    this.modifyMap = {}; // 存放修改的属性\n    this.windowSnapshot = {};\n  }\n  active() {\n    // 缓存active状态的沙箱\n    this.windowSnapshot = {};\n    for (const item in window) {\n      this.windowSnapshot[item] = window[item];\n    }\n    Object.keys(this.modifyMap).forEach((p) => {\n      window[p] = this.modifyMap[p];\n    });\n  }\n  inactive() {\n    for (const item in window) {\n      if (this.windowSnapshot[item] !== window[item]) {\n        // 记录变更\n        this.modifyMap[item] = window[item];\n        // 还原window\n        window[item] = this.windowSnapshot[item];\n      }\n    }\n  }\n}\nwindow.a = \"1\";\nconst diffSandbox = new SnapshotSandBox();\ndiffSandbox.active(); // 激活沙箱\ndebugger;\nwindow.a = \"0\";\nconsole.log(\"开启沙箱：\", window.a);\ndiffSandbox.inactive(); //失活沙箱\ndebugger;\nconsole.log(\"失活沙箱：\", window.a);\ndiffSandbox.active(); // 重新激活\ndebugger;\nconsole.log(\"再次激活\", window.a);\n这种方式也无法支持多实例，因为运行期间所有的属性都是保存在 window 上的。","代理-proxy-沙箱#代理 Proxy 沙箱":"","单实例#单实例":"class LegacySandBox {\n  addedPropsMapInSandbox = new Map();\n  modifiedPropsOriginalValueMapInSandbox = new Map();\n  currentUpdatedPropsValueMap = new Map();\n  proxyWindow;\n  setWindowProp(prop, value, toDelete = false) {\n    if (value === undefined && toDelete) {\n      delete window[prop];\n    } else {\n      window[prop] = value;\n    }\n  }\n  active() {\n    this.currentUpdatedPropsValueMap.forEach((value, prop) =>\n      this.setWindowProp(prop, value)\n    );\n  }\n  inactive() {\n    this.modifiedPropsOriginalValueMapInSandbox.forEach((value, prop) =>\n      this.setWindowProp(prop, value)\n    );\n    this.addedPropsMapInSandbox.forEach((_, prop) =>\n      this.setWindowProp(prop, undefined, true)\n    );\n  }\n  constructor() {\n    const fakeWindow = Object.create(null);\n    this.proxyWindow = new Proxy(fakeWindow, {\n      set: (target, prop, value, receiver) => {\n        const originalVal = window[prop];\n        if (!window.hasOwnProperty(prop)) {\n          this.addedPropsMapInSandbox.set(prop, value);\n        } else if (!this.modifiedPropsOriginalValueMapInSandbox.has(prop)) {\n          this.modifiedPropsOriginalValueMapInSandbox.set(prop, originalVal);\n        }\n        this.currentUpdatedPropsValueMap.set(prop, value);\n        window[prop] = value;\n      },\n      get: (target, prop, receiver) => {\n        return target[prop];\n      },\n    });\n  }\n}\n// 验证：\nlet legacySandBox = new LegacySandBox();\nlegacySandBox.active();\nlegacySandBox.proxyWindow.city = \"Beijing\";\nconsole.log(\"window.city-01:\", window.city);\nlegacySandBox.inactive();\nconsole.log(\"window.city-02:\", window.city);\nlegacySandBox.active();\nconsole.log(\"window.city-03:\", window.city);\nlegacySandBox.inactive();\n// 输出：\n// window.city-01: Beijing\n// window.city-02: undefined\n// window.city-03: Beijing","多实例#多实例":"class MultipleProxySandbox {\n  active() {\n    this.sandboxRunning = true;\n  }\n  inactive() {\n    this.sandboxRunning = false;\n  }\n  constructor() {\n    const rawWindow = window;\n    const fakeWindow = {};\n    const proxy = new Proxy(fakeWindow, {\n      set: (target, prop, value) => {\n        if (this.sandboxRunning) {\n          target[prop] = value;\n          return true;\n        }\n      },\n      get: (target, prop) => {\n        // 如果fakeWindow里面有，就从fakeWindow里面取，否则，就从外部的window里面取\n        let value = prop in target ? target[prop] : rawWindow[prop];\n        return value;\n      },\n    });\n    this.proxy = proxy;\n  }\n}\nconst context = { document: window.document };\nconst newSandBox1 = new MultipleProxySandbox(\"代理沙箱1\", context);\nnewSandBox1.active();\nconst proxyWindow1 = newSandBox1.proxy;\nconst newSandBox2 = new MultipleProxySandbox(\"代理沙箱2\", context);\nnewSandBox2.active();\nconst proxyWindow2 = newSandBox2.proxy;\nconsole.log(\n  \"共享对象是否相等\",\n  window.document === proxyWindow1.document,\n  window.document === proxyWindow2.document\n);\nproxyWindow1.a = \"1\"; // 设置代理1的值\nproxyWindow2.a = \"2\"; // 设置代理2的值\nwindow.a = \"3\"; // 设置window的值\nconsole.log(\"打印输出的值\", proxyWindow1.a, proxyWindow2.a, window.a);\nnewSandBox1.inactive();\nnewSandBox2.inactive(); // 两个沙箱都失活\nproxyWindow1.a = \"4\"; // 设置代理1的值\nproxyWindow2.a = \"4\"; // 设置代理2的值\nwindow.a = \"4\"; // 设置window的值\nconsole.log(\"失活后打印输出的值\", proxyWindow1.a, proxyWindow2.a, window.a);\nnewSandBox1.active();\nnewSandBox2.active(); // 再次激活\nproxyWindow1.a = \"4\"; // 设置代理1的值\nproxyWindow2.a = \"4\"; // 设置代理2的值\nwindow.a = \"4\"; // 设置window的值\nconsole.log(\"失活后打印输出的值\", proxyWindow1.a, proxyWindow2.a, window.a);\n可以看出最后一种实现是最优实现，既没有操作 window,又能实现多实例，代码又精简，通俗易懂 👍🏻"}},"/posts/js/this":{"title":"this指针、作用域","data":{"":"图：Nguyen Nhut","上下文--作用域#上下文 + 作用域":"","作用域链#作用域链":"let a = 'global';\n  console.log(a);\n  function course() {\n    let b = 'zhuawa';\n    console.log(b);\n    session();\n    function session() {\n      let c = 'this';\n      console.log(c);\n      teacher();\n      function teacher() {\n        let d = 'yy';\n        console.log(d);\n        // 作用域查找\n        console.log(b);\n      }\n    }\n  }\n  course();\n  // 取消了全局、块级作用域\n  if（true) {\n    let e = 1111;\n    console.log(e);\n  }","this-上下文-context#this 上下文 context":"this 是在执行时动态读取上下文决定的，不是在定义时决定函数直接调用 - this 指向 window\nfunction foo() {\n  console.log(\"函数内部的this:\", this);\n}\nfoo();\n隐式绑定 - this 指向调用堆栈的上一级\nfunction fn() {\n  console.log(\"隐式绑定：\", this.a);\n}\nconst obj = {\n  a: 1,\n};\nobj.fn = fn;\nobj.fn();","实战#实战：":"const foo = {\n  bar: 10,\n  fn: function () {\n    console.log(this.bar);\n    console.log(this);\n  },\n};\nlet fn1 = foo.fn;\nfn1();\n// 如何改变指向\nconst o1 = {\n  text: \"o1\",\n  fn: function () {\n    return this.text;\n  },\n};\nconst o2 = {\n  text: \"o2\",\n  fn: function () {\n    return o1.fn();\n  },\n};\nconst o3 = {\n  text: \"o3\",\n  fn: function () {\n    let fn = o1.fn;\n    return fn();\n  },\n};\nconsole.log(o1.fn());\nconsole.log(o2.fn());\nconsole.log(o3.fn());\n在执行函数时，如果函数被上一级所调用，那么上下文即指向上一级\n否则为全局孤立，指向 window\n将 console.log(o2.fn())结果是 o2\n// 1 - 人为干涉、改变this - bind/call/apply\n// 2 - 不许改变this\nconst o1 = {\n  text: \"o1\",\n  fn: function () {\n    return this.text;\n  },\n};\nconst o2 = {\n  text: \"o2\",\n  fn: o1.fn,\n};\n// this指向最后调用他的对象，在fn执行时，函数挂到o2上即可\n显式绑定（bind | apply | call)\nfunction foo() {\n  console.log(\"函数内部的this:\", this);\n}\nfoo();\nfoo.call({ a: 1 });\nfoo.apply({ a: 1 });\nconst bindFoo = foo.bind({ a: 1 });\nbindFoo();\nnew - this 指向的是 new 之后得到的实例\nclass Course {\n  constructor(name) {\n    this.name = name;\n    console.log(\"构造函数中的this\", this);\n  }\n  test() {\n    console.log(\"类方法中的this\", this);\n  }\n}\nconst course = new Course(\"this\");\ncourse.test();\n异步方法中 this 有区别么\nclass Course {\n  constructor(name) {\n    this.name = name;\n    console.log(\"构造函数中的this\", this);\n  }\n  test() {\n    console.log(\"类方法中的this\", this);\n  }\n  asyncTest() {\n    console.log(\"异步方法外\", this);\n    setTimeout(function () {\n      console.log(\"异步方法中的this\", this);\n    }, 100);\n  }\n}\nconst course = new Course(\"this\");\ncourse.test();\ncourse.asyncTest();\n执行 setTimeout 时，传入匿名 function 执行，效果和全局执行函数效果相同\n把 function 改为无独立上下文的箭头函数即可\nbind 原理 / 手写 bind\nbind 在哪里\nfunction sum(a, b, c) {\n  console.log(a, b, c, this);\n  return a + b + c;\n}\n// 1. sum.bind - 在哪里 ? => Function.prototype\n//\nFunction.prototype.newBind = function () {\n  // 2. bind 是什么？\n  // a.返回一个函数 b. 返回原函数执行结果 c. 传参不变\n  const _this = this;\n  const args = Array.prototype.slice.call(arguments);\n  // args特点： 第一项 - newThis, 第二项 ~ 最后一项 - 函数传参\n  const newThis = args.shift();\n  return function () {\n    return _this.apply(newThis, args);\n  };\n};\napply 应用 - 多传参数组化\nMath.max(2, 4, 5, 6);\nconst arr = [2, 4, 5, 6];\nlet max = Math.max.apply(this, arr);","优先级---new--显式--隐式--默认#优先级 - new > 显式 > 隐式 > 默认":"function fn() {\n  console.log(this);\n}\nconst obj = {\n  fn,\n};\nobj.fn(); // obj\n// 显式 > 隐式\nobj.fn.bind(111)();\nfunction foo(a) {\n  this.a = a;\n}\nconst obj1 = {};\nvar bar = foo.bind(obj1);\nbar(2);\nconsole.log(obj1.a); // 2\n// new\nlet baz = new bar(3);\n// new > 显式\nconsole.log(obj1.a); // 2\nconsole.log(baz.a); // 3","闭包-一个函数和他周围状态的引用捆绑在一起的组合#闭包: 一个函数和他周围状态的引用捆绑在一起的组合":"函数作为返回值场景\nfunction mail() {\n  let content = \"信\";\n  return function () {\n    console.log(content);\n  };\n}\nconst envelop = mail();\nenvelop();\n函数外部获取到了函数作用域内的变量值\n函数作为参数\nlet content;\nfunction envelop(fn) {\n  content = 1;\n  fn();\n}\nfunction mail() {\n  console.log(content);\n}\nenvelop(mail);\n函数嵌套\nlet counter = 0;\nfunction outerFn() {\n  function innerFn() {\n    counter++;\n    console.log(counter);\n  }\n  return innerFn;\n}\n事件处理（异步执行）的闭包\nlet lis = document.getElementsByTagName(\"li\");\nfor (var i = 0; i < lis.length; i++) {\n  (function (i) {\n    lis[i].onclick = function () {\n      console.log(i);\n    };\n    // setTimeout(function() {\n    //   console.log(i);\n    // }, 100)\n  })(i);\n}\n立即执行嵌套\n(function immediateA(a) {\n  return (function immediateB(b) {\n    console.log(a); // 0\n  })(1);\n})(0);\n立即执行遇上块级作用域\nlet count = 0;\n(function immediate() {\n  if (count === 0) {\n    let count = 1;\n    console.log(count);\n  }\n  console.log(count);\n})();\n拆分执行 多个闭包\nfunction createIncrement() {\n  let count = 0;\n  function increment() {\n    count++;\n  }\n  let message = `count is ${count}`;\n  function log() {\n    console.log(message);\n  }\n  return [increment, log];\n}\nconst [increment, log] = createIncrement();\nincrement();\nincrement();\nincrement();\nlog(); // count is 0\n实现私有变量\nfunction createStack() {\n  return {\n    items: [],\n    push(item) {\n      this.items.push(item);\n    },\n  };\n}\nconst stack = {\n  items: [],\n  push: function () {},\n};\nfunction createStack() {\n  const items = [];\n  return {\n    push(item) {\n      items.push(item);\n    },\n  };\n}"}},"/posts/js/solid":{"title":"Amazing！Solid 比react还react","data":{"":"图：Vivivian","介绍#介绍":"solid是一个用于构建用户界面，简单高效、性能卓越的JavaScript库Solid 站在 React, Knockout 等巨人的肩膀上。如果你之前用 React Hooks 开发过，Solid 应该看起来很自然。事实上，Solid 模型更简单，没有 Hook 规则。每个组件执行一次，随着依赖项的更新，钩子和绑定会多次执行。Solid 遵循与 React 相同的理念，具有单向数据流、读/写隔离和不可变接口。但是放弃了使用虚拟 DOM，使用了完全不同的实现。\nSvelte 之于 Vue 就像 Solid 之于 React ,\n更低的功耗，更高的性能 ,\nSvelte和Solid就像是电动车，vue和react就像是燃油车，OH!","感受一下#感受一下":"<html>\n  <body>\n    <script type=\"module\">\n      import {\n        createSignal,\n        onCleanup\n      } from \"https://cdn.skypack.dev/solid-js\";\n      import { render } from \"https://cdn.skypack.dev/solid-js/web\";\n      import html from \"https://cdn.skypack.dev/solid-js/html\";\n      import confetti from \"https://cdn.skypack.dev/canvas-confetti\";\n      import moment from \"https://cdn.skypack.dev/moment\";\n      const App = () => {\n        const [count, setCount] = createSignal(0);\n        const timer = setInterval(() => setCount(count() + 1), 1000);\n        const handleAdd = (params) => {\n          setCount((count) => count + params);\n          confetti();\n          console.log(moment().format());\n        };\n        onCleanup(() => clearInterval(timer));\n        return html`<div>${count}</div>\n          <button onClick=${[handleAdd, 2]}>ADD</button>`;\n      };\n      render(App, document.body);\n    </script>\n  </body>\n</html>","在线体验#在线体验":"skypack 用起来感觉也是极好的，Amazing这种编程体验是不是又回到了10年前最纯的样子，看似回到了原点，实则是另一个起点。"}},"/posts/js/threejs-material":{"title":"Threejs 材质","data":{"":"图：Vivivian","材质类型#材质类型":"类型名称\t类型说明\tMeshBasicMaterial\t基本材质\tMeshNormalMaterial\t普通材质（多色）\tMeshMatcapMaterial\t金属材质\tMeshDepthMaterial\t深度材质\tMeshLambertMaterial\t\tMeshPhongMaterial\t冯氏材质，比较光滑，类似瓷器\tMeshToonMaterial\t多面材质\tMeshStandardMaterial\t标准材质","材质属性#材质属性":"属性\t属性说明\tmap\t纹理\tcolor\t颜色\twireframe\t网格\topacity\t不透明度\ttransparent\t透明\talphaMap\t透明通道纹理\tside\t渲染面\tflatShading\t平面着色\tmatcap\t金属贴图\tshininess\t光度\tspecular\t反光颜色\tgradientMap\t渐变纹理\tmetalness\t金属度"}},"/posts/js/threejs-text":{"title":"Threejs 字体","data":{"":"图：Amrit Pal Singh","加载字体#加载字体":"// 通过fontLoader加载字体json文件\nfontLoader.load(\"/fonts/helvetiker_regular.typeface.json\", function (font) {\n  // 创建几何体\n  const textGeometry = new TextGeometry(\"PAGGY\", {\n    // 字体\n    font,\n    // 大小\n    size: 0.5,\n    // 深度\n    height: 0.2,\n    // 细分\n    curveSegments: 12,\n    // 倒角\n    bevelEnabled: true,\n    // 倒角\n    bevelThickness: 0.03,\n    // 倒角大小\n    bevelSize: 0.02,\n    // 倒角位置\n    bevelOffset: 0,\n    // 倒角细分\n    bevelSegments: 5,\n  });\n  // 字体居中\n  textGeometry.center();\n})"}},"/posts/life/ai":{"title":"下一个泡泡玛特工程师是谁呢？","data":{"":"图：AI\nartwork 8k pixiv, handsome face, young man, white shirt, clock eye， full body shot, character sheet, pocket watch， iron chain， cyberpunk, streetwear outfit, ☂️, neon city. detailed, stunning environment, unreal engine, incredible quality.cute, young pale skinny girl,IP character,A cute Kawaii tiny hyper realistic cute random animal , with tech gear, headphones, radio backpack, goggles, helmet, holding phone, highly detailed, Cinematography, photorealistic, epic composition, Unreal Engine 5, Cinematic, Color Grading, Portrait Photography, Ultra-Wide Angle, Depth of Field, hyper detailed, symmetrical face, detailed face, digital painting, ethereal, , character sheets, artstation, concept art, smooth, sharp focus, figure golden glow, suspenders showing legs, high heels showing full feet, Unreal Engine 5 Volumetric Lighting VHSCyberpunk"}},"/posts/life/keyboard":{"title":"机械键盘相关参数","data":{"":"图：AI\n对于程序猿来讲，机械键盘是避不开的东西，就这么点乐子关于键盘外壳的材料就关系到键盘的使用情景了，一般来说对于需要通过蓝牙或者2.4G使用的用户来说，塑料外壳可能便是最好的选择，因为塑料外壳对于蓝牙与2.4G的影响低且价格便宜，相比其他金属，木材更具有性价比，但塑料在使用体验上确实是有一定差距的，相比金属键盘我觉得对于我来说最大的区别可能就在声音，质感和重量上，虽然塑料键盘也可以通过自己填充调试等获得较好的声音但感觉就没有金属外壳的键盘感觉声音那么的低沉，听起来难免有种塑料感，且在日常使用中由于我喜欢使用重一点的键盘给人感觉比较稳当因此我正在使用的两把键盘都是CNC铝合金外壳，起初我最感兴趣的应该是木制键盘，但经过了解关于木制键盘的使用还要去了解相关的保养知识，且使用寿命也不长，日常比较慵懒的我也便选择了放弃，对木制键盘情有独钟的小伙伴可自己去学习下相关知识。对于亚克力堆叠结构与榫卯结构便是通过软件画图最终用亚克力切割出来的外壳，我个人体验上来说堆叠外壳一般会显得更为结实，两种方式的亚克力堆叠键盘在设计合理的情况下效果还是相当的不错的，具有CAD画图经验的小伙伴或者有这方面兴趣的小伙伴可以自己尝试下，自己无从下手的话也可以加入相关Q群会有图纸可以用来参考学习。塑料外壳声音给人感觉不如金属键盘的问题，也可以通过一些简单的操作来缩小差距，根据我的经验最有效的三个方法便是更换定位板，添加夹心棉与底棉和添加轴下垫，我觉得对于一般键盘来说夹心棉和底棉是不可缺少的，可以有效的减弱键盘的空腔音，再在此基础上通过更换定位板使键盘声音更好听手感更舒适，加上轴下垫让键盘声音更聚集来提升键盘的声音，对于夹心棉，轴下垫，底棉的材料我觉得并不用很讲究，能起到填充减震的效果即可。定位板的材料主要有钢板定位板，铝合金定位板，黄铜定位板，碳纤维定位板，玻璃纤维定位板与亚克力定位板等。一般量产键盘用的应该都是钢板定位板虽然效果并没有很好，但也是中规中矩，大家不必嫌弃。我自己用的是亚克力定位板和黄铜定位板，不难看出钢板定位板，铝合金定位板，黄铜定位板这些定位板在定位板中是比较硬的给人的感觉可以说是结实也可以说在砸铁，所以我就干脆在我的船壳上加了一块4mm的定位板虽然比较硬但也有减弱了船壳反馈强度不均匀声音不一致的缺点。在玻璃纤维，碳纤维，亚克力定位板明显软不少，我用亚克力的原因也非常简单也就是懒得换，我比较看好玻璃纤维的材料，这种定位板比碳纤维更软一些且也比较韧想尝试一下。在键盘大键的主轴两旁会有两颗副轴作为支撑这就是卫星轴。卫星轴主要分为PCB卫星轴与钢板卫星轴。钢板卫星轴主要采用固定在定位板上面的形式，卡在定位板板上，主要偏向量产键盘。PCB卫星轴，主要采用螺丝固定在PCB上的形式，虽然价格较贵且需要特殊的PCB电路板，但个人觉得效果比钢板卫星轴好，主要是调试方便，比较精准，而钢板卫星轴虽然有些也许可以达到比PCB卫星轴更好的效果但调试的难度要大不少，毕竟其要兼容各种开口的尺寸，总的来说我觉得对于卫星轴而言重要的是你是否能调试到位才是最重要的。ABS 键帽：触感细腻，但容易打油，需要经常拆洗\nPBT 键帽：颗粒触感，不易打油\nPOM 键帽：硬度、抗摩擦性强于 ABS 键帽，光滑细腻"}},"/posts/life/go":{"title":"碧血丹心","data":{"":"图：胡彦斌\n很符合现在的心情,单曲循环中\n仗剑天涯曾是我们的梦想多少年来只是梦 却从来不敢想时代灯海茫茫 不是我心所往嘈杂中 放声长啸终究没有回响可是男儿从来就不轻言绝望少年的剑还在心里 发着光只要还不服输 侠义就会高昂对世界 说句有种你们跟我一起上走过每一步的痕迹让我不断升级滚滚红尘奔波奋进什么值得珍惜朋友总会撑你的家人总会 疼你的对手不会变少赢你也是注定的谁又能 让时间 停下脚步弯路没 白走成 中流砥柱一生追逐 义无反顾一拳放倒现实的残酷心中充满理想 去征服远方路途坎坷 也不能把我阻挡越过千重山 踏过万重浪将相本无主 男儿当自强何必儿女情长 我逆流而上男儿志在四方 热血有力量我天生倔强 所以寸步不让我似红日光 一心做栋梁战士不老只是改变了战场心中的剑一出手 还在发着光时代不停前行 我也勇往前闯别回头 身后有着数不清的回响我从来不信命 拼就拼个尽兴我命由我 哪里来的天注定我从小命就硬 天生个性任性刀光剑影 也要杀出困境从不会放手 把机会放走把自己当对手 要力争上游誓不罢休 是攥紧的拳头都说越过了山丘后无人等候你说最后是谁 会在最后压轴时间的沙漏 是装在心门上的把手学不会低头 我初心依旧当棋逢对手 我还是我 必定锋芒毕露心中充满理想 去征服远方路途坎坷也不 能把我阻挡越过千重山 踏过万重浪将相本无主 男儿当自强何必儿女情长 我逆流而上男儿志在四方 热血有力量我天生倔强 所以寸步不让我似红日光 一心做栋梁心中不灭理想 像一双翅膀天那么高 是为了让我翱翔沿途风尘早已染尽了风霜我心还炽热 我的血还滚烫心中充满理想 去征服远方路途坎坷也不 能把我阻挡越过千重山 踏过万重浪将相本无主 男儿当自强何必儿女情长 我逆流而上男儿志在四方 热血有力量我天生倔强 所以寸步不让我似红日光 一心做栋梁"}},"/posts/network/base":{"title":"Nodejs 网络 & HTTP","data":{"":"图：Kashish Arora","tcpip网络协议#TCP/IP网络协议":"传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议IP是Internet Protocol（网际互连协议）的缩写，是TCP/IP体系中的网际层协议。是⼀一个协议家族, 以TCP、IP协议为核⼼心, 包含HTTP、SMTP、TELNET等各种协议。","osi七层模型#OSI七层模型":"OSI（开放系统互联(Open System Interconnection)）一般指开放式系统互联开放式系统互联是把网络通信的工作分为7层,分别是物理层,数据链路层,网络层,传输层,会话层,表示层和应用层。第七层： 应用层 为操作系统或者网络应用程序提供访问网络服务的接口。 （html）第六层： 表示层 压缩，格式转换第五层： 会话层 负责数据传输中维持网络设备之间的通信链接第四层： 传输层 把传输表头加到数据上形成数据包，完成端到端的数据传输。协议：TCP UDP第三层： 网络层 负责对子网间的数据包进行寻址和路由选择,可以实现拥塞控制、网际互联等功能。协议：IP; (路由器)第二层： 数据链路层 物理地址寻址 （交换机/猫）第一层： 物理层 在局域网上进行数据传输，负责电脑通信设备与网络媒体之间的互通 (网线网卡……)","数据包#数据包":"数据包是⽹网络层及以上分层中包的单位每个分层都会对发送的数据添加一个首部, 首部包含了该层协议相关的信息, 而真正要发送的内容称之为数据.也就是说每一个数据包都由首部 + 数据组成.而对于下层来说, 上层发送过来的全部内容, 都会当做本层的数据, 举个例子：传输层 TCP包：TCP包首部 + 数据\n网络层 IP包：IP包首部 + (TCP包首部 + 数据)\n数据链路层 以太网包：以太网包首部 + (IP包首部 + (TCP包首部 + 数据))","每层在接收到数据后除了添加首部-还要做什么呢#每层在接收到数据后除了添加首部, 还要做什么呢?":"用户1\n传输层：TCP模块为保证数据的可靠传输, 需要添加TCP首部\n网络层：IP包生成后，参考路由控制表决定接受此 IP 包的路由或主机。\n数据链路层：生成的以太网数据包将通过物理层传输给接收端\n用户2\n数据链路层：主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。\n如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，比如IP.\n网络层：从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，比如TCP\n传输层：在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照顺序接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。\n总结一下几个地址：\n数据链路层的是MAC地址, 用来识别同一链路中的不同计算机\n网络层的是IP地址, 用来识别TCP/IP 网络中互连的主机和路由器\n传输层的是端口号(程序地址), 用来识别同一台计算机中进行通信的不同应用程序","通过以下这几个数据综合来识别一次通信#通过以下这几个数据综合来识别一次通信：":"IP首部：源IP地址\nIP首部：目标IP地址\n协议号, TCP或者UDP\nTCP首部：源端口号\nTCP首部：目标端口号","tcpudp的区别#TCP/UDP的区别":"用户数据报协议（UDP，User Datagram Protocol）\nUDP是无连接的，TCP必须三次握手建立连接\nUDP是面向报文，没有拥塞控制，所以速度快，适合多媒体通信要求，比如及时聊天，支持一对一，一队多。多对一，多对多。\nTCP只能是一对一的可靠性传输\n那么咱们的直播底层是什么协议呢?其实现在常见的rtmp和hls直播, 都是基于TCP的, 希望能提供稳定的直播环境.","tcp通过什么方式提供可靠性#TCP通过什么方式提供可靠性？":"超时重发，发出报文段要是没有收到及时的确认，会重发。\n数据包的校验，也就是校验首部数据和。\n对失序的数据重新排序\n进行流量控制，防止缓冲区溢出\n快重传和快恢复\nTCP会将数据截断为合理的长度","tcp如何控制拥塞#TCP如何控制拥塞？":"拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：\n当cwnd<ssthresh时，使用慢开始算法。也就是乘法算法\n当cwnd>ssthresh时，改用拥塞避免算法。也就是加法算法\n当cwnd=ssthresh时，慢开始与拥塞避免算法任意。\n当出现拥塞的时候就把心的门限值设为此时窗口大小的一般，窗口大小设置为1，再重新执行上面的步骤。\n当收到连续三个重传的时候这就需要快重传和快恢复了，当收到连续三个重传 这个时候发送方就要重传自己的信息，然后门限减半但是这个时候并不是网络阻塞，窗口只会减半执行拥塞避免算法。","tcp协议的一次数据传输-从建立连接到断开连接都有哪些流程#TCP协议的一次数据传输, 从建立连接到断开连接都有哪些流程?":"第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；第二次握手：服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，\n设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，\n将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，\n一并发送给客户端，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，\n向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，\n完成TCP三次握手。完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。通信结束客户端和服务端就断开连接，需要经过四次分手确认。第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；\n此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；\n主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；\n此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。","ip地址#IP地址":"IP 地址（IPv4 地址）由32位正整数来表示，在计算机内部以二进制方式被处理。日常生活中，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数IP地址包含网络标识和主机标识, 比如152.112.110.16152.112.110就是网络标识, 同一网段内网络标识必须相同\n16就是主机标识, 同一网段内主机标识不能重复","ipv6#IPv6":"IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。","dns#DNS":"我们平时访问一个网站, 一个应用程序, 并不是用ip来访问的, 而是用一个域名. 那么域名是怎么和ip地址建立联系的呢?就是通过dns, Domain Name System. 比如wiki上的一个例子以访问 zh.wikipedia.org 为例：客户端发送查询报文\"query zh.wikipedia.org\"至DNS服务器，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果。\n如果记录老化或不存在，则：\nDNS服务器向根域名服务器发送查询报文\"query zh.wikipedia.org\"，根域名服务器返回顶级域 .org 的顶级域名服务器地址。\nDNS服务器向 .org 域的顶级域名服务器发送查询报文\"query zh.wikipedia.org\"，得到二级域 .wikipedia.org 的权威域名服务器地址。\nDNS服务器向 .wikipedia.org 域的权威域名服务器发送查询报文\"query zh.wikipedia.org\"，得到主机 zh 的A记录，存入自身缓存并返回给客户端。"}},"/posts/network/concurrent":{"title":"网络和并发","data":{"":"图：Mako Tsereteli","http-101120-在并发请求上主要区别是什么#HTTP 1.0/1.1/2.0 在并发请求上主要区别是什么?":"HTTP/1.0\n每次 TCP 连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立 TCP 连接.\nHTTP/1.1\n默认采用持续连接(TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive).\n增加了管道机制，在同一个 TCP 连接里，允许多个请求同时发送，增加了并发性，进一步改善了 HTTP 协议的效率，\n但是同一个 TCP 连接里，所有的数据通信是按次序进行的。回应慢，会有许多请求排队，造成\"队头堵塞\"。\nHTTP/2.0\n加了双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题。\n使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 HTTP1.1 大了好几个数量级。\n增加服务器推送的功能，不经请求服务端主动向客户端发送数据。","http11-长连接和-http20-多路复用的区别#HTTP/1.1 长连接和 HTTP/2.0 多路复用的区别?":"HTTP/1.1：同一时间一个 TCP 连接只能处理一个请求, 采用一问一答的形式, 上一个请求响应后才能处理下一个请求. 由于浏览器最大 TCP 连接数的限制, 所以有了最大并发请求数的限制.\nHTTP/2.0：同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。单个连接上可以并行交错的请求和响应，之间互不干扰","那为什么-http11-不能实现多路复用#那为什么 HTTP/1.1 不能实现多路复用?":"HTTP/2 是基于二进制“帧”的协议，HTTP/1.1 是基于“文本分割”解析的协议。HTTP1.1 的报文结构中, 服务器需要不断的读入字节，直到遇到换行符, 或者说一个空白行. 处理顺序是串行的, 一个请求和一个响应需要通过一问一答的形式才能对应起来.\nGET / HTTP/1.1\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding:gzip, deflate, br\nAccept-Language:zh-CN,zh;q=0.9,en;q=0.8\nCache-Control:max-age=0\nConnection:keep-alive\nHost:www.imooc.com\nReferer:https://www.baidu.com/\nHTTP2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。\n帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。\n多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。","控制并发量#控制并发量":"const urls = [\n  {\n    info: \"link1\",\n    time: 3000,\n  },\n  {\n    info: \"link2\",\n    time: 2000,\n  },\n  {\n    info: \"link3\",\n    time: 5000,\n  },\n  {\n    info: \"link4\",\n    time: 1000,\n  },\n  {\n    info: \"link5\",\n    time: 1200,\n  },\n  {\n    info: \"link6\",\n    time: 2000,\n  },\n  {\n    info: \"link7\",\n    time: 800,\n  },\n  {\n    info: \"link8\",\n    time: 3000,\n  },\n];\n// 设置我们要执行的任务\nfunction loadImg(url) {\n  return new Promise((resolve, reject) => {\n    console.log(\"----\" + url.info + \" start!\");\n    setTimeout(() => {\n      console.log(url.info + \" OK!!!\");\n      resolve();\n    }, url.time);\n  });\n}\nmodule.exports = {\n  urls,\n  loadImg,\n};","递归法#递归法":"//index.js\nconst { urls, loadImg } = require(\"./mock\");\nfunction promiseLimit(arr, maxCount) {\n  let current = 0;\n  let pendingList = [];\n  for (let i = 0; i < arr.length; i++) {\n    doSend(arr[i]);\n  }\n  function doSend(item) {\n    if (current < maxCount) {\n      current++;\n      loadImg(item).then(() => {\n        current--;\n        if (pendingList.length > 0) {\n          doSend(pendingList.shift());\n        }\n      });\n    } else {\n      pendingList.push(item);\n    }\n  }\n}\npromiseLimit(urls, 3);","类#类":"const { urls, loadImg } = require(\"./mock\");\nclass PromiseLimit {\n  constructor(props) {\n    const { concurrency } = props;\n    this.concurrency = concurrency || 1;\n    this.pendingList = [];\n    this.limitCount = 0;\n  }\n  add(task) {\n    this.pendingList.push(task);\n    this.run();\n  }\n  run() {\n    if (this.pendingList.length === 0 || this.limitCount === this.concurrency) {\n      return;\n    }\n    this.limitCount++;\n    const fn = this.pendingList.shift();\n    const promise = fn();\n    promise.then(this.complete.bind(this)).catch(this.complete.bind(this));\n  }\n  complete() {\n    this.limitCount--;\n    this.run();\n  }\n}\nconst Limit = new PromiseLimit({ concurrency: 3 });\nfor (let i = 0; i < urls.length; i++) {\n  Limit.add(() => loadImg(urls[i]));\n}"}},"/posts/network/cross-domain":{"title":"跨域方法","data":{"":"图：Mako Tsereteli","1jsonp#1、JSONP":"","原理#原理":"利用script标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以","优缺点#优缺点":"JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具有局限性,不安全可能会遭受 XSS 攻击","实现#实现":"声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。\n创建一个script标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。\n服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是 show，它准备好的数据是 show('我不爱你')。\n最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。\n// index.html\nfunction jsonp({ url, params, callback }) {\n  return new Promise((resolve, reject) => {\n    let script = document.createElement(\"script\");\n    window[callback] = function (data) {\n      resolve(data);\n      document.body.removeChild(script);\n    };\n    params = { ...params, callback }; // wd=b&callback=show\n    let arrs = [];\n    for (let key in params) {\n      arrs.push(`${key}=${params[key]}`);\n    }\n    script.src = `${url}?${arrs.join(\"&\")}`;\n    document.body.appendChild(script);\n  });\n}\njsonp({\n  url: \"http://localhost:3000/say\",\n  params: { wd: \"Iloveyou\" },\n  callback: \"show\",\n}).then((data) => {\n  console.log(data);\n});\n上面这段代码相当于向 http://localhost:3000/say?wd=Iloveyou&callback=show 这个地址请求数据，然后后台返回 show('我不爱你')，最后会运行 show()这个函数，打印出'我不爱你'\n// server.js\nlet express = require(\"express\");\nlet app = express();\napp.get(\"/say\", function (req, res) {\n  let { wd, callback } = req.query;\n  console.log(wd); // Iloveyou\n  console.log(callback); // show\n  res.end(`${callback}('我不爱你')`);\n});\napp.listen(3000);","2cors#2、Cors":"CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。","简单请求#简单请求":"只要同时满足以下两大条件，就属于简单请求\n条件 1：使用下列方法之一：\nGETHEADPOST\n条件 2：Content-Type 的值仅限于下列三者之一：\ntext/plainmultipart/form-dataapplication/x-www-form-urlencoded请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。","复杂请求#复杂请求":"不符合以上条件的请求就肯定是复杂请求了。\n复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为\"预检\"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。我们用 PUT 向后台请求时，属于复杂请求，后台需做如下配置：\n// 允许哪个方法访问我\nres.setHeader(\"Access-Control-Allow-Methods\", \"PUT\");\n// 预检的存活时间\nres.setHeader(\"Access-Control-Max-Age\", 6);\n// OPTIONS请求不做任何处理\nif (req.method === \"OPTIONS\") {\n  res.end();\n}\n// 定义后台返回的内容\napp.put(\"/getData\", function (req, res) {\n  console.log(req.headers);\n  res.end(\"我不爱你\");\n});","3postmessage#3、postMessage":"postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：\n页面和其打开的新窗口的数据传递\n多窗口之间消息传递\n页面与嵌套的 iframe 消息传递\n上面三个场景的跨域数据传递\npostMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。\notherWindow.postMessage(message, targetOrigin, [transfer]);\nmessage: 将要发送到其他 window 的数据。\ntargetOrigin:通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串\"*\"（表示无限制）或者一个 URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。\ntransfer(可选)：是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。接下来我们看个例子： http://localhost:3000/a.html 页面向 http://localhost:4000/b.html 传递“我爱你”,然后后者传回\"我不爱你\"。\n// a.html\n<iframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"></iframe> //等它加载完触发一个事件\n//内嵌在http://localhost:3000/a.html\n<script>\n  function load() {\n    let frame = document.getElementById('frame')\n    frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据\n    window.onmessage = function(e) { //接受返回数据\n      console.log(e.data) //我不爱你\n    }\n  }\n</script>\n// b.html\n  window.onmessage = function(e) {\n    console.log(e.data) //我爱你\n    e.source.postMessage('我不爱你', e.origin)\n }","4websocket#4、websocket":"Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据\n// socket.html\n<script>\n    let socket = new WebSocket('ws://localhost:3000');\n    socket.onopen = function () {\n      socket.send('我爱你');//向服务器发送数据\n    }\n    socket.onmessage = function (e) {\n      console.log(e.data);//接收服务器返回的数据\n    }\n</script>\n// server.js\nlet express = require('express');\nlet app = express();\nlet WebSocket = require('ws');//记得安装ws\nlet wss = new WebSocket.Server({port:3000});\nwss.on('connection',function(ws) {\n  ws.on('message', function (data) {\n    console.log(data);\n    ws.send('我不爱你')\n  });\n})","5node中间件代理两次跨域#5、Node中间件代理(两次跨域)":"实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。\n代理服务器，需要做以下几个步骤：\n接受客户端请求 。\n将请求 转发给服务器。\n拿到服务器 响应 数据。\n将 响应 转发给客户端。\n我们先来看个例子：本地文件index.html文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据。\n// index.html(http://127.0.0.1:5500)\n<script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"></script>\n<script>\n  $.ajax({\n    url: 'http://localhost:3000',\n    type: 'post',\n    data: { name: 'xiamen', password: '123456' },\n    contentType: 'application/json;charset=utf-8',\n    success: function(result) {\n      console.log(result) // {\"title\":\"fontend\",\"password\":\"123456\"}\n    },\n    error: function(msg) {\n      console.log(msg)\n    }\n  })\n</script>\n// server1.js 代理服务器(http://localhost:3000)\nconst http = require('http')\n// 第一步：接受客户端请求\nconst server = http.createServer((request, response) => {\n  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段\n  response.writeHead(200, {\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Methods': '*',\n    'Access-Control-Allow-Headers': 'Content-Type'\n  })\n  // 第二步：将请求转发给服务器\n  const proxyRequest = http\n    .request(\n      {\n        host: '127.0.0.1',\n        port: 4000,\n        url: '/',\n        method: request.method,\n        headers: request.headers\n      },\n      serverResponse => {\n        // 第三步：收到服务器的响应\n        var body = ''\n        serverResponse.on('data', chunk => {\n          body += chunk\n        })\n        serverResponse.on('end', () => {\n          console.log('The data is ' + body)\n          // 第四步：将响应结果转发给浏览器\n          response.end(body)\n        })\n      }\n    )\n    .end()\n})\nserver.listen(3000, () => {\n  console.log('The proxyServer is running at http://localhost:3000')\n})\n// server2.js(http://localhost:4000)\nconst http = require('http')\nconst data = { title: 'fontend', password: '123456' }\nconst server = http.createServer((request, response) => {\n  if (request.url === '/') {\n    response.end(JSON.stringify(data))\n  }\n})\nserver.listen(4000, () => {\n  console.log('The server is running at http://localhost:4000')\n})\n上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出{\"title\":\"fontend\",\"password\":\"123456\"}","6nginx反向代理#6、nginx反向代理":"实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。先下载nginx，然后将nginx目录下的nginx.conf修改如下:\n// proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n最后通过命令行nginx -s reload启动nginx\n// index.html\nvar xhr = new XMLHttpRequest();\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n// 访问nginx中的代理服务器\nxhr.open('get', 'http://www.domain1.com:81/?user=admin', true);\nxhr.send();\n// server.js\nvar http = require('http');\nvar server = http.createServer();\nvar qs = require('querystring');\nserver.on('request', function(req, res) {\n    var params = qs.parse(req.url.substring(2));\n    // 向前台写cookie\n    res.writeHead(200, {\n        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'   // HttpOnly:脚本无法读取\n    });\n    res.write(JSON.stringify(params));\n    res.end();\n});\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');","7windowname--iframe#7、window.name + iframe":"window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。其中a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000\n // a.html(http://localhost:3000/b.html)\n  <iframe src=\"http://localhost:4000/c.html\" frameborder=\"0\" onload=\"load()\" id=\"iframe\"></iframe>\n  <script>\n    let first = true\n    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    function load() {\n      if(first){\n      // 第1次onload(跨域页)成功后，切换到同域代理页面\n        let iframe = document.getElementById('iframe');\n        iframe.src = 'http://localhost:3000/b.html';\n        first = false;\n      }else{\n      // 第2次onload(同域b.html页)成功后，读取同域window.name中数据\n        console.log(iframe.contentWindow.name);\n      }\n    }\n  </script>\nb.html为中间代理页，与a.html同域，内容为空。\n // c.html(http://localhost:4000/c.html)\n  <script>\n    window.name = '我不爱你'  \n  </script>","8locationhash--iframe#8、location.hash + iframe":"实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。\n同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000\n // a.html\n  <iframe src=\"http://localhost:4000/c.html#iloveyou\"></iframe>\n  <script>\n    window.onhashchange = function () { //检测hash的变化\n      console.log(location.hash);\n    }\n  </script>\n // b.html\n  <script>\n    window.parent.parent.location.hash = location.hash \n    //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面\n  </script>\n // c.html\n console.log(location.hash);\n  let iframe = document.createElement('iframe');\n  iframe.src = 'http://localhost:3000/b.html#idontloveyou';\n  document.body.appendChild(iframe);","9documentdomain--iframe#9、document.domain + iframe":"该方式只能用于一级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。\n只需要给页面添加 document.domain ='test.com' 表示二级域名都相同就可以实现跨域。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。我们看个例子：页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中a的值\n// a.html\n<body>\n helloa\n  <iframe src=\"http://b.zf1.cn:3000/b.html\" frameborder=\"0\" onload=\"load()\" id=\"frame\"></iframe>\n  <script>\n    document.domain = 'zf1.cn'\n    function load() {\n      console.log(frame.contentWindow.a);\n    }\n  </script>\n</body>\n// b.html\n<body>\n   hellob\n   <script>\n     document.domain = 'zf1.cn'\n     var a = 100;\n   </script>\n</body>","总结#总结":"JSONP,CORS,postMessage,websocket,node proxy,nginx,iframe[document.domain\\window.name\\location.hash]CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案\nJSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。\n不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。\n日常工作中，用得比较多的跨域方案是cors和nginx反向代理转载自：https://segmentfault.com/a/1190000018017118"}},"/posts/network/curl":{"title":"使用CURL发送POST请求","data":{"":"图：Peter Tarka","简介#简介":"curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。","示例#示例":"curl -H \"Content-Type: application/json\" -X POST -d '{\"user_id\": \"123\", \"coin\":100, \"success\":1, \"msg\":\"OK!\" }' \"http://192.168.0.1:8001/test\"\n参数\t内容\t-H\t请求头\t-d\tPOST 内容\t-X\t请求协议","参数#参数":"","-a#-A":"-A 参数指定客户端的用户代理标头，即 User-Agent。curl 的默认用户代理字符串是 curl/[version]。\n$ curl -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36' https://google.com\n上面命令将 User-Agent 改成 Chrome 浏览器。\n$ curl -A '' https://google.com\n上面命令会移除 User-Agent 标头。也可以通过-H 参数直接指定标头，更改 User-Agent。\n$ curl -H 'User-Agent: php/1.0' https://google.com","-b#-b":"-b 参数用来向服务器发送 Cookie。\n$ curl -b 'foo=bar' https://google.com\n上面命令会生成一个标头 Cookie: foo=bar，向服务器发送一个名为 foo、值为 bar 的 Cookie。\n$ curl -b 'foo1=bar;foo2=bar2' https://google.com\n上面命令发送两个 Cookie。\n$ curl -b cookies.txt https://www.google.com\n上面命令读取本地文件 cookies.txt，里面是服务器设置的 Cookie（参见-c 参数），将其发送到服务器。","-c#-c":"-c 参数将服务器设置的 Cookie 写入一个文件。\n$ curl -c cookies.txt https://www.google.com\n上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件 cookies.txt。","-d#-d":"-d 参数用于发送 POST 请求的数据体。\n$ curl -d'login=emma＆password=123'-X POST https://google.com/login\n# 或者\n$ curl -d 'login=emma' -d 'password=123' -X POST  https://google.com/login\n使用-d 参数以后，HTTP 请求会自动加上标头 Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。-d 参数可以读取本地文本文件的数据，向服务器发送。\n$ curl -d '@data.txt' https://google.com/login\n上面命令读取 data.txt 文件的内容，作为数据体向服务器发送。--data-urlencode\n--data-urlencode 参数等同于-d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。\n$ curl --data-urlencode 'comment=hello world' https://google.com/login\n上面代码中，发送的数据 hello world 之间有一个空格，需要进行 URL 编码。","-e#-e":"-e 参数用来设置 HTTP 的标头 Referer，表示请求的来源。\ncurl -e 'https://google.com?q=example' https://www.example.com\n上面命令将 Referer 标头设为https://google.com?q=example。","-h#-H":"-H参数可以通过直接添加标头 Referer，达到同样效果。\ncurl -H 'Referer: https://google.com?q=example' https://www.example.com","-f#-F":"-F 参数用来向服务器上传二进制文件。\n$ curl -F 'file=@photo.png' https://google.com/profile\n上面命令会给 HTTP 请求加上标头 Content-Type: multipart/form-data，然后将文件 photo.png 作为 file 字段上传。-F 参数可以指定 MIME 类型。\n$ curl -F 'file=@photo.png;type=image/png' https://google.com/profile\n上面命令指定 MIME 类型为 image/png，否则 curl 会把 MIME 类型设为 application/octet-stream。-F 参数也可以指定文件名。\n$ curl -F 'file=@photo.png;filename=me.png' https://google.com/profile\n上面命令中，原始文件名为 photo.png，但是服务器接收到的文件名为 me.png。","-g#-G":"-G 参数用来构造 URL 的查询字符串。\n$ curl -G -d 'q=kitties' -d 'count=20' https://google.com/search\n上面命令会发出一个 GET 请求，实际请求的 URL 为https://google.com/search?q=kitties&count=20。如果省略--G，会发出一个 POST 请求。如果数据需要 URL 编码，可以结合--data--urlencode 参数。\n$ curl -G --data-urlencode 'comment=hello world' https://www.example.com","-h-1#-H":"-H 参数添加 HTTP 请求的标头。\n$ curl -H 'Accept-Language: en-US' https://google.com\n上面命令添加 HTTP 标头 Accept-Language: en-US。\n$ curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' https://google.com\n上面命令添加两个 HTTP 标头。\n$ curl -d '{\"login\": \"emma\", \"pass\": \"123\"}' -H 'Content-Type: application/json' https://google.com/login\n上面命令添加 HTTP 请求的标头是 Content-Type: application/json，然后用-d 参数发送 JSON 数据。","-i#-i":"-i 参数打印出服务器回应的 HTTP 标头。\n$ curl -i https://www.example.com\n上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。","-i-1#-I":"-I 参数向服务器发出 HEAD 请求，然会将服务器返回的 HTTP 标头打印出来。\n$ curl -I https://www.example.com\n上面命令输出服务器对 HEAD 请求的回应。--head 参数等同于-I。\n$ curl --head https://www.example.com","-k#-k":"-k 参数指定跳过 SSL 检测。\n$ curl -k https://www.example.com\n上面命令不会检查服务器的 SSL 证书是否正确。","-l#-L":"-L 参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。\n$ curl -L -d 'tweet=hi' https://api.twitter.com/tweet\n--limit-rate\n--limit-rate 用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。\n$ curl --limit-rate 200k https://google.com\n上面命令将带宽限制在每秒 200K 字节。","-o#-o":"-o 参数将服务器的回应保存成文件，等同于 wget 命令。\n$ curl -o example.html https://www.example.com\n上面命令将www.example.com保存成example.html。","-o-1#-O":"-O 参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。\n$ curl -O https://www.example.com/foo/bar.html\n上面命令将服务器回应保存成文件，文件名为 bar.html。","-s#-s":"-s 参数将不输出错误和进度信息。\n$ curl -s https://www.example.com\n上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。如果想让 curl 不产生任何输出，可以使用下面的命令。\n$ curl -s -o /dev/null https://google.com","-s-1#-S":"-S 参数指定只输出错误信息，通常与-s 一起使用。\n$ curl -s -o /dev/null https://google.com\n上面命令没有任何输出，除非发生错误。","-u#-u":"-u 参数用来设置服务器认证的用户名和密码。\n$ curl -u 'bob:12345' https://google.com/login\n上面命令设置用户名为 bob，密码为 12345，然后将其转为 HTTP 标头 Authorization: Basic Ym9iOjEyMzQ1。curl 能够识别 URL 里面的用户名和密码。\n$ curl https://bob:12345@google.com/login\n上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。\n$ curl -u 'bob' https://google.com/login\n上面命令只设置了用户名，执行后，curl 会提示用户输入密码。","-v#-v":"-v 参数输出通信的整个过程，用于调试。\n$ curl -v https://www.example.com\n--trace 参数也可以用于调试，还会输出原始的二进制数据。\n$ curl --trace - https://www.example.com","-x#-x":"-x 参数指定 HTTP 请求的代理。\n$ curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com\n上面命令指定 HTTP 请求通过 myproxy.com:8080 的 socks5 代理发出。如果没有指定代理协议，默认为 HTTP。\n$ curl -x james:cats@myproxy.com:8080 https://www.example.com\n上面命令中，请求的代理使用 HTTP 协议。","-x-1#-X":"-X 参数指定 HTTP 请求的方法。\n$ curl -X POST https://www.example.com\n上面命令对https://www.example.com发出 POST 请求。"}},"/posts/network/httpdifference":{"title":"http1.1和http2.0有什么区别","data":{"":"图：Nguyen Nhut","http11和http20有什么区别#http1.1和http2.0有什么区别":"","http11#http1.1":"引入了持久链接，即 TCP 默认不关闭，可以被多个请求复用\n引入管道机制，一个 TCP 连接，可以同时发送多个请求\n新增了一些缓存的字段\n新增了一些方法，PUT、DELETE、OPTIONS、PATCH\n支持断点续传，通过请求头字段 Rang 来实现","http20#http2.0":"头部压缩\n多路复用\n二进制传输，头信息和数据体都是二进制\n请求优先级， 设置数据帧的优先级，让服务器优先处理\n服务器主动推送消息","http30#http3.0":"Http3.0 相对于 Http2.0 是一种脱胎换骨的改变！\nhttp 协议是应用层协议，都是建立在传输层之上的。我们也都知道传输层上面不只有 TCP 协议，还有另外一个强大的协议 UDP 协议，2.0 和 1.0 都是基于 TCP 的，因此都会有 TCP 带来的硬伤以及局限性。而 Http3.0 则是建立在 UDP 的基础上。所以其与 Http2.0 之间有质的不同。\nhttp3.0 特性如下\n连接迁移\n无队头阻塞\n自定义的拥塞控制\n前向安全和前向纠错"}},"/posts/network/postget":{"title":"POST和GET区别","data":{"":"图：Kashish Arora","请求参数#请求参数":"get 请求参数是通过 url 传递的，多个参数以&连接；POST 请求放在 request body 中。","请求缓存#请求缓存":"get 请求会被缓存，而 post 请求不会，除非手动设置。","相对的安全性#相对的安全性":"get 是将参数通过 url 传递的，会被浏览器缓存，容易被他人获取，post 相对来说，比较安全。","请求参数长度限制#请求参数长度限制":"get 通过 url 传参，浏览器会限制 url 的长度(http不会)。","编码方式#编码方式":"GET 请求只能进行 url 编码，而 POST 支持多种编码方式。"}},"/posts/nodejs/aspect-oriented":{"title":"nodejs里面向切面编程的一种范式","data":{"":"图：Mako Tsereteli","例子#例子":"比如我们可以在module js解析器的前面或者后面增加一些逻辑\nconst Module = require(\"module\");\nconst prevFunc = Module._extensions[\"js\"];\nModule._extensions[\"js\"] = function (...args) {\n  console.log(\"do something pre\");\n  prevFunc.apply(prevFunc, args);\n  console.log(\"do something post\");\n};\n诸如此类操作"}},"/posts/nodejs/buffer":{"title":"Buffer","data":{"":"图：Nguyen Nhut","背景知识#背景知识":"ArrayBuffer\nArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。\nArrayBuffer 不能直接操作，而是要通过类型数组对象 或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。你可以把它理解为一块内存, 具体存什么需要其他的声明。\nnew ArrayBuffer(length)\n// 参数：length 表示要创建的 ArrayBuffer 的大小，单位为字节。\n// 返回值：一个指定大小的 ArrayBuffer 对象，其内容被初始化为 0。\n// 异常：如果 length 大于 Number.MAX_SAFE_INTEGER（>= 2 ** 53）或为负数，则抛出一个 RangeError 异常。\nex. 比如这段代码, 可以执行一下看看输出什么\nvar buffer = new ArrayBuffer(8);\nvar view = new Int16Array(buffer);\nconsole.log(buffer);\nconsole.log(view);\nUnit8Array\nUint8Array 数组类型表示一个 8 位无符号整型数组，创建时内容被初始化为 0。\n创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。\n// 来自长度\nvar uint8 = new Uint8Array(2);\nuint8[0] = 42;\nconsole.log(uint8[0]); // 42\nconsole.log(uint8.length); // 2\nconsole.log(uint8.BYTES_PER_ELEMENT); // 1\n// 来自数组\nvar arr = new Uint8Array([21,31]);\nconsole.log(arr[1]); // 31\n// 来自另一个 TypedArray\nvar x = new Uint8Array([21, 31]);\nvar y = new Uint8Array(x);\nconsole.log(y[0]); // 21\nArrayBuffer 和 TypedArray的关系\nTypedArray: Unit8Array, Int32Array这些都是TypedArray, 那些 Uint32Array 也好，Int16Array 也好，都是给 ArrayBuffer 提供了一个 “View”，MDN上的原话叫做 “Multiple views on the same data”，对它们进行下标读写，最终都会反应到它所建立在的 ArrayBuffer 之上。ArrayBuffer 本身只是一个 0 和 1 存放在一行里面的一个集合，ArrayBuffer 不知道第一个和第二个元素在数组中该如何分配。为了能提供上下文，我们需要将其封装在一个叫做 View 的东西里面。这些在数据上的 View 可以被添加进确定类型的数组，而且我们有很多种确定类型的数据可以使用。3.1 例如，你可以使用一个 Int8 的确定类型数组来分离存放 8 位二进制字节。3.2 例如，你可以使用一个无符号的 Int16 数组来分离存放 16 位二进制字节。(是不是和8分音符和16分音符有异曲同工之妙？)\n总结\n总之, ArrayBuffer 基本上扮演了一个原生内存的角色.","nodejs-buffer#NodeJs Buffer":"Buffer 类以一种更优化、更适合 Node.js 用例的方式实现了 Uint8Array API.Buffer 类的实例类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存。 Buffer 的大小在被创建时确定，且无法调整。","基本使用#基本使用":"// 创建一个长度为 10、且用 0 填充的 Buffer。\nconst buf1 = Buffer.alloc(10);\n// 创建一个长度为 10、且用 0x1 填充的 Buffer。 \nconst buf2 = Buffer.alloc(10, 1);\n// 创建一个长度为 10、且未初始化的 Buffer。\n// 这个方法比调用 Buffer.alloc() 更快，\n// 但返回的 Buffer 实例可能包含旧数据，\n// 因此需要使用 fill() 或 write() 重写。\nconst buf3 = Buffer.allocUnsafe(10);\n// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。\nconst buf4 = Buffer.from([1, 2, 3]);\n// 创建一个包含 UTF-8 字节  的 Buffer。\nconst buf5 = Buffer.from('tést');","tips#tips":"当调用 Buffer.allocUnsafe() 时，被分配的内存段是未初始化的（没有用 0 填充）。\n虽然这样的设计使得内存的分配非常快，但已分配的内存段可能包含潜在的敏感旧数据。 使用通过 Buffer.allocUnsafe() 创建的没有被完全重写内存的 Buffer ，在 Buffer内存可读的情况下，可能泄露它的旧数据。\n虽然使用 Buffer.allocUnsafe() 有明显的性能优势，但必须额外小心，以避免给应用程序引入安全漏洞。","buffer-与字符编码#Buffer 与字符编码":"Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。\nconst buf = Buffer.from('hello world', 'ascii');\nconsole.log(buf)\n// 输出 68656c6c6f20776f726c64\nconsole.log(buf.toString('hex'));\n// 输出 aGVsbG8gd29ybGQ=\nconsole.log(buf.toString('base64'));\nNode.js 目前支持的字符编码包括：\nascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\nutf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。\nutf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。\nucs2 - 'utf16le' 的别名。\nbase64 - Base64 编码。当从字符串创建 Buffer 时，按照 RFC4648 第 5 章的规定，这种编码也将正确地接受 “URL 与文件名安全字母表”。\nlatin1 - 一种把 Buffer 编码成一字节编码的字符串的方式（由 IANA 定义在 RFC1345 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码）。\nbinary - 'latin1' 的别名。\nhex - 将每个字节编码为两个十六进制字符。","buffer-内存管理#Buffer 内存管理":"在介绍 Buffer 内存管理之前，我们要先来介绍一下 Buffer 内部的 8K 内存池。","8k-内存池#8K 内存池":"在 Node.js 应用程序启动时，为了方便地、高效地使用 Buffer，会创建一个大小为 8K 的内存池。\nBuffer.poolSize = 8 * 1024; // 8K\nvar poolSize, poolOffset, allocPool;\n// 创建内存池\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeArrayBuffer(poolSize);\n  poolOffset = 0;\n}\ncreatePool();\n在 createPool() 函数中，通过调用 createUnsafeArrayBuffer() 函数来创建 poolSize（即8K）的 ArrayBuffer 对象。createUnsafeArrayBuffer() 函数的实现如下：\nfunction createUnsafeArrayBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new ArrayBuffer(size); // 创建指定size大小的ArrayBuffer对象，其内容被初始化为0。\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n这里你只需知道 Node.js 应用程序启动时，内部有个 8K 的内存池即可。\n那接下来我们要介绍哪个对象呢？在前面的预备知识部分，我们简单介绍了 ArrayBuffer 和 Unit8Array 相关的基础知识，而 ArrayBuffer 的应用在 8K 的内存池部分的已经介绍过了。那接下来当然要轮到 Unit8Array 了，我们再来回顾一下它的语法：\nUint8Array(length);\nUint8Array(typedArray);\nUint8Array(object);\nUint8Array(buffer [, byteOffset [, length]]);\n其实除了 Buffer 类外，还有一个 FastBuffer 类，该类的声明如下：\nclass FastBuffer extends Uint8Array {\n  constructor(arg1, arg2, arg3) {\n    super(arg1, arg2, arg3);\n  }\n}\n是不是知道 Uint8Array 用在哪里了，在 FastBuffer 类的构造函数中，通过调用 Uint8Array(buffer [, byteOffset [, length]]) 来创建 Uint8Array 对象。\n那么现在问题来了，FastBuffer 有什么用？它和 Buffer 类有什么关系？带着这两个问题，我们先来一起分析下面的简单示例：\nconst buf = Buffer.from('semlinker');\nconsole.log(buf); // <Buffer 73 65 6d 6c 69 6e 6b 65 72>\n为什么输出了一串数字, 我们创建的字符串呢? 来看一下源码\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function from(value, encodingOrOffset, length) {\n  if (typeof value === \"string\") return fromString(value, encodingOrOffset);\n  // 处理其它数据类型，省略异常处理等其它代码\n  if (isAnyArrayBuffer(value))\n    return fromArrayBuffer(value, encodingOrOffset, length);\n  var b = fromObject(value);\n};\n可以看出 Buffer.from() 工厂函数，支持基于多种数据类型（string、array、buffer 等）创建 Buffer 对象。对于字符串类型的数据，内部调用 fromString(value, encodingOrOffset) 方法来创建 Buffer 对象。是时候来会一会 fromString() 方法了，它内部实现如下：\nfunction fromString(string, encoding) {\n  var length;\n  if (typeof encoding !== \"string\" || encoding.length === 0) {\n    if (string.length === 0) return new FastBuffer();\n    // 若未设置编码，则默认使用utf8编码。\n    encoding = \"utf8\"; \n    // 使用 buffer binding 提供的方法计算string的长度\n    length = byteLengthUtf8(string);\n  } else {\n\t// 基于指定的 encoding 计算string的长度\n    length = byteLength(string, encoding, true);\n    if (length === -1)\n      throw new errors.TypeError(\"ERR_UNKNOWN_ENCODING\", encoding);\n    if (string.length === 0) return new FastBuffer();\n  }\n  // 当字符串所需字节数大于4KB，则直接进行内存分配\n  if (length >= Buffer.poolSize >>> 1)\n    // 使用 buffer binding 提供的方法，创建buffer对象\n    return createFromString(string, encoding);\n  // 当剩余的空间小于所需的字节长度，则先重新申请8K内存\n  if (length > poolSize - poolOffset)\n    // allocPool = createUnsafeArrayBuffer(8K); poolOffset = 0;\n    createPool(); \n  // 创建 FastBuffer 对象，并写入数据。\n  var b = new FastBuffer(allocPool, poolOffset, length);\n  const actual = b.write(string, encoding);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case, though.\n    b = new FastBuffer(allocPool, poolOffset, actual);\n  }\n  // 更新pool的偏移\n  poolOffset += actual;\n  alignPool();\n  return b;\n所以我们得到这样的结论\n当未设置编码的时候，默认使用 utf8 编码；\n当字符串所需字节数大于4KB，则直接进行内存分配；\n当字符串所需字节数小于4KB，但超过预分配的 8K 内存池的剩余空间，则重新申请 8K 的内存池；\n调用 new FastBuffer(allocPool, poolOffset, length) 创建 FastBuffer 对象，进行数据存储，数据成功保存后，会进行长度校验、更新 poolOffset 偏移量和字节对齐等操作。"}},"/posts/nodejs/cjs-implementation":{"title":"CommonJS简易版实现","data":{"":"图：Mako Tsereteli","逻辑#逻辑":"借助nodejs的虚拟机vm模块，通过nodejs读取文件，字符串包裹文件内容一层函数，实现自定义模块参数注入","代码#代码":"需要创建3个文件来验证\nindex.js 入口文件\nmodule.js 模块文件\nrequire.js 逻辑实现文件","indexjs#index.js":"require('./require.js')\nconst result = myRequire('./module.js')\nconsole.log('result',result)","modulejs#module.js":"myExports.default = { name: \"John\" };\nconsole.log('Author',Author)","requirejs#require.js":"const vm = require(\"vm\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nfunction myRequire(filename) {\n  const pathToFile = path.resolve(__dirname, filename);\n  const content = fs.readFileSync(pathToFile, \"utf-8\");\n  const wrapper = [\n    \"(function(myRequire,myModule,myExports,__dirname,__filename,Author){\",\n    \"})\",\n  ];\n  const wrapperContent = wrapper[0] + content + wrapper[1];\n  const script = new vm.Script(wrapperContent, {\n    filename,\n  });\n  const myModule = {\n    myExports: {},\n  };\n  const result = script.runInThisContext();\n  result(\n    myRequire,\n    myModule,\n    myModule.myExports,\n    pathToFile,\n    filename,\n    \"Favori\"//自定义全局变量注入\n  );\n  return myModule.myExports;\n}\nglobal.myRequire = myRequire;","验证#验证":"在命令行工具里执行 node index.js，输出如下结果\n[Running] node \"./index.js\"\nAuthor Favori\nresult { default: { name: 'John' } }\n[Done] exited with code=0 in 0.051 seconds\n到此我们就用最简易的方式实现了一个自定义模块加载器，觉得不错的收藏一下吧！"}},"/posts/nodejs/createtcp":{"title":"如何使用Nodejs来创建一个TCP/UDP服务?","data":{"":"图：Mako Tsereteli","如何使用nodejs来创建一个tcp服务#如何使用Nodejs来创建一个TCP服务":"在这之前咱们要先来了解一下Socket的概念,我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信, 比如create，listen，accept，connect，read和write等等。node里有各种网络相关的模块, http为应用层模块，主要按照特定协议编解码数据；net为传输层模块，主要负责传输编码后的应用层数据；https是个综合模块（涵盖了http/tls/crypto等），主要用于确保数据安全性\n创建tcp服务端\nconst net = require('net');\nconst HOST = '127.0.0.1';\nconst PORT = 7777;\n// 创建一个TCP服务器实例，调用listen函数开始监听指定端口\n// net.createServer()有一个参数, 是监听连接建立的回调\nnet.createServer((socket) => {\n    const remoteName = `${socket.remoteAddress}:${socket.remotePort}`;\n    // 建立成功了一个连接, 这个回调函数里返回一个socket对象.\n    console.log(`${remoteName} 连接到本服务器`);\n    // 接收消息\n    socket.on('data', (data) => {\n        console.log(`${remoteName} - ${data}`)\n        // 给客户端发消息\n        socket.write(`你刚才说啥？是${data}吗？`);\n    });\n    // 关闭\n    socket.on('close', (data) => {\n        console.log(`${remoteName} 连接关闭`)\n    });\n}).listen(PORT, HOST);\nconsole.log(`Server listening on ${HOST}:${PORT}`);\n创建tcp客户端\nconst net = require('net');\nconst HOST = '127.0.0.1';\nconst PORT = 7777;\nconst client = new net.Socket();\nconst ServerName = `${HOST}:${PORT}`;\nlet count = 0;\nclient.connect(PORT, HOST, () => {\n    console.log(`成功连接到 ${ServerName}`);\n    // 向服务端发送数据\n    const timer = setInterval(() => {\n        if (count > 10) {\n            client.write('我没事了, 告辞');\n            clearInterval(timer);\n            return;\n        }\n        client.write('马冬梅' + count++);\n    }, 1000)\n});\n// 接收消息\nclient.on('data', (data) => {\n    console.log(`${ServerName} - ${data}`);\n    // 关闭连接\n    // client.destroy();\n});\n// 关闭事件\nclient.on('close', () => {\n    console.log('Connection closed');\n});\nclient.on('error', (error) => {\n    console.log(error);\n})\n运行一下\nnode tcp-server.jsnode tcp-client.js","如何使用nodejs来创建一个udp服务#如何使用NodeJs来创建一个UDP服务?":"创建udp服务端\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('message', (msg, remote) => {\n    console.log(`${remote.address}:${remote.port} - ${msg}`)\n    server.send(`收到！`, remote.port, remote.address);\n})\nserver.on('listening', () => {\n    const address = server.address()\n    console.log(`Server listening on ${address.address}:${address.port}`);\n})\nserver.bind(44444);\n创建udp客户端\nconst dgram = require('dgram')\nconst message = Buffer.alloc(5, 'john')\nconst client = dgram.createSocket('udp4')\nclient.send(message, 0, message.length, 44444, 'localhost',\n    (err, bytes) => {\n        console.log(`发送成功${bytes}字节`);\n        // client.close()\n    }\n)\nclient.on('message', (buffer) => {\n    console.log(buffer.toString())\n})\n运行一下\nnode udp-server.jsnode udp-client.js"}},"/posts/nodejs/cli":{"title":"如何开发一个cli","data":{"":"图：Philipp Kühn\n我们来开发一个下载仓库代码，并通过命令行界面来启动项目的功能","准备工作#准备工作":"安装以下工具,注意版本\nclear: 清屏\nchalk: 装饰作用，使之终端上的输出加上颜色\nfiglet: 将字母转化为字符拼成的文字\ngit-pull-or-clone：将代码下载\ninquirer: 在命令行中打出交互式的命令\nora: 优雅的显示loading效果","编码#编码":"const { resolve } = require(\"path\");\nconst fs = require(\"fs\");\nconst { promisify } = require(\"util\");\nconst chalk = require(\"chalk\");\nconst inquirer = require(\"inquirer\");\nconst figlet = require(\"figlet\");\nconst clear = require(\"clear\");\nconst ora = require(\"ora\");\nconst download = promisify(require(\"git-pull-or-clone\"));\nconst { spawn, log } = require(\"./utils\");\n//仓库地址\nconst repo = \"git@github.com:yuanguandong/react-keyevent.git\";\n//清屏\nclear();\n//打印logo\nlog(\n  figlet.textSync(\"WIDGET\", {\n    horizontalLayout: \"fitted\",\n    verticalLayout: \"default\",\n    width: 80,\n    whitespaceBreak: true,\n  }),\n  \"green\"\n);\n//主流程\nconst main = async () => {\n  // 项⽬名称\n  const answer = await inquirer.prompt([\n    {\n      type: \"input\",\n      message: \"DirName:\",\n      name: \"name\",\n      default: \"widgets\", // 默认值\n    },\n  ]);\n  const dir = resolve(`./${answer.name}`);\n  const process = ora(chalk[\"gray\"](`${dir} loading.....`));\n  process.start();\n  try {\n    await download(repo, dir);\n    process.succeed();\n    log(`✅ Download Success`);\n  } catch (e) {\n    log(e, \"red\");\n    process.fail();\n  }\n  tool(answer.name, dir);\n};\n//工具方法\nconst actions = {\n  install: async ({ dir, name }) => {\n    log(\"installing....\", \"gray\");\n    await spawn(\"pnpm\", [\"install\"], { cwd: `${name}/` });\n    log(\"✅ Installed\");\n  },\n  run: async ({ dir, name }) => {\n    const isFile = fs.existsSync(`${dir}/node_modules`);\n    if (isFile) {\n      const res = await spawn(\"pnpm\", [\"run\", \"test\"], { cwd: `${name}/` });\n      return;\n    } else {\n      log(\"Not Installed\", \"red\");\n    }\n  },\n  exit: async ({ dir, name }) => {\n    const isFile = fs.existsSync(`${dir}/node_modules`);\n    if (isFile) {\n      log(\"🖐  Bye Bye!\", \"yellow\");\n    }\n    return;\n  },\n};\n//工具箱\nasync function tool(name, dir) {\n  const answer = await inquirer.prompt([\n    {\n      type: \"rawlist\",\n      message: \"Action\",\n      name: \"operation\",\n      choices: Object.keys(actions),\n    },\n  ]);\n  const res = await actions[answer.operation]({ dir, name });\n  if (!res) {\n    return;\n  }\n  tool(name, dir);\n}\nmain();\nmodule.exports = { main, tool };","utils#Utils":"const chalk = require(\"chalk\");\nconst { spawn: _spawn } = require(\"child_process\");\nconst spawn = async (...args) => {\n  return new Promise((resolve) => {\n    const proc = _spawn(...args);\n    proc.stdout.pipe(process.stdout);\n    proc.stderr.pipe(process.stderr);\n    proc.on(\"close\", (...restArgs) => {\n      resolve(restArgs);\n    });\n  });\n};\nconst log = (msg, color = \"green\", ...arg) =>\n  console.log(chalk[color](msg, arg));\nmodule.exports = { spawn, log };"}},"/posts/nodejs/deploy":{"title":"如何部署Nodejs服务","data":{"":"图：Nguyen Nhut","服务器#服务器":"阿里云\nhttps://www.aliyun.com/daily-act/ecs/activity_selection","下载安装包#下载安装包":"wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz","解压#解压":"tar xf  node-v10.9.0-linux-x64.tar.xz","设置软链接#设置软链接":"ln -s /root/node-v10.9.0-linux-x64/bin/node   /usr/local/bin/node\nln -s /root/node-v10.9.0-linux-x64/bin/npm   /usr/local/bin/npm`","查看node版本和npm版本#查看Node版本和npm版本":"node -v\nnpm -v","设置npm源#设置npm源":"npm config set registry  https://registry.npm.taobao.org","服务器安装pm2#服务器安装pm2":"npm install -g pm2\nln -s /root/node-v10.9.0-linux-x64/bin/pm2 /usr/local/bin/","配置ssh#配置ssh":"本地生成秘钥对: ssh-keygen -t rsa  demo_id_rsa\n将公钥放到服务器上:\nscp ~/.ssh/demo_id_rsa.pub root@39.107.238.161:/root/.ssh/authorized_keys\n修改ssh配置 vi ~/.ssh/config\nHost john\nHostName 39.107.238.161\nUser root\nPort 22\nIdentityFile ~/.ssh/demo_id_rsa\n服务器上修改ssh配置 vim /etc/ssh/sshd_config\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n最后就可以ssh登录了! ssh john","将本地代码同步到服务器#将本地代码同步到服务器":"rsync -avzp -e \"ssh\" ./Internet/ john:/root/app","服务器上启动http#服务器上启动http":"pm2 start /root/app/http-server.js","本地修改发布命令#本地修改发布命令":"新建deploy.sh文件\n#!/bin/bash\nHOST=john\nrsync -avzp -e \"ssh\" ./Internet/ $HOST:/root/app\nssh $HOST \"pm2 restart /root/app/http-server.js\"\necho 'deploy success'\n初始化npm命令npm init\n新增scripts \"deploy\": \"./deploy.sh\"发布npm run deploy","修改http-server的监听host#修改http-server的监听host":"const http = require('http')\nconst host = '0.0.0.0';\nconst port = 80;\nhttp.createServer(function (req, res) {\n    res.writeHead(## {\n        'Content-Type': 'text/plain'\n    })\n    res.end('Hello World')\n}).listen(port, host)\nconsole.log(`Server running at http://${host}:${port}/`)\nECS安全组添加80端口查看服务器上是否已正常监听80端口netstat -tpln","通过ip端口访问#通过ip+端口访问":"39.107.238.161:80"}},"/posts/nodejs/event-emitter":{"title":"手写EventEmitter事件巴士","data":{"":"图：Nguyen Nhut","实现#实现":"class EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n  on(name, fn) {\n    if (!this.events[name]) {\n      this.events[name] = [];\n    }\n    this.events[name].push(fn);\n    return this;\n  }\n  emit(name, ...args) {\n    if (!this.events[name]) {\n      console.log(\"没有注册这个事件\");\n      return this;\n    }\n    this.events[name].forEach((fn) => fn.apply(this, args));\n    return this;\n  }\n  once(name, fn) {\n    //包一层多做一步off\n    const func = (...args) => {\n      this.off(name, func);\n      fn.apply(this, args);\n    };\n    this.on(name, func);\n    return this;\n  }\n  off(name, fn) {\n    if (!this.events[name]) {\n      return this;\n    }\n    //如果不指定fn,那么全部移除掉\n    if (!fn) {\n      delete this.events[name];\n      return this;\n    }\n    //如果指定了fn,那么移除对应的fn\n    const index = this.evnets[name].indexOf(fn);\n    this.evnets[name].splice(index, 1);\n    return this;\n  }\n}","测试#测试":"const eventEmitter = new EventEmitter();\neventEmitter.on(\"test\", (args) => {\n  console.log(args);\n});\neventEmitter.emit(\"test\", { a: 1 });"}},"/posts/nodejs/eventloop":{"title":"NodeJS 事件循环模型","data":{"":"图：Nguyen Nhut","什么是事件循环#什么是事件循环":"事件循环使 Node.js 可以通过将操作转移到系统内核中来执行非阻塞 I/O 操作（尽管 JavaScript 是单线程的）。由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。 当这些操作之一完成时，内核会告诉 Node.js，以便可以将适当的回调添加到轮询队列中以最终执行。Node.js 启动时，它将初始化事件循环，处理提供的输入脚本，这些脚本可能会进行异步 API 调用，调度计时器或调用 process.nextTick， 然后开始处理事件循环。\n⌚️\n   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n每个阶段都有一个要执行的回调 FIFO 队列。 尽管每个阶段都有其自己的特殊方式，但是通常，当事件循环进入给定阶段时，它将执行该阶段特定的任何操作，然后在该阶段的队列中执行回调，直到队列耗尽或执行回调的最大数量为止。 当队列已为空或达到回调限制时，事件循环将移至下一个阶段，依此类推。","各阶段概览#各阶段概览":"timers：此阶段执行由 setTimeout 和 setInterval 设置的回调。\npending callbacks：执行推迟到下一个循环迭代的 I/O 回调。\nidle, prepare, ：仅在内部使用。\npoll：取出新完成的 I/O 事件；执行与 I/O 相关的回调（除了关闭回调，计时器调度的回调和 setImmediate 之外，几乎所有这些回调） 适当时，node 将在此处阻塞。\ncheck：在这里调用 setImmediate 回调。\nclose callbacks：一些关闭回调，例如 socket.on('close', ...)。\n在每次事件循环运行之间，Node.js 会检查它是否正在等待任何异步 I/O 或 timers，如果没有，则将其干净地关闭。","各阶段详细解析#各阶段详细解析":"","timers-计时器阶段#timers 计时器阶段":"计时器可以在回调后面指定时间阈值，但这不是我们希望其执行的确切时间。 计时器回调将在经过指定的时间后尽早运行。 但是，操作系统调度或其他回调的运行可能会延迟它们。-- 执行的实际时间不确定\nconst fs = require(\"fs\");\nfunction someAsyncOperation(callback) {\n  // Assume this takes 95ms to complete\n  fs.readFile(\"/path/to/file\", callback);\n}\nconst timeoutScheduled = Date.now();\nsetTimeout(() => {\n  const delay = Date.now() - timeoutScheduled;\n  console.log(`${delay}ms have passed since I was scheduled`);\n}, 100);\n// do someAsyncOperation which takes 95 ms to complete\nsomeAsyncOperation(() => {\n  const startCallback = Date.now();\n  // do something that will take 10ms...\n  while (Date.now() - startCallback < 10) {\n    // do nothing\n  }\n});\n当事件循环进入 poll 阶段时，它有一个空队列（fs.readFile 尚未完成），因此它将等待直到达到最快的计时器 timer 阈值为止。\n等待 95 ms 过去时，fs.readFile 完成读取文件，并将需要 10ms 完成的其回调添加到轮询 (poll) 队列并执行。\n回调完成后，队列中不再有回调，此时事件循环已达到最早计时器 (timer) 的阈值 (100ms)，然后返回到计时器 (timer) 阶段以执行计时器的回调。\n在此示例中，您将看到计划的计时器与执行的回调之间的总延迟为 105ms。","pending-callbacks-阶段#pending callbacks 阶段":"此阶段执行某些系统操作的回调，例如 TCP 错误。 平时无需关注","轮询-poll-阶段#轮询 poll 阶段":"轮询阶段具有两个主要功能：\n计算应该阻塞并 I/O 轮询的时间\n处理轮询队列 (poll queue) 中的事件\n当事件循环进入轮询 (poll) 阶段并且没有任何计时器调度 (timers scheduled) 时，将发生以下两种情况之一：\n如果轮询队列 (poll queue) 不为空，则事件循环将遍历其回调队列，使其同步执行，直到队列用尽或达到与系统相关的硬限制为止 (到底是哪些硬限制？)。\n如果轮询队列为空，则会发生以下两种情况之一：\n2.1 如果已通过 setImmediate 调度了脚本，则事件循环将结束轮询 poll 阶段，并继续执行 check 阶段以执行那些调度的脚本。\n2.2 如果脚本并没有 setImmediate 设置回调，则事件循环将等待 poll 队列中的回调，然后立即执行它们。\n一旦轮询队列 (poll queue) 为空，事件循环将检查哪些计时器 timer 已经到时间。 如果一个或多个计时器 timer 准备就绪，则事件循环将返回到计时器阶段，以执行这些计时器的回调。","检查阶段-check#检查阶段 check":"此阶段允许在轮询 poll 阶段完成后立即执行回调。 如果轮询 poll 阶段处于空闲，并且脚本已使用 setImmediate 进入 check 队列，则事件循环可能会进入 check 阶段，而不是在 poll 阶段等待。setImmediate 实际上是一个特殊的计时器，它在事件循环的单独阶段运行。 它使用 libuv API，该 API 计划在轮询阶段完成后执行回调。通常，在执行代码时，事件循环最终将到达轮询 poll 阶段，在该阶段它将等待传入的连接，请求等。但是，如果已使用 setImmediate 设置回调并且轮询阶段变为空闲，则它将将结束并进入 check 阶段，而不是等待轮询事件。","close-callbacks-阶段#close callbacks 阶段":"如果套接字或句柄突然关闭（例如 socket.destroy），则在此阶段将发出 'close' 事件。 否则它将通过 process.nextTick 发出。","setimmediate-和-settimeout-的区别#setImmediate 和 setTimeout 的区别":"setImmediate 和 setTimeout 相似，但是根据调用时间的不同，它们的行为也不同。\nsetImmediate 设计为在当前轮询 poll 阶段完成后执行脚本。\nsetTimeout 计划在以毫秒为单位的最小阈值过去之后运行脚本。\nTips: 计时器的执行顺序将根据调用它们的上下文而有所不同。 如果两者都是主模块中调用的，则时序将受到进程性能的限制.来看两个例子：\n在主模块中执行两者的执行顺序是不固定的, 可能 timeout 在前, 也可能 immediate 在前\nsetTimeout(() => {\n  console.log(\"timeout\");\n}, 0);\nsetImmediate(() => {\n  console.log(\"immediate\");\n});\n在同一个 I/O 回调里执行setImmediate 总是先执行\nconst fs = require(\"fs\");\nfs.readFile(__filename, () => {\n  setTimeout(() => {\n    console.log(\"timeout\");\n  }, 0);\n  setImmediate(() => {\n    console.log(\"immediate\");\n  });\n});\n问题：那为什么在外部 (比如主代码部分 mainline) 这两者的执行顺序不确定呢？解答：在 主代码 部分执行 setTimeout 设置定时器 (此时还没有写入队列)，与 setImmediate 写入 check 队列。mainline 执行完开始事件循环，第一阶段是 timers，这时候 timers 队列可能为空，也可能有回调；\n如果没有那么执行 check 队列的回调，下一轮循环在检查并执行 timers 队列的回调；\n如果有就先执行 timers 的回调，再执行 check 阶段的回调。因此这是 timers 的不确定性导致的。","processnexttick#process.nextTick":"process.nextTick 从技术上讲不是事件循环的一部分。 相反，无论事件循环的当前阶段如何，都将在当前操作完成之后处理 nextTickQueue","processnexttick-和-setimmediate-的区别#process.nextTick 和 setImmediate 的区别":"process.nextTick 在同一阶段立即触发\nsetImmediate fires on the following iteration or 'tick' of the event loop (在事件循环接下来的阶段迭代中执行 - check 阶段)。","nexttick-在事件循环中的位置#nextTick 在事件循环中的位置":"⌚️\n           ┌───────────────────────────┐\n        ┌─>│           timers          │\n        │  └─────────────┬─────────────┘\n        │           nextTickQueue\n        │  ┌─────────────┴─────────────┐\n        │  │     pending callbacks     │\n        │  └─────────────┬─────────────┘\n        │           nextTickQueue\n        │  ┌─────────────┴─────────────┐\n        |  |     idle, prepare         │\n        |  └─────────────┬─────────────┘\n  nextTickQueue     nextTickQueue\n        |  ┌─────────────┴─────────────┐\n        |  │           poll            │\n        │  └─────────────┬─────────────┘\n        │           nextTickQueue\n        │  ┌─────────────┴─────────────┐\n        │  │           check           │\n        │  └─────────────┬─────────────┘\n        │           nextTickQueue\n        │  ┌─────────────┴─────────────┐\n        └──┤       close callbacks     │\n           └───────────────────────────┘","microtasks-微任务#Microtasks 微任务":"在 Node 领域，微任务是来自以下对象的回调：\nprocess.nextTick()\nthen()\n在主线结束后以及事件循环的每个阶段之后，立即运行微任务回调。resolved 的 promise.then 回调像微处理一样执行，就像 process.nextTick 一样。 虽然，如果两者都在同一个微任务队列中，则将首先执行 process.nextTick 的回调。优先级 process.nextTick > promise.then","看代码输出顺序#看代码输出顺序":"async function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n}\nasync function async2() {\n  console.log(\"async2\");\n}\nconsole.log(\"script start\");\nsetTimeout(function () {\n  console.log(\"setTimeout0\");\n  setTimeout(function () {\n    console.log(\"setTimeout1\");\n  }, 0);\n  setImmediate(() => console.log(\"setImmediate\"));\n}, 0);\nprocess.nextTick(() => console.log(\"nextTick\"));\nasync1();\nnew Promise(function (resolve) {\n  console.log(\"promise1\");\n  resolve();\n  console.log(\"promise2\");\n}).then(function () {\n  console.log(\"promise3\");\n});\nconsole.log(\"script end\");\n我们先按运行主线一步一步往下走js运行主线\n遇到两个异步函数声明，async function, 还没有调用，所以不执行\n遇到console.log('script start')，执行\n遇到setTimeout，把回调任务塞入异步任务回调队列，等待\n遇到process.nextTick，塞入微任务回调队列\n执行async1, 执行 console.log('async1 start')\n遇到await async2, 执行 async2, 执行 console.log('async2')\nawait后面的代码相当于是promise.then，把其塞入微任务回调队列\nasync1 执行完后遇到了new Promise， 立即执行其中的代码，执行 console.log('promise1')\n遇到了resolve，立即当前函数体的下面代码，执行 console.log('promise2')\n遇到了promise.then, 把其塞入微任务回调队列\n执行 console.log('script end')， 此时主线运行完毕，即将进行下一轮事件循环\n回调队列\n检查微任务回调队列，如果有，则依次执行并清空微任务队列\n依次执行\nconsole.log('nextTick')\nconsole.log('async1 end')\nconsole.log('promise3')\n检查timmer回调，如果有，则依次执行并清空timmer回调任务队列 （setTimeout和setImmediate在同一任务时，先执行setImmediate）\n依次执行\nconsole.log('setTimeout0')\nconsole.log('setImmediate')\nconsole.log('setTimeout1');\n最终执行顺序为\n// js运行主线\nconsole.log('script start')\nconsole.log('async1 start')\nconsole.log('async2 start')\nconsole.log('promise1')\nconsole.log('promise2')\nconsole.log('script end')\n// 微任务回调\nconsole.log('nextTick')\nconsole.log('async1 end')\nconsole.log('promise3')\n// timmer回调\nconsole.log('setTimeout0')\nconsole.log('setImmediate')\nconsole.log('setTimeout1');"}},"/posts/nodejs/events":{"title":"Events","data":{"":"图：Nguyen Nhut","events#Events":"events模块是node的核心模块之一，几乎所有常用的node模块都继承了events模块，比如http、fs等。模块本身非常简单，API虽然也不少，但常用的就那么几个，这里举几个简单例子。","例子1单个事件监听器#例子1：单个事件监听器":"var EventEmitter = require('events');\nclass Man extends EventEmitter {}\nvar man = new Man();\nman.on('wakeup', function(){\n    console.log('man has woken up');\n});\nman.emit('wakeup');\n// 输出如下：\n// man has woken up","例子2同个事件多个事件监听器#例子2：同个事件，多个事件监听器":"可以看到，事件触发时，事件监听器按照注册的顺序执行。\nvar EventEmitter = require('events');\nclass Man extends EventEmitter {}\nvar man = new Man();\nman.on('wakeup', function(){\n    console.log('man has woken up');\n});\nman.on('wakeup', function(){\n    console.log('man has woken up again');\n});\nman.emit('wakeup');\n// 输出如下：\n// man has woken up\n// man has woken up again","例子3只运行一次的事件监听器#例子3：只运行一次的事件监听器":"var EventEmitter = require('events');\nclass Man extends EventEmitter {}\nvar man = new Man();\nman.on('wakeup', function(){\n    console.log('man has woken up');\n});\nman.once('wakeup', function(){\n    console.log('man has woken up again');\n});\nman.emit('wakeup');\nman.emit('wakeup');\n// 输出如下：\n// man has woken up\n// man has woken up again\n// man has woken up","例子4注册事件监听器前事件先触发#例子4：注册事件监听器前，事件先触发":"可以看到，注册事件监听器前，事件先触发，则该事件会直接被忽略。\nvar EventEmitter = require('events');\nclass Man extends EventEmitter {}\nvar man = new Man();\nman.emit('wakeup', 1);\nman.on('wakeup', function(index){\n    console.log('man has woken up ->' + index);\n});\nman.emit('wakeup', 2);\n// 输出如下：\n// man has woken up ->2","例子5异步执行还是顺序执行#例子5：异步执行，还是顺序执行":"例子很简单，但非常重要。究竟是代码1先执行，还是代码2先执行，这点差异，无论对于我们理解别人的代码，还是自己编写node程序，都非常关键。实践证明，代码1先执行了\nvar EventEmitter = require('events');\nclass Man extends EventEmitter {}\nvar man = new Man();\nman.on('wakeup', function(){\n    console.log('man has woken up'); // 代码1\n});\nman.emit('wakeup');\nconsole.log('woman has woken up');  // 代码2\n// 输出如下：\n// man has woken up\n// woman has woken up","例子6移除事件监听器#例子6：移除事件监听器":"var EventEmitter = require('events');\nfunction wakeup(){\n    console.log('man has woken up');\n}\nclass Man extends EventEmitter {}\nvar man = new Man();\nman.on('wakeup', wakeup);\nman.emit('wakeup');\nman.removeListener('wakeup', wakeup);\nman.emit('wakeup');\n// 输出如下：\n// man has woken up","手写eventemitter事件巴士#手写EventEmitter事件巴士":""}},"/posts/nodejs/global":{"title":"NodeJS全局对象","data":{"":"图：Nguyen Nhut","全局对象解析#全局对象解析":"JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。","全局对象和全局变量#全局对象和全局变量":"global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：在最外层定义的变量；\n全局对象的属性；\n隐式定义的变量（未定义直接赋值的变量）。\n当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。","__filename#__filename":"__filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。\nconsole.log( __filename );","__dirname#__dirname":"__dirname 表示当前执行脚本所在的目录。\nconsole.log( __dirname );","settimeoutcb-ms#setTimeout(cb, ms)":"setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。返回一个代表定时器的句柄值。\nfunction printHello(){\n   console.log( \"Hello, World!\");\n}\n// 两秒后执行以上函数\nsetTimeout(printHello, 2000);","cleartimeout#clearTimeout":"","setinterval#setInterval":"","clearinterval#clearInterval":"","console#console":"","process#process":"process 是一个全局变量，即 global 对象的属性。它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。\nexit\n当进程准备退出时触发。\nbeforeExit\n当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。\nuncaughtException\n当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。\nSignal 事件\n当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。\nprocess.on('exit', function(code) {\n  // 以下代码永远不会执行\n  setTimeout(function() {\n    console.log(\"该代码不会执行\");\n  }, 0);\n   \n  console.log('退出码为:', code);\n});\nconsole.log(\"程序执行结束\");","退出的状态码#退出的状态码":"Uncaught Fatal Exception\n有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。\n3\tInternal JavaScript Parse Error\nJavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。4\tInternal JavaScript Evaluation Failure\nJavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。5\tFatal Error\nV8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR6\tNon-function Internal Exception Handler\n未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。7\tInternal Exception Handler Run-Time Failure\n未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。9\tInvalid Argument\n可能是给了未知的参数，或者给的参数没有值。10\tInternal JavaScript Run-Time Failure\nJavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。12\tInvalid Debug Argument\n设置了参数–debug 和/或 –debug-brk，但是选择了错误端口。\n128\tSignal Exits\n如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。\n// 输出到终端\nprocess.stdout.write(\"Hello World!\" + \"\\n\");\n \n// 通过参数读取\nprocess.argv.forEach(function(val, index, array) {\n   console.log(index + ': ' + val);\n});\n \n// 获取执行路局\nconsole.log(process.execPath);\n \n// 平台信息\nconsole.log(process.platform);","看看这段代码输出什么#看看这段代码输出什么":"// this in NodeJS global scope is the current module.exports object, not the global object.\nconsole.log(this);    // {}\nmodule.exports.foo = 5;\nconsole.log(this);   // { foo:5 }"}},"/posts/nodejs/httpserver":{"title":"如何使用NodeJs创建HTTP服务？","data":{"":"图：Nguyen Nhut","如何使用nodejs创建http服务#如何使用NodeJs创建HTTP服务？":"http-server.js\nconst http = require('http')\nhttp.createServer(function (req, res) {\n    res.writeHead(200, {\n        'Content-Type': 'text/plain'\n    })\n    res.end('Hello World')\n}).listen(80, '127.0.0.1')\nconsole.log('Server running at http://127.0.0.1:80/')\n浏览器访问\nhttp://127.0.0.1:80/\n用curl访问\ncurl -v http://127.0.0.1:80看一下请求报文\n// 三次握手\n* Rebuilt URL to: http://127.0.0.1:80/\n*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to 127.0.0.1 (127.0.0.1) port 80 (#0)\n// 客户端向服务端发送请求报文\n> GET / HTTP/1.1\n> Host: 127.0.0.1:80\n> User-Agent: curl/7.54.0\n> Accept: */*\n>\n// 服务端响应客户端内容\n< HTTP/1.1 200 OK\n< Content-Type: text/plain\n< Date: Wed, 04 Aug 2021 15:55:55 GMT\n< Connection: keep-alive\n< Keep-Alive: timeout=5\n< Transfer-Encoding: chunked\n<\n* Connection #0 to host 127.0.0.1 left intact\nHello World%\nhtttp-client.js\nconst http = require('http')\nconst options = {\n    hostname: '127.0.0.1',\n    port: 80,\n    path: '/',\n    method: 'GET'\n}\nconst req = http.request(options, (res) => {\n    console.log(`Status=${res.statusCode}, Headers=${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8')\n    res.on('data', (data) => {\n        console.log(data)\n    })\n})\nreq.end()"}},"/posts/nodejs/puppeteer":{"title":"puppeteer应用","data":{"":"图：Amrit Pal Singh","介绍#介绍":"Puppeteer 是一个 Node 库，它提供了一个高级 API 来通过DevTools 协议控制 Chrome 或 Chromium 。Puppeteer 默认运行无头，但可以配置为运行完整（非无头）Chrome 或 Chromium。一般用于：生成页面的屏幕截图和 PDF。抓取 SPA（单页应用程序）并生成预渲染内容（即“SSR”（服务器端渲染））。自动化表单提交、UI 测试、键盘输入等。创建最新的自动化测试环境。使用最新的 JavaScript 和浏览器功能直接在最新版本的 Chrome 中运行测试。捕获您网站的时间线轨迹以帮助诊断性能问题。测试 Chrome 扩展程序。","安装#安装":"npm i puppeteer","截图#截图":"// 截图\nconst screenShot = async () => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.goto('https://example.com');\n  const a = await page.screenshot({ path: 'example.png' });\n  await browser.close();\n}","执行scripts#执行scripts":"// 执行脚本\nconst doScript = async () => {\n  await page.goto('https://www.all1024.com', {\n    waitUntil: 'networkidle2',\n  });\n  await page.pdf({ path: '1024.pdf', format: 'a4' });\n  const dimensions = await page.evaluate(() => {\n    return {\n      width: document.documentElement.clientWidth,\n      height: document.documentElement.clientHeight,\n      deviceScaleFactor: window.devicePixelRatio,\n    };\n  });\n  console.log('Dimensions:', dimensions);\n}","自动填表单#自动填表单":"// 自动填表单\nconst fillForm = async () => {\n  const browser = await puppeteer.launch();\n  // 调试可见\n  // const browser = await puppeteer.launch({\n  //   headless: false,\n  //   executablePath: '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',\n  //   args: ['--start-maximized']\n  //   //launch这里将浏览器设置为非无头模式，且这里设置启动本机安装的chrome，如果这里不设置，还需要下载chromium，这里请设置你自己本机的chrome浏览器\n  // });\n  const page = await browser.newPage();\n  // 地址栏输入网页地址\n  await page.goto('https://baidu.com/', {\n    waitUntil: 'networkidle2',\n  });\n  // 输入搜索关键字\n  await page.type('#kw', '腾讯公司', {\n    delay: 1000, // 控制 keypress 也就是每个字母输入的间隔\n  });\n  // 回车\n  await page.keyboard.press('Enter');\n}","repl交互式解释器#REPL(交互式解释器)":"调试puppeteer应用程式有两种方法，一种是打开可见的带头的浏览器，观察真实效果，另一种是单步调试，通过交互式解释器来实现。使用交互式 REPL 使快速 puppeteer 调试和探索变得有趣。可以随时中断您的代码以在您的控制台中启动交互式REPL 。向和实例添加便利.repl()方法。PageBrowser支持检查任意对象和实例。可用对象属性的功能选项卡自动完成和彩色提示。\nconst puppeteer = require('puppeteer-extra');\nconst repl = require('puppeteer-extra-plugin-repl')();\nasync function showREPL() {\n  await puppeteer.use(repl);\n  //固定写法，表示puppeteer要使用repl插件\n  const browser = await puppeteer.launch({\n    headless: false,\n    executablePath: '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',\n    args: ['--start-maximized']\n    //launch这里将浏览器设置为非无头模式，且这里设置启动本机安装的chrome，如果这里不设置，还需要下载chromium，这里请设置你自己本机的chrome浏览器\n  });\n  const page = await browser.newPage();\n  await page.setViewport({\n    width: 1366,\n    height: 768\n  });\n  await page.goto('https://example.com');\n  //默认打开上面的网页\n  await page.repl();\n  //在page对象上开启交互的REPL，这样可以实时看到page上提供的方法执行结果，执行效果见下图所示\n  //在page对象上开启交互的REPL，这样可以实时看到page上提供的方法执行结果\n  await browser.repl();\n  //在browser对象上开启交互的REPL，这样可以实时看到page上提供的方法执行结果\n  await browser.close();\n}\nshowREPL();","应用#应用":"最近公司会用到邮件发送报表的功能，来实现一个服务端生成网页png/pdf的功能吧","暴露接口供其他服务调用#暴露接口，供其他服务调用":"const express = require(\"express\");\nconst getPDF = require('./getPDF');\nconst getPNG = require('./getPNG');\nconst app = express();\nconst port = 9000;\napp.get(\"/getPDF\", async (req, res) => {\n  const { url } = req.query;\n  if (!url) { res.send({ status: 'error', msg: '缺少参数url' }) }\n  const result = await getPDF({ url });\n  res.send(result);\n});\napp.get(\"/getPNG\", async (req, res) => {\n  const { url, width: _width } = req.query;\n  if (!url) { res.send({ status: 'error', msg: '缺少参数url' }) }\n  const width = _width ? 1000 : Number(_width);\n  const result = await getPNG({ url, width });\n  res.send(result);\n});\napp.listen(port, () => {\n  console.log(`Example app listening at http://localhost:${port}`);\n});","getpng实现#getPNG实现":"const puppeteer = require('puppeteer');\nconst UTILS = require('./utils');\nmodule.exports = async ({ url, name = 'file.png', width = 1366 }) => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.setViewport({\n    width,\n    height: 768\n  });\n  await page.goto(url, {\n    waitUtil: 'networkidle2'\n  });\n  await UTILS.waitTillHTMLRendered(page);\n  console.log('开始截图……')\n  const res = await page.screenshot({ path: name, fullPage: true });\n  console.log('完成截图')\n  await browser.close();\n  return res\n}","getpdf实现#getPDF实现":"const puppeteer = require('puppeteer');\nmodule.exports = async function getPDF({ url }) {\n  const browser = await puppeteer.launch({\n    headless: true,\n    args: [\n      \"--no-sandbox\", // linux系统中必须开启\n      \"--no-zygote\",\n      // \"--single-process\", // 此处关掉单进程\n      \"--disable-setuid-sandbox\",\n      \"--disable-gpu\",\n      \"--disable-dev-shm-usage\",\n      \"--no-first-run\",\n      \"--disable-extensions\",\n      \"--disable-file-system\",\n      \"--disable-background-networking\",\n      \"--disable-default-apps\",\n      \"--disable-sync\", // 禁止同步\n      \"--disable-translate\",\n      \"--hide-scrollbars\",\n      \"--metrics-recording-only\",\n      \"--mute-audio\",\n      \"--safebrowsing-disable-auto-update\",\n      \"--ignore-certificate-errors\",\n      \"--ignore-ssl-errors\",\n      \"--ignore-certificate-errors-spki-list\",\n      \"--font-render-hinting=medium\",\n    ]\n  });\n  // try...catch...\n  try {\n    const page = await browser.newPage();\n    await page.goto(url, {\n      waitUtil: 'networkidle2'\n    });\n    // 页眉模板（图片使用base64，此处的src的base64为占位值）\n    const headerTemplate = ``\n    // 页脚模板（pageNumber处会自动注入当前页码）\n    const footerTemplate = ``;\n    // 对于大的PDF生成，可能会时间很久，这里规定不会进行超时处理\n    await page.setDefaultNavigationTimeout(0);\n    // 定义html内容\n    // await page.setContent(this.HTMLStr, { waitUntil: \"networkidle2\" });\n    // 等待字体加载响应\n    await page.evaluateHandle(\"document.fonts.ready\");\n    let pdfbuf = await page.pdf({\n      // 页面缩放比例\n      scale: 1,\n      // 是否展示页眉页脚\n      // displayHeaderFooter: true,\n      // pdf存储单页大小\n      format: \"a4\",\n      // 页面的边距\n      // 页眉的模板\n      // headerTemplate,\n      // // 页脚的模板\n      // footerTemplate,\n      margin: {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0\n      },\n      // 输出的页码范围\n      pageRanges: \"\",\n      // CSS\n      preferCSSPageSize: true,\n      // 开启渲染背景色，因为 puppeteer 是基于 chrome 浏览器的，浏览器为了打印节省油墨，默认是不导出背景图及背景色的\n      // 坑点，必须加\n      printBackground: true,\n    });\n    // 关闭browser\n    await browser.close();\n    // 返回的是buffer不需要存储为pdf，直接将buffer传回前端进行下载，提高处理速度\n    return pdfbuf\n  } catch (e) {\n    await browser.close();\n    throw e\n  }\n}","判断页面加载完成工具函数#判断页面加载完成工具函数":"如何判断页面渲染完成其实不能单单从网络或者document load来判断，因为应用里js一般都会是动态加载其他js来动态渲染，所以，用定时轮询页面大小变化来判断页面是否加载完毕比较合适。\n// 判断页面加载完成\nconst waitTillHTMLRendered = async (page, timeout = 10000) => {\n  console.log('页面加载中...')\n  const checkDurationMsecs = 1000;\n  const maxChecks = timeout / checkDurationMsecs;\n  let lastHTMLSize = 0;\n  let checkCounts = 1;\n  let countStableSizeIterations = 0;\n  const minStableSizeIterations = 3;\n  while (checkCounts++ <= maxChecks) {\n    let html = await page.content();\n    let currentHTMLSize = html.length;\n    let bodyHTMLSize = await page.evaluate(() => document.body.innerHTML.length);\n    console.log('last: ', lastHTMLSize, ' <> curr: ', currentHTMLSize, \" body html size: \", bodyHTMLSize);\n    if (lastHTMLSize != 0 && currentHTMLSize == lastHTMLSize)\n      countStableSizeIterations++;\n    else\n      countStableSizeIterations = 0; //reset the counter\n    if (countStableSizeIterations >= minStableSizeIterations) {\n      console.log(\"页面完成加载!\");\n      checkCounts = maxChecks + 2\n      break;\n    }\n    lastHTMLSize = currentHTMLSize;\n    await page.waitForTimeout(checkDurationMsecs);\n  }\n};\nmodule.exports = {\n  waitTillHTMLRendered\n}\n至此，就实现了一个非常常见的需求，生成的png或者pdf就可以用于其他服务来发报表邮件了。"}},"/posts/nodejs/stream":{"title":"Stream","data":{"":"图：Nguyen Nhut","stream#Stream":"在构建较复杂的系统时，通常将其拆解为功能独立的若干部分。这些部分的接口遵循一定的规范，通过某种方式相连，以共同完成较复杂的任务。譬如，shell通过管道|连接各部分，其输入输出的规范是文本流。在Node.js中，内置的Stream模块也实现了类似功能，各部分通过.pipe()连接。Stream提供了以下四种类型的流：\nvar Stream = require('stream')\nvar Readable = Stream.Readable\nvar Writable = Stream.Writable\nvar Duplex = Stream.Duplex\nvar Transform = Stream.Transform\n使用Stream可实现数据的流式处理，如：\nvar fs = require('fs')\n// `fs.createReadStream`创建一个`Readable`对象以读取`bigFile`的内容，并输出到标准输出\n// 如果使用`fs.readFile`则可能由于文件过大而失败\nfs.createReadStream(bigFile).pipe(process.stdout)","readable#Readable":"创建可读流。实例：流式消耗迭代器中的数据。\n'use strict'\nconst Readable = require('stream').Readable\nclass ToReadable extends Readable {\n  constructor(iterator) {\n    super()\n    this.iterator = iterator\n  }\n  // 子类需要实现该方法\n  // 这是生产数据的逻辑\n  _read() {\n    const res = this.iterator.next()\n    if (res.done) {\n      // 数据源已枯竭，调用`push(null)`通知流\n      return this.push(null)\n    }\n    setTimeout(() => {\n      // 通过`push`方法将数据添加到流中\n      this.push(res.value + '\\n')\n    }, 0)\n  }\n}\nmodule.exports = ToReadable\n实际使用时，new ToReadable(iterator)会返回一个可读流，下游可以流式的消耗迭代器中的数据。\nconst iterator = function (limit) {\n  return {\n    next: function () {\n      if (limit--) {\n        return { done: false, value: limit + Math.random() }\n      }\n      return { done: true }\n    }\n  }\n}(1e10)\nconst readable = new ToReadable(iterator)\n// 监听`data`事件，一次获取一个数据\nreadable.on('data', data => process.stdout.write(data))\n// 所有数据均已读完\nreadable.on('end', () => process.stdout.write('DONE'))\n执行上述代码，将会有100亿个随机数源源不断地写进标准输出流。创建可读流时，需要继承Readable，并实现_read方法。\n_read方法是从底层系统读取具体数据的逻辑，即生产数据的逻辑。\n在_read方法中，通过调用push(data)将数据放入可读流中供下游消耗。\n在_read方法中，可以同步调用push(data)，也可以异步调用。\n当全部数据都生产出来后，必须调用push(null)来结束可读流。\n流一旦结束，便不能再调用push(data)添加数据。\n可以通过监听data事件的方式消耗可读流。\n在首次监听其data事件后，readable便会持续不断地调用_read()，通过触发data事件将数据输出。\n第一次data事件会在下一个tick中触发，所以，可以安全地将数据输出前的逻辑放在事件监听后（同一个tick中）。\n当数据全部被消耗时，会触发end事件。\n上面的例子中，process.stdout代表标准输出流，实际是一个可写流。下小节中介绍可写流的用法。","writable#Writable":"创建可写流。前面通过继承的方式去创建一类可读流，这种方法也适用于创建一类可写流，只是需要实现的是_write(data, enc, next)方法，而不是_read()方法。有些简单的情况下不需要创建一类流，而只是一个流对象，可以用如下方式去做：\nconst Writable = require('stream').Writable\nconst writable = Writable()\n// 实现`_write`方法\n// 这是将数据写入底层的逻辑\nwritable._write = function (data, enc, next) {\n  // 将流中的数据写入底层\n  process.stdout.write(data.toString().toUpperCase())\n  // 写入完成时，调用`next()`方法通知流传入下一个数据\n  process.nextTick(next)\n}\n// 所有数据均已写入底层\nwritable.on('finish', () => process.stdout.write('DONE'))\n// 将一个数据写入流中\nwritable.write('a' + '\\n')\nwritable.write('b' + '\\n')\nwritable.write('c' + '\\n')\n// 再无数据写入流时，需要调用`end`方法\nwritable.end()\n上游通过调用writable.write(data)将数据写入可写流中。write()方法会调用_write()将data写入底层。\n在_write中，当数据成功写入底层后，必须调用next(err)告诉流开始处理下一个数据。\nnext的调用既可以是同步的，也可以是异步的。\n上游必须调用writable.end(data)来结束可写流，data是可选的。此后，不能再调用write新增数据。\n在end方法调用后，当所有底层的写操作均完成时，会触发finish事件。","duplex#Duplex":"创建可读可写流。Duplex实际上就是继承了Readable和Writable的一类流。 所以，一个Duplex对象既可当成可读流来使用（需要实现_read方法），也可当成可写流来使用（需要实现_write方法）。\nvar Duplex = require('stream').Duplex\nvar duplex = Duplex()\n// 可读端底层读取逻辑\nduplex._read = function () {\n  this._readNum = this._readNum || 0\n  if (this._readNum > 1) {\n    this.push(null)\n  } else {\n    this.push('' + (this._readNum++))\n  }\n}\n// 可写端底层写逻辑\nduplex._write = function (buf, enc, next) {\n  // a, b\n  process.stdout.write('_write ' + buf.toString() + '\\n')\n  next()\n}\n// 0, 1\nduplex.on('data', data => console.log('ondata', data.toString()))\nduplex.write('a')\nduplex.write('b')\nduplex.write('x')\nduplex.end()\n上面的代码中实现了_read方法，所以可以监听data事件来消耗Duplex产生的数据。 同时，又实现了_write方法，可作为下游去消耗数据。因为它既可读又可写，所以称它有两端：可写端和可读端。 可写端的接口与Writable一致，作为下游来使用；可读端的接口与Readable一致，作为上游来使用。","transform#Transform":"在上面的例子中，可读流中的数据（0, 1）与可写流中的数据（’a’, ‘b’）是隔离开的，但在Transform中可写端写入的数据经变换后会自动添加到可读端。 Tranform继承自Duplex，并已经实现了_read和_write方法，同时要求用户实现一个_transform方法。\n'use strict'\nconst Transform = require('stream').Transform\nclass Rotate extends Transform {\n  constructor(n) {\n    super()\n    // 将字母移动`n`个位置\n    this.offset = (n || 13) % 26\n  }\n  // 将可写端写入的数据变换后添加到可读端\n  _transform(buf, enc, next) {\n    var res = buf.toString().split('').map(c => {\n      var code = c.charCodeAt(0)\n      if (c >= 'a' && c <= 'z') {\n        code += this.offset\n        if (code > 'z'.charCodeAt(0)) {\n          code -= 26\n        }\n      } else if (c >= 'A' && c <= 'Z') {\n        code += this.offset\n        if (code > 'Z'.charCodeAt(0)) {\n          code -= 26\n        }\n      }\n      return String.fromCharCode(code)\n    }).join('')\n    // 调用push方法将变换后的数据添加到可读端\n    this.push(res)\n    // 调用next方法准备处理下一个\n    next()\n  }\n}\nvar transform = new Rotate(3)\ntransform.on('data', data => process.stdout.write(data))\ntransform.write('hello, ')\ntransform.write('world!')\ntransform.end()","数据类型#数据类型":"前面几节的例子中，经常看到调用data.toString()。这个toString()的调用是必需的吗？在shell中，用管道（|）连接上下游。上游输出的是文本流（标准输出流），下游输入的也是文本流（标准输入流）对于可读流来说，push(data)时，data只能是String或Buffer类型，而消耗时data事件输出的数据都是Buffer类型。对于可写流来说，write(data)时，data只能是String或Buffer类型，_write(data)调用时传进来的data都是Buffer类型。也就是说，流中的数据默认情况下都是Buffer类型。产生的数据一放入流中，便转成Buffer被消耗；写入的数据在传给底层写逻辑时，也被转成Buffer类型。但每个构造函数都接收一个配置对象，有一个objectMode的选项，一旦设置为true，就能出现“种瓜得瓜，种豆得豆”的效果。\nReadable未设置objectMode时：\nconst Readable = require('stream').Readable\nconst readable = Readable()\nreadable.push('a')\nreadable.push('b')\nreadable.push(null)\nreadable.on('data', data => console.log(data))\nReadable设置objectMode后：\nconst Readable = require('stream').Readable\nconst readable = Readable({ objectMode: true })\nreadable.push('a')\nreadable.push('b')\nreadable.push({})\nreadable.push(null)\nreadable.on('data', data => console.log(data))\n可见，设置objectMode后，push(data)的数据被原样地输出了。此时，可以生产任意类型的数据。"}},"/posts/other/alog":{"title":"常见算法","data":{"":"图：Nguyen Nhut","有效的括号#有效的括号":"给定一个只包括 '('，')'，''，'['，']' 的字符串 s ，判断字符串是否有效。\nconst isValid = function (s) {\n  if (s.length % 2 === 1) {\n    return false;\n  }\n  const regObj = {\n    \"{\": \"}\",\n    \"(\": \")\",\n    \"[\": \"]\",\n  };\n  let stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"{\" || s[i] === \"(\" || s[i] === \"[\") {\n      stack.push(s[i]);\n    } else {\n      const cur = stack.pop();\n      if (s[i] !== regObj[cur]) {\n        return false;\n      }\n    }\n  }\n  if (stack.length) {\n    return false;\n  }\n  return true;\n};","公共前缀#公共前缀":"编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 \"\"。示例 1：输入：strs = [\"flower\",\"flow\",\"flight\"]\n输出：\"fl\"示例 2：输入：strs = [\"dog\",\"racecar\",\"car\"]\n输出：\"\"\n解释：输入不存在公共前缀。\nconst longestCommonPrefix = function (strs) {\n  const str = strs[0];\n  let index = 0;\n  while (index < str.length) {\n    const strCur = str.slice(0, index + 1);\n    for (let i = 0; i < strs.length; i++) {\n      if (!strs[i] || !strs[i].startsWith(strCur)) {\n        return str.slice(0, index);\n      }\n    }\n    index++;\n  }\n  return str;\n};","无重复子串#无重复子串":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。示例 1:输入: s = \"abcabcbb\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。示例 2:输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。示例 3:输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。示例 4:输入: s = \"\"\n输出: 0\nconst lengthOfLongestSubstring = function (s) {\n  if (s.length === 0) {\n    return 0;\n  }\n  let left = 0;\n  let right = 1;\n  let max = 0;\n  while (right <= s.length) {\n    let lr = s.slice(left, right);\n    const index = lr.indexOf(s[right]);\n    if (index > -1) {\n      left = index + left + 1;\n    } else {\n      lr = s.slice(left, right + 1);\n      max = Math.max(max, lr.length);\n    }\n    right++;\n  }\n  return max;\n};","在制定数据源里面生成一个长度为-n-的不重复随机数组#在制定数据源里面生成一个长度为 n 的不重复随机数组":"function getTenNum(testArray, n) {\n  const cloneArr = [...testArray];\n  let result = [];\n  for (let i = 0; i < n; ++i) {\n    const random = Math.floor(Math.random() * cloneArr.length);\n    const cur = cloneArr[random];\n    result.push(cur);\n    cloneArr.splice(random, 1);\n  }\n  return result;\n}\nconst testArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];\nconst resArr = getTenNum(testArray, 14);","全排列#全排列":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nconst permute = nums => {\n    if (!nums) return [];\n    const res = [];\n    // path是组合的数组\n    const backtrack = path => {\n        if (path.length === nums.length) {\n            // 长度满足条件，推入res数组\n            res.push(path);\n            return;\n        }\n        nums.forEach(n => {\n            // path中已经有n，放弃此轮\n            if (path.includes(n)) return;\n            // 将n加入path继续找\n            backtrack([...path, n]);\n        });\n    };\n    // 从空数组开始\n    backtrack([]);\n    return res;\n};","判断是否环形链表#判断是否环形链表":"const hasCycle = function(head) {\n  if(head === null || head.next === null) {\n    return false;\n  }\n  let slow = head;\n  let fast = head.next;\n  while (slow) {\n    if(slow === fast) {\n      return true\n    }\n    slow = slow?.next || null;\n    fast = fast?.next?.next || null;\n  }\n  return false;\n};","区间调度#区间调度":"// 有许多[start, end]的闭区间, 请设计一个算法, 算出这些区间中, 最多有几个互不相交的区间。\n// 比如intvs = [[1,3], [2,4], [3,6]]\n// 这些区间最多有两个区间互不相交, 即 [1,3], [3,6], intervalSchedule函数此时应该返回2\nfunction intervalSchedule(intvs) {\n    if (intvs.length === 0) {\n        return 0;\n    }\n    const sortArray = intvs.sort((a, b) => a[1] - b[1]);\n    let count = 1; // 最少有一个区间不相交\n    let xEnd = sortArray[0][1];\n    for (let item of intvs) {\n        const start = item[0];\n        // 这里是> 或者 >=取决于, [1,3][3,6], 3算不算相交\n        if (start >= xEnd) {\n            count++;\n            xEnd = item[1];\n        }\n    }\n    return count;\n}\nconsole.log(intervalSchedule([\n    [1, 3],\n    [2, 4],\n    [3, 6]\n]))"}},"/posts/other/blender-shortcut":{"title":"Blender常用快捷键","data":{"":"图：M Wildan Cahya Syarief","快捷键#快捷键":"名称\t快捷键\t倒角\tctrl+b\t挤出\tctrl + e\t游标回到原点\tshift+c\t分段\tctrl+r\t辅助线\tb\t画笔\td\t拆分顶点\tv\t复制\tshift+d\t内插面\ti\t切换渲染\tz","技巧#技巧":"目的\t命令\t变平滑\t平滑着色、平直着色\t桥接\t桥接循环边\t分离\t分开选中项"}},"/posts/other/brew":{"title":"brew安装","data":{"":"图：Mako Tsereteli\nbrew 是 MacOS 上的包管理工具，可以简化 macOS 和 Linux 操作系统上软件的安装。","确认安装-ruby#确认安装 ruby":"brew 是 ruby 开发的，需要确认 ruby 是否已安装，默认是已经安装的。\n$ which ruby\n$ ruby --version","安装#安装":"执行命令:\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n目前此命令可用，按提示选择下载源，我选的清华下载源\n/bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\"","确认#确认":"brew --version\n测试是否已安装成功\nwhich brew\n安装成功则显示路径"}},"/posts/other/brewtree":{"title":"Mac使用tree生成目录结构","data":{"":"图：Nguyen Nhut","前言#前言":"程序员经常会有需求，需要列出项目的结构树。Mac或者Linux下可以使用tree列出项目结构，如下图这种：\n├── build\n├── config\n├── docs\n│   └── static\n│       ├── css\n│       └── js\n├── src\n│   ├── assets\n│   ├── components\n│   ├── store\n│   │   └── modules\n│   └── views\n│       ├── book\n│       └── movie\n└── static\nMac下可以使用brew install tree进行安装。安装后，在terminal中输入tree -a便可以查看某个文件夹下的所有文件。","常用的命令#常用的命令":"当然了，我们的需求肯定不止列出所有文件这么简单。下面介绍几个常用的命令\ntree -d 只显示文件夹；\ntree -L n 显示项目的层级。n表示层级数。比如想要显示项目三层结构，可以用tree -l 3；\ntree -I pattern 用于过滤不想要显示的文件或者文件夹。比如你想要过滤项目中的node_modules文件夹，可以使用tree -I \"node_modules\"；\ntree > tree.md 将项目结构输出到tree.md这个文件。\n举个例子，如果我们要显示某个项目下3层的所有文件结构，同时又过滤node_modules文件夹，最后输出到tree.md，可以这么写\ntree -L 3 -I \"node_modules\"\n更多命令的使用可以查看tree --help"}},"/posts/other/cache":{"title":"前端缓存","data":{"":"图：Vivivian","缓存好处#缓存好处":"缓解服务器压力，不用每次都去请求数据\n提升性能，打开本地资源肯定比服务器快\n减少带宽消耗","缓存种类#缓存种类":"类型\t描述\t数据库缓存\t当 web 应用关系复杂，数据表往上增长时，可以将查询后的数据放到内存中进行缓存，下次再查询时，就直接从内存中获取，从而提高响应速度\tCDN 缓存\t当我们发送一个 web 请求时，CDN 会帮我们计算去哪得到这些内容的路径短且快，这个是从网站管理员部署的，所以他们也可以将大家经常访问的内容放在 CDN 里，从而加快响应\t代理服务器缓存\t代理服务器缓存，根浏览器缓存性质类似，但是代理服务器缓存面向的群体更广，规模更大，它不只是一个用户服务，一般为大量用户提供服务，同一个副本会被重用多次，因此在减少响应时间方面很有效\t浏览器缓存\t每个浏览器都实现了 HTTP 缓存，我们通过浏览器使用 HTTP 协议与服务器交互的时候，浏览器就会根据一套与服务器约定的规则进行缓冲工作，当我们在浏览器中点击前进和后退时，利用的就是浏览器的缓存机制\t\n所谓浏览器缓存其实就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。浏览器缓存过程： 强缓存，协商缓存。浏览器缓存位置一般分为四类： Service Worker-->Memory Cache-->Disk Cache-->Push Cache。","强缓存#强缓存":"强缓存是当我们访问 URL 的时候，不会向服务器发送请求，直接从缓存中读取资源，但是会返回 200 的状态码。","如何设置强缓存#如何设置强缓存？":"我们第一次进入页面，请求服务器，然后服务器进行应答，浏览器会根据 response Header 来判断是否对资源进行缓存，如果响应头中 expires、pragma 或者 cache-control 字段，代表这是强缓存，浏览器就会把资源缓存在 memory cache 或 disk cache 中。第二次请求时，浏览器判断请求参数，如果符合强缓存条件就直接返回状态码 200，从本地缓存中拿数据。否则把响应参数存在 request header 请求头中，看是否符合协商缓存，符合则返回状态码 304，不符合则服务器会返回全新资源。","expires#expires":"是 HTTP1.0 控制网页缓存的字段，值为一个时间戳，准确来讲是格林尼治时间，服务器返回该请求结果缓存的到期时间，意思是，再次发送请求时，如果未超过过期时间，直接使用该缓存，如果过期了则重新请求。\n有个缺点，就是它判断是否过期是用本地时间来判断的，本地时间是可以自己修改的。","cache-control#Cache-Control":"是 HTTP1.1 中控制网页缓存的字段，当 Cache-Control 都存在时，Cache-Control 优先级更高，主要取值为：\npublic：资源客户端和服务器都可以缓存。\nprivite：资源只有客户端可以缓存。\nno-cache：客户端缓存资源，但是是否缓存需要经过协商缓存来验证。\nno-store：不使用缓存。\nmax-age：缓存保质期。Cache-Control 使用了 max-age 相对时间，解决了 expires 的问题。","缓存位置#缓存位置":"上面我们说，强缓存我们会把资源房放到 memory cache 和 disk cache 中，那什么资源放在 memory cache，什么资源放在 disk cache 中？存存储图像和网页等资源主要缓存在 disk cache，操作系统缓存文件等资源大部分都会缓存在 memory cache 中。具体操作浏览器自动分配，看谁的资源利用率不高就分给谁。查找浏览器缓存时会按顺序查找: Service Worker-->Memory Cache-->Disk Cache-->Push Cache。","service-worker#Service Worker":"是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。","memory-cache#Memory Cache":"内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。","disk-cache#Disk Cache":"存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。\n在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。\nmemory cache 要比 disk cache 快的多。举个例子：从远程 web 服务器直接提取访问文件可能需要 500 毫秒(半秒)，那么磁盘访问可能需要 10-20 毫秒，而内存访问只需要 100 纳秒，更高级的还有 L1 缓存访问(最快和最小的 CPU 缓存)只需要 0.5 纳秒。","协商缓存#协商缓存":"协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程。主要有以下两种情况：协商缓存生效，返回 304协商缓存失效，返回 200 和请求结果如何设置协商缓存？","last-modified--if-modified-since#Last-Modified / If-Modified-Since":"Last-Modified 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。If-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。","etag--if-none-match#Etag / If-None-Match":"Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。If-None-Match 是客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为 200。\nEtag / If-None-Match 优先级高于 Last-Modified / If-Modified-Since，同时存在则只有 Etag / If-None-Match 生效。","缓存方案#缓存方案":"目前的项目大多使用这种缓存方案的：HTML: 协商缓存；css、js、图片：强缓存，文件名带上 hash。","强缓存与协商缓存的区别#强缓存与协商缓存的区别":"强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。\n大部分 web 服务器都默认开启协商缓存。","刷新对于强缓存和协商缓存的影响#刷新对于强缓存和协商缓存的影响":"当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。\n当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存。\n浏览器地址栏中写入 URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）"}},"/posts/other/docker":{"title":"Docker 常用命令","data":{"":"图：network","docker#Docker":"Docker 是一个应用打包、分发、部署的工具,你也可以把它理解为一个轻量的虚拟机是运行环境和应用的集合","编写-dockerfile#编写 dockerfile":"FROM node:16\nLABEL maintainer=\"favori\"\n# 复制代码\nADD . /app\n# 设置容器启动后的默认运行目录\nWORKDIR /app\n# 运行命令，安装依赖\n# RUN 命令可以有多个，但是可以用 && 连接多个命令来减少层级。\n# 例如 RUN npm install && cd /app && mkdir logs\nRUN npm install\n# CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。\n# 如果还需要运行其他命令可以用 && 连接，也可以写成一个shell脚本去执行。\n# 例如 CMD cd /app && ./start.sh\nCMD npm run start","打包镜像#打包镜像":"docker build -t test:v2 .\n参数说明：https://docs.docker.com/engine/reference/commandline/build/","启动镜像实例化为容器#启动镜像(实例化为容器)":"docker run -p 8080:8080 --name test test:v2\ndocker run -p 8080:8080 --name test test:v2 -d\ndocker run --name repo alpine/git clone https://github.com/docker/getting-started.git","停止容器#停止容器":"停止某一个容器\ndocker stop test\n停止所有容器运行：\ndocker stop $(docker ps -a -q)\n删除所有停止运行的容器：\ndocker rm $(docker ps -a -q)","目录挂载#目录挂载":"docker run -p 9090:8080 --name test-volumes -v /Users/yuanguandong/Desktop/github/code/docker/demoweb:/app -d test:v2","docker-compose#Docker-compose":"通过 docker-compose.yml 拉起多个 docker 容器要把项目依赖的多个服务集合到一起，我们需要编写一个 docker-compose.yml 文件，描述依赖哪些服务参考文档：https://docs.docker.com/compose/\nversion: \"3.7\"\nservices:\n  app:\n    build: ./\n    ports:\n      - 80:8080\n    volumes:\n      - ./:/app\n    environment:\n      - TZ=Asia/Shanghai\n  redis:\n    image: redis:5.0.13\n    volumes:\n      - redis:/data\n    environment:\n      - TZ=Asia/Shanghai\nvolumes:\n  redis:\n在 docker-compose.yml 文件所在目录，执行：\ndocker-compose up\n就可以跑起来了。命令参考：https://docs.docker.com/compose/reference/up/在后台运行只需要加一个 -d 参数\ndocker-compose up -d\n查看运行状态：\ndocker-compose ps\n停止运行：\ndocker-compose stop\n重启：\ndocker-compose restart\n重启单个服务：\ndocker-compose restart service-name\n进入容器命令行：\ndocker-compose exec service-name sh\n查看容器运行\nlog：docker-compose logs [service-name]","进入容器终端#进入容器终端":"docker exec -it test-v bash","复制文件到容器#复制文件到容器":"docker cp fromPath container:targetPath","常见参数#常见参数":"-i : 让容器的标准输入保持打开-t : 让 docker 分配一个伪终端并绑定到容器的标准输入上"}},"/posts/other/mac-quick-file":{"title":"MacBook快速进入一个文件夹目录","data":{"":"图：Amrit Pal Singh","直达文件夹#直达文件夹":"在桌面点击 Find(访达)，快捷键\ncommand+shift+g\n会弹出一个窗口，在这个窗口中输入文件夹名称就可以快速进入了","拷贝当前文件夹路径#拷贝当前文件夹路径":"command+alt+c","剪切粘贴#剪切粘贴":"command+alt+v","快速打开-finder#快速打开 Finder":"commond+n","快速显示隐藏文件夹#快速显示隐藏文件夹":"commond+shift+.","获取npm全局安装目录#获取npm全局安装目录":"npm root -g","获取npm命令程序目录#获取npm命令程序目录":"npm bin -g"}},"/posts/other/question":{"title":"前端答疑","data":{"":"图：Nguyen Nhut","get-和-post-有什么区别#get 和 post 有什么区别？":"形式\n安全性\n大小\n编码方式\n缓存","http10和http11和http20区别#http1.0和http1.1和http2.0区别":"http1.1\n持久链接\n管道机制\n新方法，PUT,DELETE,OPTIONS,PATCH\n新增缓存字段\n断点续传，通过Range字段来实现\nhttp2.0\n多路复用\n头部压缩\n二进制传输\n优先级\n服务器可以主动推送消息","200-状态码一定是服务器返回的吗#200 状态码一定是服务器返回的吗？":"不是，命中强缓存的话，会直接从内存或者磁盘中读取资源，并返回一个 200 状态码","generate自动执行#generate自动执行":"function asyncToGenerator(generatorFunc) {\n  return function () {\n    const genFn = generatorFunc.apply(this, arguments);\n    const next = (data) => {\n      const { value, done } = genFn.next(data);\n      if (done) return;\n      value.then((data) => {\n        next(data);\n      });\n    };\n    next(arguments);\n  };\n}","从输入一个-url-地址到浏览器完成渲染的整个过程#从输入一个 URL 地址到浏览器完成渲染的整个过程":"浏览器地址栏输入 URL 并回车\n浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期\nDNS 解析 URL 对应的 IP\n根据 IP 建立 TCP 连接（三次握手）\n发送 http 请求\n服务器处理请求，浏览器接受 HTTP 响应\n浏览器解析并渲染页面\n关闭 TCP 连接（四次握手）\n其中浏览器渲染过程如下","将虚拟-dom-转化为真实-dom#将虚拟 Dom 转化为真实 Dom":"{\n  tag: 'DIV',\n  attrs:{\n  id:'app'\n  },\n  children: [\n    {\n      tag: 'SPAN',\n      children: [\n        { tag: 'A', children: [] }\n      ]\n    },\n    {\n      tag: 'SPAN',\n      children: [\n        { tag: 'A', children: [] },\n        { tag: 'A', children: [] }\n      ]\n    }\n  ]\n}\n//把上诉虚拟Dom转化成下方真实Dom\n<div id=\"app\">\n  <span>\n    <a></a>\n  </span>\n  <span>\n    <a></a>\n    <a></a>\n  </span>\n</div>\n// 真正的渲染函数\nfunction _render(vnode) {\n  // 如果是数字类型转化为字符串\n  if (typeof vnode === \"number\") {\n    vnode = String(vnode);\n  }\n  // 字符串类型直接就是文本节点\n  if (typeof vnode === \"string\") {\n    return document.createTextNode(vnode);\n  }\n  // 普通DOM\n  const dom = document.createElement(vnode.tag);\n  if (vnode.attrs) {\n    // 遍历属性\n    Object.keys(vnode.attrs).forEach((key) => {\n      const value = vnode.attrs[key];\n      dom.setAttribute(key, value);\n    });\n  }\n  // 子数组进行递归操作 这一步是关键\n  vnode.children.forEach((child) => dom.appendChild(_render(child)));\n  return dom;\n}","babel工作原理#babel工作原理":"Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）。\n解析\n将代码解析成抽象语法树（AST），每个 js 引擎（比如 Chrome 浏览器中的 V8 引擎）都有自己的 AST 解析器，而 Babel 是通过 Babylon 实现的。在解析过程中有两个阶段：词法分析和语法分析，词法分析阶段把字符串形式的代码转换为令牌（tokens）流，令牌类似于 AST 中节点；而语法分析阶段则会把一个令牌流转换成 AST 的形式，同时这个阶段会把令牌中的信息转换成 AST 的表述结构。\n转换\n在这个阶段，Babel 接受得到 AST 并通过 babel-traverse 对其进行深度优先遍历，在此过程中对节点进行添加、更新及移除操作。这部分也是 Babel 插件介入工作的部分。\n生成\n将经过转换的 AST 通过 babel-generator 再转换成 js 代码，过程就是深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。","raf-和-ric-是什么#RAF 和 RIC 是什么":"requestAnimationFrame： 告诉浏览器在下次重绘之前执行传入的回调函数(通常是操纵 dom，更新动画的函数)；由于是每帧执行一次，那结果就是每秒的执行次数与浏览器屏幕刷新次数一样，通常是每秒 60 次。requestIdleCallback：: 会在浏览器空闲时间执行回调，也就是允许开发人员在主事件循环中执行低优先级任务，而不影响一些延迟关键事件。如果有多个回调，会按照先进先出原则执行，但是当传入了 timeout，为了避免超时，有可能会打乱这个顺序。"}},"/posts/other/productmanager":{"title":"项目管理","data":{"":"图：Vivivian","角色转换#角色转换":"","误区一凡事恨不得事必躬亲#误区一：凡事恨不得事必躬亲":"讲清楚为什么要做，为什么要现在做，获取理解及认同，激发团队的动力","告知#告知":"成功施加影响的三个层次，分别是让人知道要做（Awareness）、有动力做（Desire）和有能力做（Ability）。","动力#动力":"单方面的工作交待和告知，停留在浅层次的信息传达上，知道要做（Awareness），但并不足以让人产生动力（Desire），去促成有效的行动。","能力#能力":"对于动力（Desire）的关注尤为重要。讲清楚为什么要做，为什么要现在做，获取理解及认同，激发团队的动力，是项目经理成功授权工作的关键。在动力（Desire）的基础上，你还要确保你所选择的人，有相应的能力（Ability）来做到这件事情。如果现阶段的团队都没有对应的能力，该怎么办呢？项目成功关键路径上的核心能力缺失，是你作为项目管理人员，要当作最高优先级的风险管理的事项。","误区二追在别人屁股后面做监工#误区二：追在别人屁股后面做监工":"项目经理最该做的，并不是每天监督逐个人、逐条事项，而是要明确目标，建立机制，并让这个机制运转起来，最终在项目组形成一种良性的秩序。要始终依靠流程和规则来约束大家的行为。","误区三拿着锤子看哪里都是钉子#误区三：拿着锤子，看哪里都是钉子":"需要与项目中的重要干系人加强沟通，理清前因后果，多想想自己的项目现阶段到底最需要什么\n在你的项目组中，时间、成本、质量、范围这几个因素，到底哪个更重要？哪些是允许有一定调整空间的？","项目管理常识#项目管理常识":"“项目管理就是变理想为现实，化抽象为具体的一门科学和艺术。”","干系人管理如何管理干系人#干系人管理：如何管理干系人？":"哪些人会是你的干系人？项目发起人对活动的预期效果是什么？","范围管理做什么#范围管理：做什么？":"确保围绕着预期目标来设计相应的活动方案","进度管理花多长时间#进度管理：花多长时间？":"要规划好阶段性步骤，同时明确每个里程碑的目标成果和时间安排。","成本管理花多大代价#成本管理：花多大代价？":"要从全局视角去思考，如何更有效地管理项目的各项投入，以达到更加匹配目标的预期效果。","质量管理达到什么要求#质量管理：达到什么要求？":"需要引入哪些必要的流程和方法，以保障活动效果的达成。","资源管理有多少内部资源#资源管理：有多少内部资源？":"公司内有哪些核心资源是可以使用的？","采购管理有多少还要买#采购管理：有多少还要买？":"还有哪些是需要外部采购？","沟通管理如何管理沟通#沟通管理：如何管理沟通？":"需要考虑的是，活动策划团队、执行团队分别通过什么方式来进行项目沟通？","风险管理如何应对风险#风险管理：如何应对风险？":"你需要提前做好系统性的风险识别，分等级制定应对策略。","整合管理如何实现整体最优#整合管理：如何实现整体最优？":"如何去统筹全局，整合并协调各个环节的利益冲突和工作安排，在不断变化的情境下，根据活动的目标“裁剪”出合适的过程、方法和工具，进行有效管理，从而达到全局的最优效果。\n保目标，助决策，提效能，促协作。","pdca#PDCA":"很多人应该都听说过 PDCA 循环，它最早来自于质量管理领域，意思是做任何事情，都要经过规划（Plan）、执行（Do)、检查 (Check) 和行动 (Act) 这四个步骤，又称戴明环。可以说，这四个步骤提供了一个简易的思考和做事框架。需要注意的是，这个循环并不是运行一次就结束了，而是周而复始、螺旋上升的。别看它很简单，实际上，越是简单的东西，就越是普适！PMI 遵循 PDCA 的法则，将所有的项目管理活动分成了五大过程组，分别是启动过程组、规划过程组、执行过程组、监控过程组和收尾过程组。","项目管理的五大过程组#项目管理的五大过程组":"启动过程组（千里之行，始于足下）启动过程组意味着正式开始一个项目，或者是开始一个项目中的新阶段，包括识别干系人和制定项目章程两个子过程。正式宣告一个新项目或新阶段的开始，公开确认项目章程，包括明晰各方干系人的期望和诉求，设定愿景目标和重要里程碑，确定责任分工和沟通机制等。","规划过程组运筹帷幄决胜千里#规划过程组（运筹帷幄，决胜千里）":"规划就是要把愿景目标转化为可落地的行动方案和工作路线。你需要根据预期目标，明确项目范围，确定项目的里程碑阶段目标，为项目的执行做好各项准备。","执行过程组言出必行行之必果#执行过程组（言出必行，行之必果）":"规划做好之后，就是考验执行力的时候了。这个阶段重在整合资源，推进项目落地，完成项目管理计划中确定的工作以实现项目目标。","监控过程组审时度势沉着应变#监控过程组（审时度势，沉着应变）":"执行并不意味着在任何情况下都要一成不变。当外界环境或内部要求发生变化时，项目管理者也要审时度势，沉着应变，适时调整各方，以更好地实现目标。","收尾过程组慎终如始则无败事#收尾过程组（慎终如始，则无败事）":"收尾过程组是五个过程中的最后一个，而头和尾都是最容易被忽略的，所以我要重点强调一下。在这个阶段，你要交付项目成果，组织团队的回顾复盘，归档所有文档等组织过程资产，正式结束一个项目或阶段。不管项目成功与否，“趁热”复盘都是极为重要的一步。\n提效能是要去关注和消灭团队中的低价值工作所引发的效能痛点。\n通过技术的手段实现自动化，从而为整条链条提速。\n促协作则是着眼于使用各种项目管理方法和工具，让高价值工作者，也就是一堆牛人放在一起，如何可以更好地合作。\n比如，建立清晰有效的信息渠道和沟通机制，积极推动各角色达成共识等，实现全局价值的最大化。举个例子，假如测试环境的部署耗时很长，这已经成为了整个团队的瓶颈，那你就要想办法","风险管理冰山下的风险如何系统化应对#风险管理：冰山下的风险，如何系统化应对？":"在整个项目期间，积极而又持续地开展风险管理。","系统化风险识别#系统化风险识别":"风险识别的主体，应该包含项目中的团队成员在内的各方干系人","冰山下的风险#冰山下的风险":"大家对项目里的风险避而不谈。原因可能是：缺乏风险的沟通渠道；提出来也没有用；老板会认为我没能力管好当前的项目。没有人反馈风险，不代表没有风险。其实，当寻常的渠道不管用的时候，就要看 PM 的信息网络了。项目经理一定不能脱离团队，如果没有群众基础，只是坐等着别人给你上报风险，那你的工作就远远没有做到位。记住，你识别出的风险越多，项目的风险就越低。","风险应对措施#风险应对措施":"对于发生概率很高的严重风险，一定要提前准备风险应对方案和危机应急预案，一旦风险和危机来临，应急预案就可以有效地降低风险的损失和危机的灾难。周期性的风险审查，来识别新的风险。","树立正确的风险观#树立正确的风险观":"治未病，建立系统性保健机制事后不如事中控制，事中不如事前控制。你要致力于持续改善人与人之间的互动品质，提升项目团队的健康度。匿名的问卷收集或访谈","积极管理致命风险#积极管理致命风险":"1、挖掘出这些致命风险，把它们变为可见的、可谈的。很多管理者非常关心执行中的风险，却对于这类致命风险讳莫如深，只留在自己脑子里，这样反而是最危险的。致命风险的挖掘，通常会让我们对于项目背景的理解更加透彻，并对那些影响到项目生死存亡的关键要事，有更加清晰的认知和规划部署。2、正视风险，不存侥幸心理。你要和发起人一起想办法，发动核心团队，合力去制定应对策略。3、在项目核心团队中，周期性地梳理和同步风险状态。加速构建核心能力，不断拓宽护城河，才是最根本的应对之道。"}},"/posts/other/ram":{"title":"内存管理","data":{"":"图：Mako Tsereteli","1内存的生命周期#1、内存的生命周期":"内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存内存使用：即读写内存，也就是使用变量、函数等内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存","2-js-中的内存分配#2. Js 中的内存分配":"const n = 123; // 给数值变量分配内存\nconst s = \"azerty\"; // 给字符串分配内存\nconst o = {\n  a: 1,\n  b: null,\n}; // 给对象及其包含的值分配内存","3-js-中的内存使用#3. Js 中的内存使用":"使用值的过程实际上是对分配内存进行读取与写入的操作。 读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。\nvar a = 10; // 分配内存\nconsole.log(a); // 对内存的使用","4-js-中的垃圾回收机制#4. Js 中的垃圾回收机制":"垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。","41-引用计数垃圾回收#4.1 引用计数垃圾回收":"引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。 如果没有其他对象指向它了，说明该对象已经不再需了。但它却存在一个致命的问题：循环引用。如果两个对象相互引用，尽管他们已不再使用，垃圾回收不会进行回收，导致内存泄露。","42-标记清除算法#4.2 标记清除算法":"标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 简单来说，就是从根部（在 JS 中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。4.2.1 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。4.2.2 从根部出发将能触及到的对象的标记清除。4.2.3 那些还存在标记的变量被视为准备删除的变量。4.2.4 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。","5-常见的内存泄露#5. 常见的内存泄露":"","51-全局变量#5.1 全局变量":"function foo() {\n  bar1 = \"some text\"; // 没有声明变量 实际上是全局变量 => window.bar1\n  this.bar2 = \"some text\"; // 全局变量 => window.bar2\n}\nfoo();","52-未被清理的定时器和回调函数#5.2 未被清理的定时器和回调函数":"如果后续 renderer 元素被移除，整个定时器实际上没有任何作用。 但如果你没有回收定时器，整个定时器依然有效, 不但定时器无法被内存回收， 定时器函数中的依赖也无法回收。在这个案例中的 serverData 也无法被回收。\nvar serverData = loadData();\nsetInterval(function () {\n  var renderer = document.getElementById(\"renderer\");\n  if (renderer) {\n    renderer.innerHTML = JSON.stringify(serverData);\n  }\n}, 5000); // 每 5 秒调用一次","53-闭包#5.3 闭包":"在 JS 开发中，我们会经常用到闭包，一个内部函数，有权访问包含其的外部函数中的变量。 下面这种情况下，闭包也会造成内存泄露\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var unused = function () {\n    if (originalThing)\n      // 对于 'originalThing'的引用\n      console.log(\"hi\");\n  };\n  theThing = {\n    longStr: new Array(1000000).join(\"*\"),\n    someMethod: function () {\n      console.log(\"message\");\n    },\n  };\n};\nsetInterval(replaceThing, 1000);\n这段代码，每次调用 replaceThing 时，theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象。 同时 unused 是一个引用了 originalThing 的闭包。\n这个范例的关键在于，闭包之间是共享作用域的，尽管 unused 可能一直没有被调用，但是 someMethod 可能会被调用，就会导致无法对其内存进行回收。 当这段代码被反复执行时，内存会持续增长。","53-dom-引用#5.3 DOM 引用":"很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中。\nvar elements = {\n  image: document.getElementById(\"image\"),\n};\nfunction doStuff() {\n  elements.image.src = \"http://example.com/image_name.png\";\n}\nfunction removeImage() {\n  document.body.removeChild(document.getElementById(\"image\"));\n  // 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.\n}\n上述案例中，即使我们对于 image 元素进行了移除，但是仍然有对 image 元素的引用，依然无法对齐进行内存回收。","6-如何避免内存泄露#6. 如何避免内存泄露":"减少不必要的全局变量，使用严格模式避免意外创建全局变量。\n在你使用完数据后，及时解除引用（闭包中的变量，dom引用，定时器清除）。\n组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。","7-实现-sizeof-函数-get-size-of-a-javascript-object-in-bytes#7. 实现 sizeOf 函数, Get size of a JavaScript object in Bytes":"const seen = new WeakSet();\nfunction sizeOfObject(object) {\n  if (object == null) {\n    return 0;\n  }\n  let bytes = 0;\n  const properties = Object.keys(object);\n  for (let i = 0; i < properties.length; i++) {\n    const key = properties[i];\n    // Do not recalculate circular references\n    if (typeof object[key] === \"object\" && object[key] !== null) {\n      if (seen.has(object[key])) {\n        continue;\n      }\n      seen.add(object[key]);\n    }\n    bytes += calculator(key);\n    bytes += calculator(object[key]);\n  }\n  return bytes;\n}\nfunction calculator(object) {\n  const objectType = typeof object;\n  switch (objectType) {\n    case \"string\":\n      return object.length * 2;\n    case \"boolean\":\n      return 4;\n    case \"number\":\n      return 8;\n    case \"object\":\n      if (Array.isArray(object)) {\n        return object.map(calculator).reduce(function (acc, curr) {\n          return acc + curr;\n        }, 0);\n      } else {\n        return sizeOfObject(object);\n      }\n    default:\n      return 0;\n  }\n}\nconst testData = {\n  a: 111,\n  b: \"cccc\",\n  2222: false,\n};\nconsole.log(calculator(testData));"}},"/posts/other/security":{"title":"前端安全","data":{"":"图：Mako Tsereteli","总览#总览":"浏览器相关：\nXSS\nCSRF\nHTTPS\nCSP (内容安全策略, 可以禁止加载外域代码, 禁止外域提交等等)\nHSTS (强制客户端使用HTTPS与服务端建立连接)\nX-Frame-Options (控制当前页面是否可以被嵌入到Ifrmae中)\nSRI (subresource intergrity 子资源完整性, 前端可以用webpack-subresource-integrity插件, 在每个script上添加hash值, 校验加载的资源是否和当时打包生成的一致)\nReferrer-Policy (控制referer的携带策略)\nNode(服务端)相关\n\b本地文件操作相关：路径拼接导致的文件泄露\nReDOS\n时序攻击\nip origin referrer等request headers的校验(在做爬虫应用的时候\b对此会有深刻的体会)","xss#XSS":"Cross-site scripting, 跨站脚本, 通常简称为XSS. \b\b为什么简写为XSS而不是CSS? 因为CSS被广泛应用于样式的称呼里, 而Cross意味交叉, X\b字母正好是符合交叉的含义, 所以简称为XSS。说白了就是攻击者想尽一切办法将可执行代码注入到网页中, 而恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。","外在表现上-都有哪些攻击场景#外在表现上, 都有哪些攻击场景?":"评论区植入js代码(即可输入的地方植入js代码)\nurl上拼接js代码\nTIPS: 有点同学可能觉得在这种场景下, 用户能输入的代码长度有限, 根本构不成什么威胁?\n然而攻击者是可以通过引入外部脚本来实现复杂攻击的.","具体从技术角度上分析-都有哪些xss攻击的类型呢#具体从技术角度上分析, 都有哪些xss攻击的类型呢?":"1、 存储型 Server\n场景：常见于带有用户保存数据的网站功能，攻击者通过可输入区域来注入恶意代码, 如论坛发帖、商品评论、用户私信等。\n攻击步骤：\n攻击者将恶意代码提交到目标网站的数据库中\n用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在HTML中返回给浏览器(因为用户之间是可以相互看到帖子、评论等的)\n用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行\n恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站的接口执行攻击者指定的操作。\n2、 反射型 Server与存储型的区别在于，存储型的恶意代码通过可输入区域, 存储在数据库中，而反射型的恶意代码拼接在URL上。\n由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。\n场景：通过 URL 传递参数的功能，如网站搜索、跳转等。\n攻击步骤：\n攻击者构造出特殊的 URL，其中包含恶意代码。\n用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\n用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。\n恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站的接口执行攻击者指定的操作。\n3、 Dom型 BrowserDOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。\n场景：通过 URL 传递参数的功能，如网站搜索、跳转等。\n攻击步骤：\n攻击者构造出特殊的 URL，其中包含恶意代码。\n用户打开带有恶意代码的 URL。\n用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。\n恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站的接口执行攻击者指定的操作。","简单模拟一下dom型xss攻击#简单模拟一下Dom型XSS攻击?":"index.html\n<!DOCTYPE html>\n<html lang=\"zh\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n        <meta\n            name=\"viewport\"\n            content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no\"\n        />\n        <title>XSS</title>\n    </head>\n    <body>\n        <a href=\"\">跳转到新地址</a>\n    </body>\n    <script src=\"type-dom.js\"></script>\n</html>\ntype-dom.js\nconst a = document.getElementsByTagName('a')[0];\nconst queryObject = {};\nconst search = window.location.search;\nsearch.replace(/([^&=?]+)=([^&]+)/g, (m, $1, $2) => (queryObject[$1] = decodeURIComponent($2)));\na.href = queryObject.redirectUrl;\n打开当前index.html, 添加参数redirectUrl访问\n比如redirectUrl=javascript:alert('哈哈哈笨蛋!!')\n点击a链接发现已经被xss攻击了.\n长度有限制\n比如我们写这样一段脚本, 目的是创建一个script标签并且引入remote.js文件, 将这一串代码作为redirectUrl的值访问链接.\nvar script = document.createElement('script');\nscript.type = 'text/javascript';\nscript.async = true;\nscript.src = 'remote.js';\nvar s = document.getElementsByTagName('script')[0];\ns.parentNode.insertBefore(script, s);\n新建remote.js文件, 来尝试耗性能的代码.\nlet count = 0;\nconsole.log(window.navigator.userAgent);\nwhile(count++ < 100) {\n    console.log('我要通过巨量运算把你搞崩溃')\n}\n而如果我们网站的cookie里有重要的用户信息, 那么攻击者是否就可以通过document.cookie获取到了?\\\n比如我们在原来的网站脚本type-dom.js里设置一下cookie, 然后在攻击脚本remote.js里获取.document.cookie=\"name=john12313\";console.log(document.cookie);但是聪明的同学应该也想到了, 只要我们给重要的cookie设置了http-only, 就算被dom xss攻击了, 攻击者也造不成大的影响.\n再来试试访问url就直接出发的xss攻击.\ntype-dom.js\ndocument.write(queryObject.name)\n添加参数访问url,\nname=<script>window.alert(1)</script>\n可以试一下这个网站, https://alf.nu/alert1","如何防范xss攻击呢#如何防范XSS攻击呢?":"主旨：防止攻击者提交恶意代码，防止浏览器执行恶意代码\n对数据进行严格的输出编码：如HTML元素的编码，JS编码，CSS编码，URL编码等等\n避免拼接 HTML；Vue/React 技术栈，避免使用 v-html / dangerouslySetInnerHTML\nCSP HTTP Header，即 Content-Security-Policy（不支持CSP的旧版浏览器可以设置X-XSS-Protection）\n增加攻击难度，配置CSP(本质是建立白名单，由浏览器进行拦截)\nContent-Security-Policy: default-src 'self' -所有内容均来自站点的同一个源（不包括其子域名）\nContent-Security-Policy: default-src 'self' *.trusted.com -允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)\nContent-Security-Policy: default-src https://john.com -该服务器仅允许通过HTTPS方式并仅从john.com域名来访问文档\n可以做到很多事情，比如：\n禁止加载外域代码，防止复杂的攻击逻辑。\n禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。\n输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断\n开启浏览器XSS防御：Http Only cookie，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。\n验证码","csrf#CSRF":"Cross-site request forgery, 跨站请求伪造.攻击者诱导受害者进入恶意网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。","攻击步骤#攻击步骤":"受害者登录 a.com，并保留了登录凭证（Cookie）\n攻击者引诱受害者访问了b.com\nb.com 向 a.com 发送了一个请求：a.com/act=xx浏览器会默认携带a.com的Cookie\na.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求\na.com以受害者的名义执行了act=xx\n攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作","攻击类型#攻击类型":"GET型：如在页面的某个 img 中发起一个 get 请求\n![](http://bank.example/withdraw?name=xxx&amount=xxxx)\nPOST型：通过自动提交表单到恶意网站\n<form action=\"http://bank.example/withdraw\" method=POST>\n    <input type=\"hidden\" name=\"account\" value=\"john\" />\n    <input type=\"hidden\" name=\"amount\" value=\"10000\" />\n    <input type=\"hidden\" name=\"for\" value=\"hacker\" />\n</form>\n<script> document.forms[0].submit(); </script> \n链接型：需要诱导用户点击链接\n<a href=\"http://bank.example/withdraw?name=xxx&amount=xxxx\" taget=\"_blank\">\n错过再等一年！！！快来看看\n</a>","如何防范csrf的攻击呢#如何防范CSRF的攻击呢?":"首先咱们通过上面的举例可以知道, CSRF一般都是发生在第三方域名, 攻击者也无法获取到Cookie信息, 只是可以利用浏览器机制去使用Cookie.所以咱们可以针对这两点来看防范策略：","阻止第三方域名的访问#阻止第三方域名的访问":"Cookie SameSite\nSameSite有3个值： Strict, Lax和None\nStrict：浏览器会完全禁止第三方cookie。比如a.com的页面中访问 b.com 的资源，那么a.com中的cookie不会被发送到 b.com服务器，只有从b.com的站点去请求b.com的资源，才会带上这些Cookie\nLax：在跨站点的情况下，从第三方站点链接打开和从第三方站点提交 Get方式的表单这两种方式都会携带Cookie。但如果在第三方站点中使用POST方法或者通过 img、Iframe等标签加载的URL，这些场景都不会携带Cookie\nNone：任何情况下都会发送 Cookie数据\n同源检测\n通过检测request header中的origin referer等, 来确定发送请求的站点是否是自己期望中站点.比如referer, 我们可以在服务端去判断referer是否来自可信域, 同样也可以做一些referer发送时的设置：对于同源的链接和引用，会发送Referer，referer值为Host不带Path；跨域访问则不携带Referer。例如：aaa.com引用bbb.com的资源，不会发送Referer(服务端在接收到没有referer的请求时就不做响应)这就提到了Referrer-Policy这个请求头. https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy, 控制什么情况下应该携带/不携带referer","提交请求时附加额外信息#提交请求时附加额外信息":"因为攻击者无法通过csrf来获取本域下的cookie等信息, 所以可以利用这一点来做防范.\nCSRF Token\n用户打开页面的时候, 服务器利用加密算法给当前用户生成一个ToKen\n每次页面加载时, 前端把获取到的Token加到所有的能发请求的html元素上, 比如form, a\n每次前端发起请求, 都携带Token参数\n服务端每次接收请求, 都校验Token的有效性.\n双重Cookie\n用户访问网站的时候, 服务器向浏览器注入一个额外的cookie, 内容随便, 比如csrfcookie=johnxzxfasdfasfew\n每次前端发起请求, 都在请求上拼接上csrfcookie这个参数, 参数值就从cookie里获取\n服务端每次收到请求, 就去校验请求参数里的值和cookie里的值是否一致\n但是这种方式安全性不如CSRF Token. 咱们来看一下原因：\n如果前端域名和服务端域名不一样, 比如前端 fe.a.com, 后端 rd.a.com, 那如果服务端希望前端能拿到csrfcookie, 就只能把这个cookie设置到a.com域下, 并且不能设置为http-only\n那么a.com的每个子域名就都可以获取到这个cookie\n一旦某个子域名遭到xss攻击, cookie就很容易被窃取或者被篡改.\n攻击者利用篡改或者窃取的csrfcookie, 就可以攻击fe.a.com了","node服务端相关的安全问题#Node(服务端)相关的安全问题":"","本地文件操作#本地文件操作":"比如我们提供一个静态服务, 通过请求的参数url来返回给用户或者前端想要的资源.\n新建文件node/static-sever-dangerous.js\nconst fs = require('fs');\nconst http = require('http');\nconst path = require('path');\nhttp\n  .createServer(function (req, res) {\n    const file = path.join(__dirname, 'static', req.url);\n    fs.readFile(file, function (err, data) {\n      if (err) {\n        res.writeHead(404, { \"Content-Type\": \"text/plain;charset=utf-8\" });\n        res.end('找不到对应的资源');\n        return;\n      }\n      res.writeHead(200, { \"Content-Type\": \"text/plain;charset=utf-8\" });\n      res.end(data);\n    });\n  })\n  .listen(8080);\n  console.log('server listening on port 8080');\n新建文件夹static, 里面随便放点文件, 提供给外界请求\n比如 test.json\n{\n    \"name\": \"john\"\n}\n启动服务, 本地请求url\nhttp://localhost:8080/test.jsonhttp://localhost:8080/test1.json没有任何问题对吧? 存在的资源正常返回了, 不存在的资源返回404了.\n请求一个不一样的url\nhttp://localhost:8080/?/../../../questions.md\nhttp://localhost:8080/?/../../../private.js\n同级新建一个private.js, 里面写上一些私密信息\n// 这是一个私密文件\n可以看到, 攻击者可以通过拼接相对路径, 一次次猜你项目的结构, 并且可以访问到你服务器上的各种资源！\n怎么解决这个问题?\n很多node框架都自带插件来屏蔽这个问题的发生比如express.static, koa-static, 当然也有第三方包支持(resolve-path)咱们用resove-path来解决一下这个问题.\nnpm init\nyarn add resolve-path --registry=https://registry.npm.taobao.org\n新建 static-sever-secure.js 文件\nconst fs = require('fs');\nconst http = require('http');\nconst path = require('path');\n// 引入resolve-path\nconst resolvePath = require('resolve-path');\nhttp\n  .createServer(function (req, res) {\n    try {\n        // 先获取rootDir\n        const rootDir = path.join(__dirname, 'static');\n        // 调用resolvePath\n        const file = resolvePath(rootDir, req.url);\n    \n        fs.readFile(file, function (err, data) {\n          if (err) {\n            // 把错误抛出去\n            throw err;\n          }\n          res.writeHead(200, { \"Content-Type\": \"text/plain;charset=utf-8\" });\n          res.end(data);\n        });\n    } catch(e) {\n        // catch住错误, 防止服务直接挂掉\n        console.log(e);\n        res.writeHead(404, { \"Content-Type\": \"text/plain;charset=utf-8\" });\n        res.end('找不到对应的资源');\n    }\n    \n  })\n  .listen(8081); // 改成8081端口\n  console.log('server listening on port 8081');\n可以看到resolve-path的源码对path做了严格的限制.","截图服务#截图服务":"比如咱们来实现一个简单的截图服务\n安装好必要的npm包\nyarn add puppeteer-chromium-resolver koa --registry=https://registry.npm.taobao.org\n新建 screen-shot.js\n(async () => {\n    const PCR = require('puppeteer-chromium-resolver');\n    const stats = await PCR();\n  \n    const browser = await stats.puppeteer\n      .launch({\n        headless: true,\n        args: ['--no-sandbox'],\n        executablePath: stats.executablePath,\n      })\n      .catch(function (error) {\n        console.log(error);\n      });\n  \n    const Koa = require('koa');\n    const app = new Koa();\n  \n    app.use(async ctx => {\n      const { url } = ctx.query;\n  \n      // 这里演示不合理的Url校验\n      if (!url) {\n        ctx.body = 'Invalid url';\n  \n        return;\n      }\n  \n      ctx.set('Content-Type', 'image/png');\n  \n      const page = await browser.newPage();\n      await page.goto(url, { waitUntil: 'networkidle2' });\n  \n      ctx.body = await page.screenshot({ encoding: 'binary', type: 'png' });\n  \n      await page.close();\n    });\n    app.listen(8083);\n  \n    console.log('server listening on port 8083');\n  })();\n访问url\nhttp://localhost:8083/?url=http://localhost:8080/test.json\n这里咱们传入url为之前启动的不安全的静态服务. 可以看到我们直接截图了对应的资源\nhttp://localhost:8083/x?url=file:///etc/zshrc\n这里咱们传入url为文件系统的zshrc, 可以发现我们直接截图了系统文件的内容.","redos#ReDOS":"新建redos.js, 分别看一下这三个例子的执行时间\nconsole.time('case-1');\n// 能够匹配成功\n/A(B|C+)+D/.test('ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD');\nconsole.timeEnd('case-1');\nconsole.time('case-2');\n// 不能匹配成功\n/A(B|C+)+D/.test('ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX');\nconsole.timeEnd('case-2');\nconsole.time('case-3');\n// 不能匹配成功\n/A(B|C+)+D/.test(`A${'C'.repeat(30)}X`);\nconsole.timeEnd('case-3');\n可以看到, 当不能匹配成功的时候, 每多一个字符, 所消耗是时间都是指数增长的.因为咱们服务器经常会有正则去匹配一些传入的参数, 所以攻击者就可以利用正在表达式的这个特性, 来一直占用服务器运算资源, 造成服务器宕机.具体原理可以看这篇文章：https://snyk.io/node-js/connect正则表达式一般情况下会去匹配第一种可能性, 比如一个正确的字符串 ACCCD, 那么直接匹配到最后发现成功了, 耗时就很短.而比如ACCCX这样一个字符, 每当一次匹配不成功, 就会尝试回溯到上一个字符, 看看能不能有其他的组合来匹配到这个字符串.比如刚才说的ACCCX这样一个字符串, 会去尝试匹配四种不同的\"C\"字母组合来与其他字母组合, 看是否符合条件.\nCCC\nCC+C\nC+CC\nC+C+C.\n可以在写完正则后去这个网址测试一下 https://regex.rip/? 测试是否会遭到reDos.","时序攻击#时序攻击":"这种攻击方式在咱们编码过程中可能很少见, 看下面这个例子比如咱们要匹配接收的数组和咱们定义好的数组是否完全一致, 如果一致才可以进行之后的操作.\nfunction compareArray(realArray, userInputArrary) {\n    for (let i = 0; i < realArray.length; i++) {\n        if (realArray[i] !== userInputArray[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n这样写有没有什么问题? 逻辑上没有任何问题, 但是有安全问题.因为我们如果判断到一个字符不相等, 就提前返回了！！这给攻击者提供了一种方式, 就是根据服务器的响应时间来碰撞出realArray的值.比如realArray = [2,3,6,1]攻击者开始尝试\ninputArray = [1,2]\ninputArray = [1,3]发现这两种的响应时间几乎一致, 则可以认为第一个数字不是1inputArray = [2, 2]发现响应时间延长了, 则可以认为第一个数字是2.长而久之, 就可以碰撞出真实的realArray了."}},"/posts/other/ssh-keygen":{"title":"ssh-keygen命令详解","data":{"":"图：Vivivian\n为ssh生成、管理和转换认证密钥,ssh-keygen命令 用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥。\nSSH 密钥默认保留在 ~/.ssh 目录中。如果没有 ~/.ssh 目录，ssh-keygen命令会使用正确的权限创建一个。","命令语法#命令语法":"ssh-keygen [选项]","命令选项#命令选项":"-b：指定密钥长度；\n-e：读取openssh的私钥或者公钥文件；\n-C：添加注释；\n-f：指定用来保存密钥的文件名；\n-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；\n-l：显示公钥文件的指纹数据；\n-N：提供一个新密语；\n-P：提供（旧）密语；\n-q：静默模式；\n-t：指定要创建的密钥类型。\n以下 ssh-keygen 命令默认在 ~/.ssh 目录中生成 4096 位 SSH RSA 公钥和私钥文件。如果当前位置存在 SSH 密钥对，这些文件将被覆盖。\nssh-keygen -m PEM -t rsa -b 4096\n使用ssh-kengen会在~/.ssh/目录下生成两个文件，不指定文件名和密钥类型的时候，默认生成的两个文件是\nid_rsa 第一个是私钥文件\nid_rsa.pub 第二个是公钥文件","指定秘钥文件路径#指定秘钥文件路径":"ssh-keygen -t rsa -C '*****@**.com' -f ~/.ssh/github_id_rsa\n或者，在指定存放文件时输入一个新的文件名","示例#示例":"生成github action所需公钥私钥\ncd ~/.ssh\nssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\"\n公钥放到deploy key\n私钥放到secrets"}},"/posts/network/http":{"title":"HTTP详解","data":{"":"图：Nguyen Nhut\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。\nHTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。\n我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。","一次完整的http通信是什么样子的#一次完整的HTTP通信是什么样子的?":"建立 TCP 连接\n在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；\n客户端向服务器发送请求命令\n一旦建立了TCP连接，客户端就会向服务器发送请求命令；\n例如：GET/info HTTP/1.1\n客户端发送请求头信息\n客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；\n服务器应答\n客户端向服务器发出请求后，服务器会客户端返回响应；\n例如： HTTP/1.1 200 OK\n响应的第一部分是协议的版本号和响应状态码\n服务器返回响应头信息\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；\n服务器向客户端发送数据\n服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；\n服务器关闭 TCP 连接\n一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。","http协议有哪些特点#HTTP协议有哪些特点?":"通过请求和响应的交换达成通信\n协议规定, 请求从客户端发出, 服务端响应请求并返回.\n无状态\nHTTP 是一种无状态协议, 在单纯HTTP这个层面，协议对于发送过的请求或响应都不做持久化处理\n使用Cookie做状态管理\n服务端返回的头信息上有可能会携带Set-Cookie, 那么当客户端接收到响应后, 就会在本地种上cookie. 在下一次给服务端发送请求的时候, 就会携带上这些cookie。\n通过URL定位资源\n这里区分一下URI和URL的概念.URI: 统一资源标识符, 比如你身份证号是xxxxxxx, 在所有人中是独一无二的, 这个身份证号就能标识你的身份, 那么它就是URI\nURL: 统一资源定位符, 比如北京市/朝阳区/xxxx/xxxx/xxxxx, 通过这一串信息可以定位到你, 那么这个就是URLURL有点类似于通过定位实现的URI.就像有个父类叫做URI, 他要实现的是唯一确定一个id. 有的人喜欢继承URI, 通过location来实现; 有的人喜欢继承URI, 通过name来实现.\n通过各种方法来标识自己的意图\n这里指的是各种HTTP方法, 比如GET POST PUT DELETE等.\n持久连接\nHTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接，增加了很多没必要的建立连接的开销。\n为了解决上述 TCP 连接的问题，HTTP/1.1 支持持久连接。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。也就是说默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。\n管道机制\n1.1版本引入pipelining机制, 即在同一个TCP连接里面，客户端可以同时发送多个请求。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。但是现代浏览器一般没开启这个配置, 这个机制可能会造成队头阻塞. 因为响应是有顺序的, 如果一个TCP连接中的第一个HTTP请求响应非常慢, 那么就会阻塞后续HTTP请求的响应.所以现实中默认情况下, 一个TCP连接同一时间只发一个HTTP请求.有的同学会问, 我怎么听说chrome最大支持6个同域名请求呢？那是因为chrome最大支持同时开启6个TCP连接。","那么http-101120在并发请求上主要区别是什么#那么HTTP 1.0/1.1/2.0在并发请求上主要区别是什么?":"HTTP/1.0\n每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接.\nHTTP/1.1\n默认采用持续连接(TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive).\n增加了管道机制，在同一个TCP连接里，允许多个请求同时发送，增加了并发性，进一步改善了HTTP协议的效率，\n但是同一个TCP连接里，所有的数据通信是按次序进行的。回应慢，会有许多请求排队，造成\"队头堵塞\"。\nHTTP/2.0\n加了双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题。\n使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。\n增加服务器推送的功能，不经请求服务端主动向客户端发送数据。","各种headers#各种Headers":"","cache-control#Cache-Control":"通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。\nCache-Control: public\n当指定使用 public 指令时，则明确表明其他用户也可利用缓存。\nCache-Control: private\n当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。\nCache-Control: no-cache\n可以在客户端存储资源，每次都必须去服务端做过期校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。也就是所谓的协商缓存。\nCache-Control: no-store\n永远都不要在客户端存储资源，永远都去原始服务器去获取资源。\nCache-Control: max-age=604800（单位：秒）\n当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定的时间更小，那么客户端就接收缓存的资源。另外，当指定 max-age 的值为0，那么缓存服务器通常需要将请求转发给源服务器。HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，并忽略掉 Expires 首部字段\nCache-Control: s-maxage=604800（单位：秒）\ns-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（一般指代理）。\n当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理","connection#Connection":"Connection: close\nHTTP/1.1 版本的默认连接都是持久连接。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close。\nConnection: Keep-Alive\nHTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。","date#Date":"表明创建 HTTP 报文的日期和时间。\nDate: Mon, 10 Jul 2021 15:50:06 GMT\nHTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式。","pragma#Pragma":"Pragma 首部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。\nPragma: no-cache\n该首部字段属于通用首部字段，但只用在客户端发送的请求中，要求所有的中间服务器不返回缓存的资源。所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式最为理想。但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以，发送的请求会同时包含下面两个首部字段：\nCache-Control: no-cache\nPragma: no-cache","accept#Accept":"Accept: text/html, application/xhtml+xml, application/xml;\nAccept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。\nAccept-Encoding: gzip, deflate\nAccept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先顺序，并可一次性指定多种内容编码\n也可使用星号（*）作为通配符，指定任意的编码格式。gzip\t表明实体采用 GNU zip 编码\ncompress\t表明实体采用 Unix 的文件压缩程序\ndeflate\t表明实体采用 zlib 的格式压缩的\nidentity\t表明没有对实体进行编码，当没有 Content-Encoding 首部字段时，默认采用此编码方式","host#Host":"Host: www.baidu.com\n告知服务器，请求的资源所处的互联网主机和端口号。\nHost 首部字段是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。\n若服务器未设定主机名，那直接发送一个空值即可 Host: 。","if-modified-since#If-Modified-Since":"形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。\nIf-Modified-Since: Mon, 10 Jul 2021 15:50:06 GMT\n用于确认代理或客户端拥有的本地资源的有效性。\n在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应","etag#ETag":"ETag: \"aaaa-1234\"\n首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。\n另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。","if-none-match#If-None-Match":"If-None-Match: \"john\"\n用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。","user-agent#User-Agent":"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36\n首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。\n由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。","allow#Allow":"Allow: GET, HEAD\n首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。\n当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。","content-encoding#Content-Encoding":"Content-Encoding: gzip\n首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。","content-type#Content-Type":"Content-Type: text/html; charset=UTF-8\n首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。","expires#Expires":"Expires: Mon, 10 Jul 2021 15:50:06 GMT\n首部字段 Expires 会将资源失效的日期告知客户端。\n缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。","set-cookie#Set-Cookie":"Set-Cookie: userId=11111; expires=Mon, 10 Jul 20121 15:50:06 GMT; path=/;\nNAME=VALUE: cookie名称和值\nexpires=DATE: Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）\npath=PATH: 用于限制指定 Cookie 的发送范围的文件目录。\ndomain=域名: cookie有效的域名 （若不指定则默认为创建 Cookie的服务器的域名）\nSecure: 仅在 HTTPS 安全通信时才会发送 Cookie\nHttpOnly: 使 Cookie 不能被 JavaScript 脚本访问"}},"/posts/other/terminal":{"title":"做一个web termianl","data":{"":"图：Tobias\n最近公司项目要用到 web termianl, 先提前在家里做一个 🐶","效果图#效果图":"自适应容器、带搜索、主题美化","准备#准备":"需求是自动化测试的日志，要实时的展现在前端，所以少不了 webSocket在前端需要有个终端能显示出来，也有可能后续会需要在前端直接操作服务端的终端所以，一次性到位，直接做个 web termianl用到的库有 xterm、ahooks 等具体过程写在代码注释里，一看就懂上代码 👇","客户端#客户端":"import { useEffect, useLayoutEffect, useRef } from \"react\";\nimport { Terminal } from \"xterm\";\nimport { AttachAddon } from \"xterm-addon-attach\";\nimport { FitAddon } from \"xterm-addon-fit\";\nimport { SearchAddon } from \"xterm-addon-search\";\nimport { WebLinksAddon } from \"xterm-addon-web-links\";\nimport { AdventureTime } from \"xterm-theme\";\nimport { useSize, useWebSocket } from \"ahooks\";\nimport \"xterm/css/xterm.css\";\nimport \"./index.less\";\nconst socketURL = \"ws://127.0.0.1:4000/socket\";\nconst height = 500;\nconst fontSize = 12;\nexport default function HomePage() {\n  const termRef = useRef<any>(null);\n  const containerRef = useRef<any>(null);\n  const insDomRef = useRef<any>(null);\n  // 监听容器尺寸，用于做自适应\n  const size = useSize(containerRef);\n  // 直接使用封装好的useWebSocket\n  const {\n    readyState,\n    sendMessage,\n    latestMessage,\n    disconnect,\n    connect,\n    webSocketIns,\n  } = useWebSocket(socketURL);\n  useEffect(() => {\n    if (!webSocketIns) {\n      return;\n    }\n    // 创建终端实例\n    var term = new Terminal({\n      fontFamily: 'Menlo, Monaco, \"Courier New\", monospace',\n      fontWeight: 400,\n      fontSize,\n      theme: AdventureTime,\n      rows: Math.floor(height / (fontSize + 2)),\n    });\n    // 添加终端插件\n    // An addon for xterm.js that enables attaching to a web socket\n    const attachAddon = new AttachAddon(webSocketIns as WebSocket);\n    // 自适应容器插件\n    const fitAddon = new FitAddon();\n    // 搜索插件\n    const searchAddon = new SearchAddon();\n    // 超链接显示插件\n    const webLinksAddon = new WebLinksAddon();\n    term.loadAddon(attachAddon);\n    term.loadAddon(fitAddon);\n    term.loadAddon(searchAddon);\n    term.loadAddon(webLinksAddon);\n    // 把示例挂载给ref\n    termRef.current = {\n      term,\n      searchAddon,\n      fitAddon,\n    };\n    // render 终端到容器\n    term.open(insDomRef.current);\n    // 适用容器（发现只能适应宽度）\n    fitAddon.fit();\n    return () => {\n      //组件卸载，清除 Terminal 实例\n      term.dispose();\n      termRef.current = null;\n    };\n  }, [webSocketIns]);\n  // 响应容器尺寸副作用\n  useLayoutEffect(() => {\n    if (!size) {\n      return;\n    }\n    // 想做响应式高度、不过这个方法调用报错说rows只能在构造函数里指定，暂时没想到好的办法处理\n    // termRef.current.term.setOption(\n    //   \"rows\",\n    //   Math.floor(size.height / (fontSize + 2))\n    // );\n    termRef.current?.fitAddon?.fit();\n  }, [size]);\n  return (\n    <>\n      <input\n        type=\"text\"\n        placeholder=\"查询关键字\"\n        onChange={(e) => termRef.current.searchAddon?.findNext(e.target.value)}\n        style={{ marginBottom: 10 }}\n      />\n      <div style={{ height, width: \"100%\" }} ref={containerRef}>\n        <div\n          style={{\n            background: \"#1F1D45\",\n            borderRadius: 10,\n            overflow: \"hidden\",\n            padding: 10,\n          }}\n          ref={insDomRef}\n        />\n      </div>\n    </>\n  );\n}\n定制下滚动条，让其透明\n.xterm .xterm-viewport {\n  &::-webkit-scrollbar {\n    width: 10px;\n    height: 10px;\n  }\n  &::-webkit-scrollbar-track {\n    background-color: transparent;\n    border-radius: 10px;\n  }\n  &::-webkit-scrollbar-thumb {\n    background-color: rgba(255, 255, 255, 0.1);\n    border-radius: 10px;\n  }\n}","服务端#服务端":"const express = require(\"express\");\nconst expressWs = require(\"express-ws\");\nconst pty = require(\"node-pty\");\nconst os = require(\"os\");\nconst example = require(\"./data\");\nconst app = express();\nconst port = 4000;\nexpressWs(app);\n// 创建终端子进程\nconst shell = os.platform() === \"win32\" ? \"powershell.exe\" : \"bash\";\nconst term = pty.spawn(shell, [\"--login\"], {\n  name: \"xterm-color\",\n  cols: 80,\n  rows: 24,\n  cwd: process.env.HOME,\n  env: process.env,\n});\n// 暴露socket\napp.ws(\"/socket\", (ws, req) => {\n  term.write(example);\n  // 编码转换\n  term.onData(function (data) {\n    ws.send(data);\n  });\n  // 收到输入\n  ws.on(\"message\", (data) => {\n    term.write(data);\n  });\n  ws.on(\"close\", function () {\n    term.kill();\n  });\n});\napp.listen(port, \"127.0.0.1\", () => {\n  console.log(`Example app listening on port ${port}`);\n});"}},"/posts/other/traffic-lights":{"title":"交通信号灯实现","data":{"":"图：Mako Tsereteli","实现一#实现一":"纯js\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>红绿灯</title>\n    <style>\n      #traffic-light {\n        width: 100px;\n        height: 100px;\n        border-radius: 50%;\n        overflow: hidden;\n        border: 1px solid #f1f1f1;\n      }\n    </style>\n  </head>\n  <body>\n    <div id=\"traffic-light\"></div>\n    <script src=\"index.js\"></script>\n  </body>\n</html>\nconst TRAFFIC_LIGHT_CONFIG = {\n  green: 3000,\n  yellow: 1000,\n  red: 2000,\n};\nfunction delay(duration) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, duration);\n  });\n}\nasync function changeColor(color) {\n  document.getElementById(\"traffic-light\").style.background = color;\n  await delay(TRAFFIC_LIGHT_CONFIG[color]);\n}\n// 通过配置文件来控制顺序\nasync function run() {\n  for (let key in TRAFFIC_LIGHT_CONFIG) {\n    await changeColor(key);\n  }\n  run();\n}\nrun();","实现二#实现二":"纯css\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>红绿灯</title>\n    <style>\n        #traffic-light {\n            width: 100px;\n            height: 100px;\n            border-radius: 50%;\n            background: red;\n            animation: hld 6s step-end infinite;\n        }\n        @keyframes hld {\n            0% { background: red; }\n            50% { background: yellow; }\n            66.67% { background: green; }\n        }\n    </style>\n</head>\n<body>\n    <div id=\"traffic-light\"></div>\n</body>\n</html>"}},"/posts/other/v8gc":{"title":"chrome V8 引擎中的垃圾回收机制","data":{"":"图：Peter Tarka","引言#引言":"JavaScript 可以高效地运行在浏览器和 Nodejs 这两大宿主环境中，是因为背后有强大的 V8 引擎在为其保驾护航，甚至成就了 Chrome 在浏览器中的霸主地位。正是因为有 V8 引擎的存在才会有前端今天的繁荣生态感谢V8 🙇V8 引擎为了追求极致的性能和更好的用户体验，为我们做了太多太多。V8 引擎努力降低整体的内存占用和提升到更高的运行性能。我们来看一下 V8 引擎中的垃圾回收机制","引用法#引用法":"","概念#概念":"判断一个对象的引用数，引用数为 0 就回收，引用数大于 0 就不回收\n// 在堆中创建一个对象，foo是这个对象的引用\nlet foo = { name: \"foo\" };\n// 把引用地址改为null, { name: \"foo\" }对象在堆中没有被栈中引用，那么这块堆中的内存就会被回收\nfoo = null;","缺陷#缺陷":"如果对象之间有相互引用关系，并且引用关系一直存在，那么就不会被回收，从而造成内存泄漏\nfunction fn() {\n  const obj1 = {};\n  const obj2 = {};\n  obj1.a = obj2;\n  obj2.a = obj1;\n}\nfn();","标记法#标记法":"标记法就是，将可达的对象标记起来，不可达的对象当成垃圾回收。就是从初始的根对象（window 或者 global）的指针开始，向下搜索子节点，子节点被搜索到了，说明该子节点的引用对象可达，并为其进行标记，然后接着递归搜索，直到所有子节点被遍历结束。那么没有被遍历到节点，也就没有被标记，也就会被当成没有被任何地方引用，就可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。","javascript-内存管理#JavaScript 内存管理":"1、分配给使用者所需的内存2、使用者拿到这些内存，并使用内存3、使用者不需要这些内存了，释放并归还给系统\nvar name = \"john\";\nvar obj = { name: \"john\" };\nname 和 obj 是使用者\n基础数据类型：拥有固定的大小，值保存在栈内存里，可以通过值直接访问\n引用数据类型：大小不固定(可以加属性)，栈内存中存着指针，指向堆内存中的对象空间，通过引用来访问\n由于栈内存所存的基础数据类型大小是固定的，所以栈内存的内存都是操作系统自动分配和释放回收的\n由于堆内存所存大小不固定，系统无法自动释放回收，所以需要 JS 引擎来手动释放这些内存","分代回收#分代回收":"在 JavaScript 中，对象存活周期分为两种情况\n存活周期很短：经过一次垃圾回收后，就被释放回收掉\n存活周期很长：经过多次垃圾回收后，他还存在，赖着不走\nV8 将堆分为两个空间，一个叫新生代，一个叫老生代，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方新生代通常只有 1-8M 的容量，而老生代的容量就大很多了。对于这两块区域，V8 分别使用了不同的垃圾回收器和不同的回收算法，以便更高效地实施垃圾回收\n副垃圾回收器 + Scavenge 算法：主要负责新生代的垃圾回收\n主垃圾回收器 + Mark-Sweep && Mark-Compact 算法：主要负责老生代的垃圾回收","新生代#新生代":"在 JavaScript 中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。在新生代中，主要使用 Scavenge（清道夫）算法进行垃圾回收，Scavenge 算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。Scavange 算法将新生代堆分为两部分，分别叫 from-space 和 to-space，工作方式也很简单，就是将 from-space 中存活的活动对象复制到 to-space 中，并将这些对象的内存有序的排列起来，然后将 from-space 中的非活动对象的内存进行释放，完成之后，将 from space  和 to space 进行互换，这样可以使得新生代中的这两块区域可以重复利用。\n1、标记活动对象和非活动对象\n2、复制 from-space 的活动对象到 to-space 中并进行排序\n3、清除 from-space 中的非活动对象\n4、将 from-space 和 to-space 进行角色互换，以便下一次的 Scavenge 算法垃圾回收\n通过可达性进行活动对象的判断在新生代中，还进一步进行了细分。\n分为 nursery（托儿所小班） 子代和 intermediate（托儿所中班） 子代两个区域，一个对象第一次分配内存时会被分配到新生代中的 nursery 子代，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们将此对象移动到 intermediate 子代，在经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升\n很形象，顽固的老油条我来单独处理你，别在托儿所上了，让小学老师来收拾你 🤣 😎","老生代#老生代":"新生代空间的对象，身经百战之后，留下来的老对象，成功晋升到了老生代空间里，由于这些对象都是经过多次回收过程但是没有被回收走的，都是一群生命力顽强，存活率高的对象，所以老生代里，回收算法不宜使用 Scavenge 算法，为啥呢，有以下原因：Scavenge 算法是复制算法，反复复制这些存活率高的对象，没什么意义，效率极低\nScavenge 算法是以空间换时间的算法，老生代是内存很大的空间，如果使用 Scavenge 算法，空间资源非常浪费，得不偿失啊。。所以老生代里使用了 Mark-Sweep 算法(标记清理)和 Mark-Compact 算法(标记整理)套路和之前一样\nMark-Sweep 算法(标记清理)\n标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记\n清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象\nMark-Compact 算法(标记整理)\n把内存空间整理一下，就像文件夹按网格排序一样","全停顿stop-the-world#全停顿(Stop-The-World)":"说完V8的分代回收，咱们来聊聊一个问题。JS代码的运行要用到JS引擎，垃圾回收也要用到JS引擎，那如果这两者同时进行了，发生冲突了咋办呢？答案是，垃圾回收优先于代码执行，会先停止代码的执行，等到垃圾回收完毕，再执行JS代码。这个过程，称为全停顿\n由于新生代空间小，并且存活对象少，再配合Scavenge算法，停顿时间较短。但是老生代就不一样了，某些情况活动对象比较多的时候，停顿时间就会较长，使得页面出现了卡顿现象。","orinoco奥里诺科优化#Orinoco（奥里诺科）优化":"orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，它提出了增量标记、懒性清理、并发、并行的优化方法。","增量标记incremental-marking#增量标记(Incremental marking)":"咱们前面不断强调了先标记，后清除，而增量标记就是在标记这个阶段进行了优化。我举个生动的例子：路上有很多垃圾，害得路人都走不了路，需要清洁工打扫干净才能走。前几天路上的垃圾都比较少，所以路人们都等到清洁工全部清理干净才通过，但是后几天垃圾越来越多，清洁工清理的太久了，路人就等不及了，跟清洁工说：“你打扫一段，我就走一段，这样效率高”。\n大家把上面例子里，清洁工清理垃圾的过程——标记过程，路人——JS代码，一一对应就懂了。当垃圾少量时不会做增量标记优化，但是当垃圾达到一定数量时，增量标记就会开启：标记一点，JS代码运行一段，从而提高效率非常像react fiber架构，任务纤维化","惰性清理lazy-sweeping#惰性清理(Lazy sweeping)":"上面说了，增量标记只是针对标记阶段，而惰性清理就是针对清除阶段了。在增量标记之后，要进行清理非活动对象的时候，垃圾回收器发现了其实就算是不清理，剩余的空间也足以让JS代码跑起来，所以就延迟了清理，让JS代码先执行，或者只清理部分垃圾，而不清理全部。这个优化就叫做惰性清理\n整理标记和惰性清理的出现，大大改善了全停顿现象。但是问题也来了：增量标记是标记一点，JS运行一段，那如果你前脚刚标记一个对象为活动对象，后脚JS代码就把此对象设置为非活动对象，或者反过来，前脚没有标记一个对象为活动对象，后脚JS代码就把此对象设置为活动对象。总结起来就是：标记和代码执行的穿插，有可能造成对象引用改变，标记错误现象。这就需要使用写屏障技术来记录这些引用关系的变化","并发concurrent#并发(Concurrent)":"并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行写屏障操作。","并行#并行":"并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。","总结#总结":"我们在写react时有一句俗语，“遇事不决加一层”， 同样，在性能优化方面，总是绕不开 “遇事不决加一个线程” ，并发、协程的解决问题， 纤维化任务等。程序世界果然好多套路都是相通的！"}},"/posts/other/vim":{"title":"Vim大法好","data":{"":"图：Amrit Pal Singh","#":"","跳行#跳行":"number","按字符光标移动#按字符光标移动":"h/l                       左/右 移动一个字符\n4l                        向右 4 个字符","基础操作#基础操作":"ZZ 或 :wq                 保存并退出\n:e!                       恢复到上一次存储的文件内容\n:w pathname/filename      写入到其他文件中\n:rf pathname/filename     删除其他文件\n:!ls pathname             查看其他目录使用情况\n:sh -> ctrl-d 或 exit     创建对应的 shell 执行其任务后再返回\nctrl-z -> fg              暂停 vi 后执行对应的任务后再返回","按行光标移动#按行光标移动":"0                         移动到行首\n$                         移动到行尾\n^                         移到当前行第一个非空格处\n10|                       移到当前行第 10 列\nj/k                       上一行/下一行\n2j                        向上移动 2 行\nG                         移动到文件的结尾\n1G                        移动到文件的第一行\nctrk-g                    屏幕底部显示信息, 包含行号, 文件总行数, 当前位置占全文的百分比","按照文本块移动#按照文本块移动":"w                        移动一个单词, 包含符号与标点\nW                        移动一个单词, 不包含符号与标点\n2w                       移动两个单词\nb                        倒退一个单词, 包含符号与标点\nB                        倒退一个单词, 不好干符号与标点\ne                        移到单词的尾部\nE                        移到单词的尾部, 忽略标点符号\n(                        移到当前句子的开头, 标点符号后有两个空格或者一行的最后一个非空格字符时候为一个句子\n)                        移到下一个句子的开头\n3)                       向上移动 3 个句子\n{                        移到当前这一段的开头, 段落指的是空白行下的文本\n}                        移到下一段的开头\n[[                       移到当前这一节的开头\n]]                       移到下一节的开头","简单的文件编辑#简单的文件编辑":"i                        insert, 插入\na                        add, 添加\nc                        change, 更改\nd                        delete, 删除后放到缓冲区\np                        paste, 粘贴, d -> p 可以移动行\ny                        复制\ncw                       表示更改整个单词\nx                        删除一个字符\nr                        重写改写一个字符","添加文本#添加文本":"a                        光标之后添加\nA                        行结尾添加\ni                        光标之前添加\nI                        行开头添加\no                        光标位置下一行打开新行添加\nO                        光标位置上一行打开新行添加","修改文本-需告知有多少文本要修改-可结合光标移动命令使用#修改文本, 需告知有多少文本要修改, 可结合光标移动命令使用":"cw                       光标到单词结尾要修改, 因此可以用英语单词的部分修改, 只要光标停留在需要修改的开始位置即可\nc2b                      光标往前 2 个字符\nc$ 或 C                  光标到本行结尾\nc0                       光标到此行开头\ncc                       修改整行文本","替换文本#替换文本":"r                        替换一个字符\n2r                       同时替换两个字符\nR                        替换整行, 逐渐覆盖\ns                        替换一个字符, 先删除字符, 并进入插入模式, 因此可以用于将一个字符替换为多个的情况\nS                        替换整行, 先删除整行, 并进入插入模式","修改大小写#修改大小写":"~                        修改一个字符为大写或者小写\n3~                       修改三个字符为大写或者小写","删除文本-需要告知有多少文本需要删除-可结合光标移动命令使用#删除文本, 需要告知有多少文本需要删除, 可结合光标移动命令使用":"dw                      删除光标到单词尾部的字符, 包含单词尾部的空白\nde                      删除光标到单词本身尾部的字符, 不包含尾部后边的空白\ndE                      删除光标到单词尾部, 包含标点符号\ndb                      向前删除一个字符\nd0                      删除光标到行开头的字符\nd$ 或 D                 删除光标到结尾的字符\ndd                      删除一整行字符\n2dd                     删除两行字符\nx                       x-ing out 打印机消除的意思, 删除一个字符\n2x                      删除两个字符\nX                       删除光标之前的一个字符\n2X                      删除光标之前的两个字符","误删恢复#误删恢复":"u                       撤销上一个命令\n3p                      将第三个缓冲区放到下一行, 默认保留九个缓冲区\nctrl-r                  重做一次撤销操作","移动文本-采用先删除后放置的方法#移动文本, 采用先删除后放置的方法":"p                       将缓冲区文本放到光标之后, 单行则放到同一行, 多行缓冲区则另起一行\nP                       将缓冲区文本放到光标之前\nxp                      对调两个字符","复制文本-需要告知有多少文本需要复制-可结合光标移动命令使用#复制文本, 需要告知有多少文本需要复制, 可结合光标移动命令使用":"yw                      复制光标到单词尾部的字符\ny0                      复制光标到行开头的字符\ny$                      复制光标到行结尾的字符\nyy 或 Y                  复制整行内容","重复命令-每个命令均会被存储到一个临时的缓冲区-直到发出下一个命令为主#重复命令, 每个命令均会被存储到一个临时的缓冲区, 直到发出下一个命令为主":".                       重复上一次的命令","合并行#合并行":"J                        合并两行, 将当前行与下一行合并\n3J                       合并三行","编辑命令#编辑命令":"文本对象\t更改\t删除\t复制\t单个字符\tr\tx\tyl\t五个字符\t5s\t5x\ty5l\t一个单词\tcw\tdw\tyw\t两个单词, 不包含标点符号\tc2W\td2W\ty2W\t后退三个单词\tc2b\td2b\ty2b\t一整行\tcc\tdd\tyy\t到一行的结尾\tc$ 或 C\td$ 或 D\ty$\t到一行的开头\tc0\td0\ty0","光标移动命令#光标移动命令":"移动\n命令\n←↓↑→\nhjkl\n下一行第一个字符\n+\n上一行第一个字符\n-\n单词结尾\ne 或 E\n往前一个单词\nw 或 W\n往后一个单词\nb 或 B\n到一行的结尾\n$\n到一行的开头\n0\n往缓冲区放置文本\np 或 P\n保存编辑结果并离开\nZZ\n不保存编辑结果并离开\n:q!\n光标所在位置插入文本\ni\n一行开头插入文本\nI\n光标所在位置附加文本\na\n一行最后附加文本\nA\n光标下一行打开新行\no\n光标上一行打开新行\nO\n删除一行并替换文本\nS\n新文本覆盖现有文本\nR\n合并当前行与下一行\nJ\n重复上一个动作\n.\n撤销上一个动作\nu","滚动屏幕#滚动屏幕":"z-enter               移动当前行到屏幕顶端并滚动屏幕\nz.                    移动当前行到屏幕中心并滚动屏幕\nz-                    移动当前\nctrl-f                forward, 向上滚动一屏\nctrl-b                backward, 向下滚动一屏\nctrl-u                up, 向上滚动半屏\nctrl-d                down, 向下滚动半屏\n100z                  将第一百行滚动到屏幕顶端","光标在屏幕中移动#光标在屏幕中移动":"H                    high, 移到屏幕顶端的行\nM                    middle, 移到屏幕中间的行\nL                    low, 移到屏幕底部的行\n10H                  移到屏幕顶端往下的第十行\n10L                  移到屏幕底部往上的第十行","根据搜索模式来移动#根据搜索模式来移动":"/                    向下匹配搜索\n?                    向上匹配搜索\nn                    往同一个方向重复搜索\nN                    往相反方向重复搜索","在当前行搜索#在当前行搜索":"fx                   光标移到本行出现下一个 x 字符的地方\n2fx                  搜索本行第二次出现 x 字符的地方\nFx                   光标移到本行出现上一个 x 字符的地方\ntx                   光标移到本行出现下一个 x 字符的地方的前一个字符\nTx                   光标移到本行出现上一个 x 字符的地方的后一个字符\n;                    重复上一个搜索命令, 方向相同\n,                    重复下一个搜索命令, 方向相反\n''                   回到上一个包含记号的行开头\n``                   回到上一个记号或上下文","百花齐放的打开文件#百花齐放的打开文件":"vi  +n  file        在第 n 行打开文件\nvi  + file          在最后一行打开文件\nvi  +/pattern file  在第一个出现 pattern 的地方打开文件\nvi  -R  file        只读模式显示文件\nvi  -r  file        恢复编辑缓冲区","缓冲区使用#缓冲区使用":"# vi 会将最后 9 次的删除操作保存在编号的缓冲区中, 1-9 的缓冲区, 1 表示最后一次的删除\n# vi 会将复制的文本放在按字母标识的缓冲区中, a-z 的缓冲区\n\"1p                恢复最后一次的删除内容, 光标之后插入\n\"1pu.              逐一将缓冲区内容放置到当前光标之后, u会删除文本, .则重复放置, 不断轮换知道找到所需的文本\n\"dyy               将当前行复制到缓冲区 d 中, \"加上缓冲区名字, 可以用于命名缓冲区\n\"dP                将缓冲区 d 中内容放置到光标之前","对某一处做标记#对某一处做标记":"mx                将当前位置标记成 x\n'x                单引号, 将光标移动到 x 标记所在的第一行\n''                两个单引号, 回到上一个标记或上下文所在行的开头\n`x                反引号, 将光标移到以 x 标记的字符位置\n``                两个反引号, 回到上一个标记或上下文的确切位置","ex-命令#ex 命令":":1p                         打印第 1 行\n:1                          打印第 1 行\n:1,3                        打印 1-3 行\n:1s/GitLab/gitlab           替换第一行的 GitLab 为 gitlab\n:s/GitLab/gitlab            在当前行替换 GitLab 为 gitlab\n:vi                         ex 模式下转换为 vi 模式\nQ                           vi 模式下转换为 ex 模式\n:1,3d                       delete 可简写为 d, 删除第 1 行到第 3 行\n:1m2                        move 可简写为 m, 将第 1 行移到第 2 行之后\n:1co2                       copy 可简写为 co, 与 t 同意, 将第 1 行复制到第 2 行之后\n:set nu                     number 可简写为 nu, 设置显示行号\n:set nonu                   no number 可简写为 nobu, 禁用显示行号\n:1,10#                      暂时显示 1-10 行的行号\n:=                          列出文件的总行数\n:.=                         列出当前所在行的行号\n:/pattern/=                 列出 patter 第一次出现的行号\n:.                          表示当前这一行\n:$                          表示文件最后一行\n:%                          表示文件中每一行\n:.,+20#                     显示当前这一行以及向下 20 行直接的行号","ex-搜索模式#ex 搜索模式":":/pattern/d                 删除下一个包含 pattern 的行\n:.,/pattern/d               删除当前行以及第一个包含 pattern 的行\n:100, +5 p                 表示打印 当前行+5 到 100 行之间的内容\n:100;+5 p                  打印 100-105 行之间的内容, 使用分号时候第一行地址会被当做当前光标的位置\n:/pattern;+10 p            显示包含 pattern 行的后十行内容\n:g/pattern                寻找文件中最后一次出现 pattern 的地方, g 表示全局, 可以让搜索模式显示并包含这个模式的所有行\n:g/pattern/p              寻找并显示所有包含 pattern 的行\n:g!/pattern/nu            寻找并显示不包含 pattern 的行, 并展示对应的行号\n:1,10g/pattern            寻找 1-10 行中包含 pattern 的行\n:1d | s/This/this         删除第一行, 并在当前行(原来的第二行)中替换 This 为 this\nex 的保存于离开文件\n:w                        将缓冲区内容写入到文件中, 但不离开\n:q                        离开编辑器\n:wq                       写入并离开,即使文件无任何修改也一样会写入\n:x                        写入文件同时离开, 仅当有修改时才会写入\n:!                        忽略警告, vi 会保护现有文件, 当需要将缓冲区内容写入到文件中会有警告产生\n:w newfile               将缓冲区内容写入到新的文件, 原有的文件不会改变\n:1,10w newfile           将缓冲区中 1-10 写入到新的文件\n:1,10w >> newfile        将缓冲区 1-10 行内容附加到新文件中\n:r newfle                read 可简写为 r, 将新文件内容读出并插入到光标所在位置的下一行\n:2r newfile              将新文件内容插入到第 2 行之后\n:0r newfile              将新文件内容插入到文件开头\nvi 多文件编辑\n:n                      跳转到下一个文件\n:first                  跳转到第一个文件\n:last                   跳转到最后一个文件\n:e filename             启动一个文件, 存在则打开, 不存在则新建, 可以 tab 补全\n:e #                    回到上一个文件, 需要将缓冲区内容写入到文件\n:w %.new                写入到当前文件, % 表示当前文件的文件名\nctrl-^                  效果同 :e # 切换到上一个文件\n\"f6yy -> :w -> :e new.txt -> \"fp  ===>  复制光标以及后 6 行内容复制到缓冲区 f 中 -> 缓冲区写入到文件 -> 切换到 new.txt 文件 -> 复制缓冲区 f 中内容到光标后\n:1,6ya a  -> :pu a    ===>    拖拽 1-6 行到缓冲区 a  -> 将缓冲区 a 中内容放置到当前光标之后, ya 为拖动命令,pu 为放置命令","全局替换#全局替换":":s/old/new                     substitute 可缩写为 s, 将当前这一行第一个出现模式 old 的字符串替换为 new, /用来分割各个命令, 最后一个/可省略\n:s/old/new/g                   将当前这一行中所有的 old 替换为 new, g表示该行中所有模式, :g 表示文件中每一行\n:1,10s/old/new/g               将 1-10 行中所有的 old 替换为 new\n:%s/old/new/g                  通 :1,$s/old/new/g , 将整个文件的 old 替换为 new    \n:1,10s/old/new/gc              替换 1-10 行中所有的 old, 每一个都需要确认\n:g/pattern/s/old/new/g         遇到包含 pattern 的行时候将 old 替换为 new\n:g/pattern/s//new/g            遇到包含 pattern 的行将 pattern 替换为 new, 此时直接用 :%s/pattern/new/g 即可","搜索模式的元字符#搜索模式的元字符":".                    匹配任何单一字符, 包含空格, 除掉换行符\n*                    匹配出位于此符号前的单一字符,该字符可以出现 0 到多个\n^                    表示后边的正则表达式必须位于行开头\n$                    表示正则表达式必须位于行结尾\n\\                    转义字符, 例如 \\. 表示匹配 . 而不是任意字符\n[]                   匹配出方括号中任意一个字符, [^a-z] 则表示匹配不是小写字母的字符, [] 中的 ^ 表示取反\n\\(\\)                 将\\(\\)之间模式匹配到的内容保留到缓冲区, 一般可以保留一行中 9 个模式, 例如 \\(That\\) or \\(this\\) 则将 That 保留到缓冲区 1, this 到 2\n\\<\\>                 匹配某些字符开头的单词, 例如 \\<ac 只会匹配出以 ac开头的单词, 而 ac\\> 只会匹配出以 ac 结尾的单词\n~                    匹配任何上一次搜索所使用的正则表达式, 只能用于正则搜索, 即 /\n[:alnum:]            字母与数字字符\n[:alpha:]            字母字符\n[:blank:]            空格与指标符\n[:cnctrl:]           控制字符\n[:digit:]            数字字符\n[:graph:]            可打印的与可见的(不包括空格)字符, 不包括空白\n[:print:]            可打印的字符, 包括空白\n[:punct:]            标点符号\n[:space:]            空白字符\n[:upper:]            大写字符\n[:xdigit:]           十六进制数字\n\\n                   利用\\(\\)存储的第 n 个模式的文字做代换, n 表示数字 1-9, 之前存储的模式是从左到右来计算\n\\                    将后面一个字符当做普通字符来看到\n&                    用在替换字符串中时, 替换为搜索模式匹配出的完整模式, 例如 :%s/AAA/&, bbb 则替换字符串为 AAA, bbb\n\\u 或 \\l             使替换字符串下一个字符变为大写或小写\n\\U 或 \\L 或 \\e 或\\E   将后边的字符串或直到出现 \\e 或 \\E 为止, 全部替换为大写或者小写","set-命令#:set 命令":":set option            打开选项\n:set nooption          关闭选项\n:set ic                指定搜索模式忽略大小写\n:set noic              指定搜索模式区分大小写\n:set window=20         设置屏幕窗口显示的行数\n:set wrapmargin        设置右边界距离, 用于自动换行\n:set all               检查 vi 正在使用的选项\n:set option?           查询指定选项的当前值\nnoignorecase           搜索时区分大小写\nwrapscan               回到文件开头继续搜索, 表示在文件中任何一处开始搜索, 都可以找到符合的文本\nmagic                  模式匹配时候辨识通配符\nautoindent             设置自动缩排, ctrl-t 下一层缩进, ctrl-d 上一层缩进\nshiftwith=4            设置默认向左或向右为 4 个空格\ntabstop                设置 tab 占用 4 个空格\nlist                   显示控制字符\nshowmatch              显示对应匹配的括号, 插入模式会有效果\nmourse=a               多窗口下, 鼠标跟随","exrc-文件-无需--即可-因为读入-exrc-文件的是-ex-读入的#exrc 文件, 无需 : 即可, 因为读入 exrc 文件的是 ex 读入的":"主目录下的.exrc 文件中添加 set exrc 则 ex 可以读取当前目录下的.exrc 文件\n:so .otherexrc        source 可缩写为 so, 加载其他的 exrc 文件","执行-unix-命令#执行 unix 命令":":!command             ! 会告诉 ex 创建一个shell, 且后续文本视为 uninx 命令\n:!date                显示系统时间\n:sh                   创建一个 shell, 可以执行多个 uninx 命令, 结束时按 ctrl-d 回到 vi:r !command           read 可简写为 r, 可与 uninx 命令结合, 把 uninx命令的结果读入到文件中\n:1r !date             将系统时间读入到文件第一行:1,10 !sort           将 1-10 行排序\n!)command             将下一句内容传递给 command","单词缩写-插入模式定义宏#单词缩写, 插入模式定义宏":"ab mb Mobiuspace            设置 Mobiuspace 的缩写为 mb, 在 vi 中输入时会自动展开, 缩写的单词不能出现在所代表的词组的词尾\n命令缩写, 命令模式定义宏\n:map x sequence             定义字符 x 映射到编辑命令 sequence\n:unmap x                    取消定义给 x 的编辑命令 sequence\n:map                        列出所有被映射的字符\n:map v dwelp                dw 删除一个单词, e 移到下一个单词结尾, l 向右移动一个空格, p 将删除的单词放置到新位置\n:map! - dw                  命令模式下强制覆盖 - 为 dw 命令","使用-tag-uninx-有-ctags-命令可以与-vi-的tag命令一起使用#使用 tag, uninx 有 ctags 命令可以与 vi 的:tag命令一起使用":":ctags *.c                 创建描述所有 c源代码文件的 tags 文件\n:tag name                  在 tags 文件中寻找 name 的定义","vim-启动#vim 启动":"vim -d file1 file2        diff 缩写为 d, 以 diff 模式启动编辑文件\nvim -o file1 file2        所有文件均各自打开窗口","vim-多窗口编辑#vim 多窗口编辑":":split                    水平分割当前窗口\nctrl-w -> s               水平分割当前窗口\n:new                      水平分割当前窗口, 会自动适配一些配置\n:vsplit                   垂直分割当前窗口\n:[n]split [++opt] [cmd] [file]        n 为 vim 指定新窗口显示的行数\nctrl-w -> ctrl-j          移动到下一个窗口\nctrl-w -> ctrl-k          移动到上一个窗口\nctrl-w -> ctrl-h          移动到当前窗口左侧\nctrl-w -> ctrl-l          移动到当前窗口右侧\nctrl-w -> ctrl-p          移动到最后一次访问的窗口\nctrl-w -> ctrl-t          移动到最左上角的窗口\nctrl-w -> ctrl-b          移动到最右下角的窗口\nctrl-w -> +               当前窗口增加一行\n:resize +2                当前窗口增加两行","vim-缓冲区命令#vim 缓冲区命令":":ls                     列出缓冲区文件"}},"/posts/react/15-16":{"title":"React 15 和 React 16 的区别","data":{"":"图：Amrit Pal Singh","结构#结构":"","react15的架构可以分为两层#react15的架构可以分为两层：":"Reconciler（协调器）— 找出需要更新的组件，以及标识出如何更新\nRenderer（渲染器）— 负责将变化后的组件渲染到页面上","react16的架构可以分为三层#react16的架构可以分为三层：":"Scheduler（调度器）— 调度任务的优先级，高级优先级的优先进入Reconciler阶段\nReconciler（协调器）— 找出需要更新的组件，以及标识出如何更新\nRenderer（渲染器）— 负责将变化后的组件渲染到页面上\n浏览器的16.6ms机制对人眼来说，正常流畅的刷新率为60hz，即60帧，即浏览器16.6ms刷新一次。我们知道js可以操作dom元素，所以浏览器的GUI线程和js线程是互斥的。js的执行和浏览器的绘制、布局不能同时进行。所以在每16.6ms内浏览器要执行如下操作：\nJS脚本执行 ------ 浏览器样式布局 ------ 浏览器样式绘制\n如果js脚本执行时间过长，超过16.6ms，这次刷新中浏览器绘制和布局就无法执行，这就会造成人眼可识别的卡顿，发现操作时浏览器没有“实时”做出反应。如：对于用户在输入框输入内容这个行为来说，就体现为按下了键盘按键但是页面上不实时显示输入。","区别#区别":"react15的reconciler是stack-reconciler。即是采用递归形式工作的，是同步的，在生成虚拟dom树并diff过程中是无法中断的。这样在组件层级过深时，会造成js执行时间过长，浏览器无法布局和绘制，造成丢帧。react16的reconciler是fiber-reconciler。即采用的异步可中断更新代替react15的同步更新，react16的scheduler调度器会告诉reconciler，浏览器是否有空闲时间执行js脚本。这样就不会影响浏览器的绘制和布局工作。不会丢帧。在react16中，原来的虚拟DOM,因其结构已不能满足异步可中断更新的需求，改而采用新的结构Fiber。虚拟dom节对应变为Fiber节点，虚拟dom树对应变为Fiber树。"}},"/posts/react/class-function":{"title":"React class组件和function组件异同","data":{"":"图：Nguyen Nhut","相同点#相同点":"都可以接收props返回react元素","不同点#不同点":"","编程思想#编程思想":"类组件需要创建实例，面向对象，函数组件不需要创建实例，接收输入，返回输出，函数式编程","内存占用#内存占用":"类组建需要创建并保存实例，占用一定的内存","值捕获特性#值捕获特性":"函数组件具有值捕获的特性","可测试性#可测试性":"函数组件方便测试","状态#状态":"类组件有自己的状态，函数组件没有，只能通过useState","生命周期#生命周期":"类组件有自己的生命周期，函数组件没有，可以使用useEffect实现类似的生命周期","逻辑复用#逻辑复用":"类组件继承，用HOC, 会导致逻辑混乱，嵌套，组合优于继承，函数组件hook逻辑复用","跳过更新#跳过更新":"shouldComponentUpdate PureComponent, React.memo","发展未来#发展未来":"函数组件未来成为主流，屏蔽this、规范、复用、适合时间分片和渲染"}},"/posts/react/fiber":{"title":"React Fiber","data":{"":"图：Nguyen Nhut","fiber是什么#Fiber是什么？":"Fiber是一个js对象，承载了节点信息、优先级、updateQueue, 是一个工作单元","作用#作用":"工作单元 任务分解 ：Fiber最重要的功能就是作为工作单元，保存原生节点或者组件节点对应信息（包括优先级），这些节点通过指针的形似形成Fiber树\n增量渲染：通过jsx对象和current Fiber的对比，生成最小的差异补丁fiberEffectList，应用到真实节点上\n根据优先级暂停、继续、排列优先级：Fiber节点上保存了优先级，能通过不同节点优先级的对比，达到任务的暂停、继续、排列优先级等能力，也为上层实现批量更新、Suspense提供了基础\n保存状态 : Fiber能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是hooks","fiber特性#Fiber特性":"Fiber双缓存可以在构建好workInProgress Fiber树之后切换成current Fiber, 内存中直接一次性切换，提高了性能\nFiber的存在使异步更新成为了可能，作为工作单元，可以在时间片内执行工作，没时间了交还执行权给浏览器，下次时间片继续执行之前的暂停之后返回FiberRootNode\nFiber可以在reconcile的时候进行相应的diff更新，让最后的更新应用在真实的节点上","与jsx的关系#与jsx的关系":"在mount时通过jsx对象（调用createElement的结果）调用createFiberFromElement生成Fiber update时通过reconcileChildFibers或reconcileChildrenArray对比新jsx和老的Fiber(current Fiber)生成新的Fiber树","数据结构#数据结构":"function FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  //作为静态的数据结构 保存节点的信息 2\n  this.tag = tag;//对应组件的类型\n  this.key = key;//key属性\n  this.elementType = null;//元素类型\n  this.type = null;//func或者class\n  this.stateNode = null;//真实dom节点\n  //作为fiber数架构 连接成fiber树\n  this.return = null;//指向父节点\n  this.child = null;//指向child\n  this.sibling = null;//指向兄弟节点\n  this.index = 0;\n  this.ref = null;\n  //用作为工作单元 来计算state\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n  this.mode = mode;\n    \n\t//effect相关\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n  this.firstEffect = null;\n  this.lastEffect = null;\n  //优先级相关的属性\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n  //current和workInProgress的指针\n  this.alternate = null;\n}","fiber双缓存#Fiber双缓存":"","mount时#mount时":"mount时，current Fiber只有一个节点，rootFier\n然后根据jsx创建workInProgress Fiber\n创建完成workInProgress后直接把fiberRoot的current指针指向workInProgress，即这时的workInProgress变为了currentFiber","update时#update时":"根据最新的jsx开始构建workInProgressFiber\n构建时同时和currentFiber做diff, 找出不同的节点，生成fiberEffectList\n构建完成workInProgressFiber，把currentFiber切换为workInProgressFiber，等待下一次更新\n把fiberEffectList交给renderer commit阶段 进行真实节点更新渲染"}},"/posts/react/hook-state":{"title":"Hook原理——状态Hook","data":{"":"图：Nguyen Nhut\nfunction 类型的 fiber 节点, 它的处理函数是 updateFunctionComponent, 其中再通过 renderWithHooks 调用 function.\n在 function 中, 通过 Hook Api(如: useState, useEffect)创建 Hook 对象.状态 Hook 实现了状态持久化(等同于 class 组件维护 fiber.memoizedState).副作用 Hook 则实现了维护 fiber.flags,并提供副作用回调(类似于 class 组件的生命周期回调)\n多个 Hook 对象构成一个链表结构, 并挂载到 fiber.memoizedState 之上.\nfiber 树更新阶段, 把 current.memoizedState 链表上的所有 Hook 按照顺序克隆到 workInProgress.memoizedState 上, 实现数据的持久化.","创建-hook#创建 Hook":"在 fiber 初次构造阶段, useState 对应源码 mountState, useReducer 对应源码 mountReducermountState:\nfunction mountState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  // 1. 创建hook\n  const hook = mountWorkInProgressHook();\n  if (typeof initialState === 'function') {\n    initialState = initialState();\n  }\n  // 2. 初始化hook的属性\n  // 2.1 设置 hook.memoizedState/hook.baseState\n  // 2.2 设置 hook.queue\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = (hook.queue = {\n    pending: null,\n    dispatch: null,\n    // queue.lastRenderedReducer是内置函数\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState: any),\n  });\n  // 2.3 设置 hook.dispatch\n  const dispatch: Dispatch<\n    BasicStateAction<S>,\n  > = (queue.dispatch = (dispatchAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  // 3. 返回[当前状态, dispatch函数]\n  return [hook.memoizedState, dispatch];\n}\nmountReducer:\nfunction mountReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  // 1. 创建hook\n  const hook = mountWorkInProgressHook();\n  let initialState;\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = ((initialArg: any): S);\n  }\n  // 2. 初始化hook的属性\n  // 2.1 设置 hook.memoizedState/hook.baseState\n  hook.memoizedState = hook.baseState = initialState;\n  // 2.2 设置 hook.queue\n  const queue = (hook.queue = {\n    pending: null,\n    dispatch: null,\n    // queue.lastRenderedReducer是由外传入\n    lastRenderedReducer: reducer,\n    lastRenderedState: (initialState: any),\n  });\n  // 2.3 设置 hook.dispatch\n  const dispatch: Dispatch<A> = (queue.dispatch = (dispatchAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  // 3. 返回[当前状态, dispatch函数]\n  return [hook.memoizedState, dispatch];\n}\nmountState 和 mountReducer 逻辑简单: 主要负责创建 hook, 初始化 hook 的属性, 最后返回[当前状态, dispatch 函数].唯一的不同点是 hook.queue.lastRenderedReducer:\nmountState 使用的是内置的 basicStateReducer\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === \"function\" ? action(state) : action;\n}\nmountReducer 使用的是外部传入自定义 reducer\n可见 mountState 是 mountReducer 的一种特殊情况, 即 useState 也是 useReducer 的一种特殊情况, 也是最简单的情况.useState 可以转换成 useReducer:\nconst [state, dispatch] = useState({ count: 0 });\n// 等价于\nconst [state, dispatch] = useReducer(\n  function basicStateReducer(state, action) {\n    return typeof action === \"function\" ? action(state) : action;\n  },\n  { count: 0 }\n);\n// 当需要更新state时, 有2种方式\ndispatch({ count: 1 }); // 1.直接设置\ndispatch((state) => ({ count: state.count + 1 })); // 2.通过回调函数设置\n可见, useState 就是对 useReducer 的基本封装, 内置了一个特殊的 reducer(后文不再区分 useState, useReducer, 都以 useState 为例).创建 hook 之后返回值[hook.memoizedState, dispatch]中的 dispath 实际上会调用 reducer 函数.","状态初始化#状态初始化":"在useState(initialState)函数内部, 设置hook.memoizedState = hook.baseState = initialState;, 初始状态被同时保存到了hook.baseState,hook.memoizedState中.\nhook.memoizedState: 当前状态\nhook.baseState: 基础状态, 作为合并 hook.baseQueue 的初始值(下文介绍).\n最后返回[hook.memoizedState, dispatch], 所以在 function 中使用的是 hook.memoizedState.","状态更新#状态更新":"有如下组件\nimport { useState } from \"react\";\nexport default function App() {\n  const [count, dispatch] = useState(0);\n  return (\n    <button\n      onClick={() => {\n        dispatch(1);\n        dispatch(3);\n        dispatch(2);\n      }}\n    >\n      {count}\n    </button>\n  );\n}\n初次渲染时 count = 0, 这时 hook 对象的内存状态如下:\n点击 button, 通过 dispatch 函数进行更新, dispatch 实际就是 dispatchAction:\nfunction dispatchAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n) {\n  // 1. 创建update对象\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(fiber); // Legacy模式返回SyncLane\n  const update: Update<S, A> = {\n    lane,\n    action,\n    eagerReducer: null,\n    eagerState: null,\n    next: (null: any),\n  };\n  // 2. 将update对象添加到hook.queue.pending队列\n  const pending = queue.pending;\n  if (pending === null) {\n    // 首个update, 创建一个环形链表\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n  queue.pending = update;\n  const alternate = fiber.alternate;\n  if (\n    fiber === currentlyRenderingFiber ||\n    (alternate !== null && alternate === currentlyRenderingFiber)\n  ) {\n    // 渲染时更新, 做好全局标记\n    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n  } else {\n    // ...省略性能优化部分, 下文介绍\n    // 3. 发起调度更新, 进入`reconciler 运作流程`中的输入阶段.\n    scheduleUpdateOnFiber(fiber, lane, eventTime);\n  }\n}\n创建 update 对象, 其中 update.lane 代表优先级(可回顾 fiber 树构造(基础准备)中的 update 优先级).\n将 update 对象添加到 hook.queue.pending 环形链表.\n环形链表的特征: 为了方便添加新元素和快速拿到队首元素(都是 O(1)), 所以 pending 指针指向了链表中最后一个元素.\n发起调度更新: 调用 scheduleUpdateOnFiber, 进入 reconciler 运作流程中的输入阶段.\n本示例中虽然同时执行了 3 次 dispatch, 会请求 3 次调度, 由于调度中心的节流优化, 最后只会执行一次渲染在 fiber 树构造(对比更新)过程中, 再次调用 function, 这时 useState 对应的函数是 updateState\nfunction updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, (initialState: any));\n}\n实际调用 updateReducer.在执行 updateReducer 之前, hook 相关的内存结构如下:\n执行：\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  // 1. 获取workInProgressHook对象\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n  queue.lastRenderedReducer = reducer;\n  const current: Hook = (currentHook: any);\n  let baseQueue = current.baseQueue;\n  // 2. 链表拼接: 将 hook.queue.pending 拼接到 current.baseQueue\n  const pendingQueue = queue.pending;\n  if (pendingQueue !== null) {\n    if (baseQueue !== null) {\n      const baseFirst = baseQueue.next;\n      const pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n  // 3. 状态计算\n  if (baseQueue !== null) {\n    const first = baseQueue.next;\n    let newState = current.baseState;\n    let newBaseState = null;\n    let newBaseQueueFirst = null;\n    let newBaseQueueLast = null;\n    let update = first;\n    do {\n      const updateLane = update.lane;\n      // 3.1 优先级提取update\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // 优先级不够: 加入到baseQueue中, 等待下一次render\n        const clone: Update<S, A> = {\n          lane: updateLane,\n          action: update.action,\n          eagerReducer: update.eagerReducer,\n          eagerState: update.eagerState,\n          next: (null: any),\n        };\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        }\n        currentlyRenderingFiber.lanes = mergeLanes(\n          currentlyRenderingFiber.lanes,\n          updateLane,\n        );\n        markSkippedUpdateLanes(updateLane);\n      } else {\n        // 优先级足够: 状态合并\n        if (newBaseQueueLast !== null) {\n          // 更新baseQueue\n          const clone: Update<S, A> = {\n            lane: NoLane,\n            action: update.action,\n            eagerReducer: update.eagerReducer,\n            eagerState: update.eagerState,\n            next: (null: any),\n          };\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        }\n        if (update.eagerReducer === reducer) {\n          // 性能优化: 如果存在 update.eagerReducer, 直接使用update.eagerState.避免重复调用reducer\n          newState = ((update.eagerState: any): S);\n        } else {\n          const action = update.action;\n          // 调用reducer获取最新状态\n          newState = reducer(newState, action);\n        }\n      }\n      update = update.next;\n    } while (update !== null && update !== first);\n    // 3.2. 更新属性\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = (newBaseQueueFirst: any);\n    }\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n    // 把计算之后的结果更新到workInProgressHook上\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n    queue.lastRenderedState = newState;\n  }\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}\n调用 updateWorkInProgressHook 获取 workInProgressHook 对象\n链表拼接: 将 hook.queue.pending 拼接到 current.baseQueue\n状态计算\nupdate 优先级不够: 加入到 baseQueue 中, 等待下一次 render\nupdate 优先级足够: 状态合并更新属性","性能优化#性能优化":"dispatchAction 函数中, 在调用 scheduleUpdateOnFiber 之前, 针对 update 对象做了性能优化.\nqueue.pending 中只包含当前 update 时, 即当前 update 是 queue.pending 中的第一个 update\n直接调用 queue.lastRenderedReducer,计算出 update 之后的 state, 记为 eagerState\n如果 eagerState 与 currentState 相同, 则直接退出, 不用发起调度更新.\n已经被挂载到 queue.pending 上的 update 会在下一次 render 时再次合并.\nfunction dispatchAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n) {\n  // ...省略无关代码 ...只保留性能优化部分代码:\n  // 下面这个if判断, 能保证当前创建的update, 是`queue.pending`中第一个`update`. 为什么? 发起更新之后fiber.lanes会被改动(可以回顾`fiber 树构造(对比更新)`章节), 如果`fiber.lanes && alternate.lanes`没有被改动, 自然就是首个update\n  if (\n    fiber.lanes === NoLanes &&\n    (alternate === null || alternate.lanes === NoLanes)\n  ) {\n    const lastRenderedReducer = queue.lastRenderedReducer;\n    if (lastRenderedReducer !== null) {\n      let prevDispatcher;\n      const currentState: S = (queue.lastRenderedState: any);\n      const eagerState = lastRenderedReducer(currentState, action);\n      // 暂存`eagerReducer`和`eagerState`, 如果在render阶段reducer==update.eagerReducer, 则可以直接使用无需再次计算\n      update.eagerReducer = lastRenderedReducer;\n      update.eagerState = eagerState;\n      if (is(eagerState, currentState)) {\n        // 快速通道, eagerState与currentState相同, 无需调度更新\n        // 注: update已经被添加到了queue.pending, 并没有丢弃. 之后需要更新的时候, 此update还是会起作用\n        return;\n      }\n    }\n  }\n  // 发起调度更新, 进入`reconciler 运作流程`中的输入阶段.\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n}\n验证demo"}},"/posts/react/hooks":{"title":"Hooks 原理概览","data":{"":"图：Nguyen Nhut","什么是-hook#什么是 Hook?":"Hook 是一个特殊的函数, 它可以让你“钩入” React 的特性. 如, useState 是允许你在 React 函数组件中添加 state 的 Hook.在 v17.0.2 中, 共定义了 14 种 Hook\nexport type HookType =\n  | \"useState\"\n  | \"useReducer\"\n  | \"useContext\"\n  | \"useRef\"\n  | \"useEffect\"\n  | \"useLayoutEffect\"\n  | \"useCallback\"\n  | \"useMemo\"\n  | \"useImperativeHandle\"\n  | \"useDebugValue\"\n  | \"useDeferredValue\"\n  | \"useTransition\"\n  | \"useMutableSource\"\n  | \"useOpaqueIdentifier\";","hook-数据结构#Hook 数据结构":"type Update<S, A> = {\n  lane: Lane,\n  action: A,\n  eagerReducer: ((S, A) => S) | null,\n  eagerState: S | null,\n  next: Update<S, A>,\n  priority?: ReactPriorityLevel,\n};\ntype UpdateQueue<S, A> = {\n  pending: Update<S, A> | null,\n  dispatch: (A => mixed) | null,\n  lastRenderedReducer: ((S, A) => S) | null,\n  lastRenderedState: S | null,\n};\nexport type Hook = {\n  memoizedState: any, // 当前状态\n  baseState: any, // 基状态\n  baseQueue: Update<any, any> | null, // 基队列\n  queue: UpdateQueue<any, any> | null, // 更新队列\n  next: Hook | null, // next指针\n};\nhook.memoizedState: 保持在内存中的局部状态.\nhook.baseState: hook.baseQueue 中所有 update 对象合并之后的状态.\nhook.baseQueue: 存储 update 对象的环形链表, 只包括高于本次渲染优先级的 update 对象.\nhook.queue: 存储 update 对象的环形链表, 包括所有优先级的 update 对象.\nhook.next: next 指针, 指向链表中的下一个 hook.","hook-与-fiber#Hook 与 Fiber":"使用 Hook 最终也是为了控制 fiber 节点的状态和副作用\nexport type Fiber = {\n  // 1. fiber节点自身状态相关\n  pendingProps: any;\n  memoizedProps: any;\n  updateQueue: mixed;\n  memoizedState: any;\n  // 2. fiber节点副作用(Effect)相关\n  flags: Flags;\n  nextEffect: Fiber | null;\n  firstEffect: Fiber | null;\n  lastEffect: Fiber | null;\n};\n使用 Hook 的任意一个 api, 最后都是为了控制上述这几个 fiber 属性.我们之前有大概了解了 Fiber,那么看下 Fiber 和 Hook 有什么关系吧，在这之前我们还是以一个组件做示例\nfunction App() {\n  // 1. useState\n  const [count, setCount] = useState(0);\n  // 2. useEffect\n  useEffect(() => {\n    console.log(`effect 1 created`);\n  });\n  // 3. useState\n  const [name, setName] = useState(\"John\");\n  // 4. useEffect\n  useEffect(() => {\n    console.log(`effect 2 created`);\n  });\n  return (\n    <>\n      <h1\n        onClick={() => {\n          setCount(() => count + 1);\n        }}\n      >\n        <p title={count}>{count}</p> {name}\n      </h1>\n    </>\n  );\n}\n在这个 function 组件中, 同时使用了状态 Hook 和副作用 Hook.\n初次渲染时, 逻辑执行到performUnitOfWork->beginWork->updateFunctionComponent->renderWithHooks前，没有右侧侧黄色部分只有调用了renderWithHooks后才开始有右侧黄色部分无论状态 Hook 或副作用 Hook 都按照调用顺序存储在 fiber.memoizedState 链表中fiber树更新阶段, 把current.memoizedState链表上的所有Hook按照顺序克隆到workInProgress.memoizedState上, 实现数据的持久化.","注意#注意":"其中 hook.queue 与 fiber.updateQueue 虽然都是 update 环形链表, 尽管 update 对象的数据结构与处理方式都高度相似, 但是这 2 个队列中的 update 对象是完全独立的. hook.queue 只作用于 hook 对象的状态维护, 切勿与 fiber.updateQueue 混淆.","为什么hooks不能写在条件判断中#为什么hooks不能写在条件判断中？":"hook会按顺序存储在链表中，如果写在条件判断中，就没法保持链表的顺序"}},"/posts/react/jsx-api":{"title":"react核心api和jsx","data":{"":"图：Nguyen Nhut","virtual-dom是什么#virtual Dom是什么":"用js对象表示dom信息和结构，更新时重新渲染更新后的对象对应的dom，这个对象就是React.createElement()的返回结果virtual Dom是一种编程方式，它以对象的形式保存在内存中，它描述了我们dom的必要信息，并且用类似react-dom等模块与真实dom同步，这一过程也叫协调(reconciler)，这种方式可以声明式的渲染相应的ui状态，让我们从dom操作中解放出来，在react中是以fiber树的形式存放组件树的相关信息，在更新时可以增量渲染相关dom，所以fiber也是virtual Dom实现的一部分","为什么要用virtual-dom#为什么要用virtual Dom":"大量的dom操作慢，很小的更新都有可能引起页面的重新排列，js对象优于在内存中，处理起来更快，可以通过diff算法比较新老virtual Dom的差异，并且批量、异步、最小化的执行dom的变更，以提高性能另外就是可以跨平台，jsx --> ReactElement对象 --> 真实节点，有中间层的存在，就可以在操作真实节点之前进行对应的处理，处理的结果反映到真实节点上，这个真实节点可以是浏览器环境，也可以是Native环境virtual Dom真的快吗？其实virtual Dom只是在更新的时候快，在应用初始的时候不一定快","jsxcreateelement#jsx&createElement":"jsx可以声明式的描述视图，提升开发效率，通过babel可以转换成React.createElement()的语法糖，也是js语法的扩展。jsx是ClassComponent的render函数或者FunctionComponent的返回值，可以用来表示组件的内容，在经过babel编译之后，最后会被编译成React.createElement，这就是为什么jsx文件要声明import React from 'react'的原因（react17之后不用导入），你可以在 babel编译jsx 站点查看jsx被编译后的结果​ React.createElement的源码中做了如下几件事\n处理config，把除了保留属性外的其他config赋值给props\n把children处理后赋值给props.children\n处理defaultProps\n调用ReactElement返回一个jsx对象(virtual-dom)\n//ReactElement.js\nexport function createElement(type, config, children) {\n  let propName;\n  const props = {};\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n  if (config != null) {\n    //处理config，把除了保留属性外的其他config赋值给props\n    //...\n  }\n  const childrenLength = arguments.length - 2;\n  //把children处理后赋值给props.children\n  //...\n  //处理defaultProps\n  //...\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    $$typeof: REACT_ELEMENT_TYPE,//表示是ReactElement类型\n    type: type,//class或function\n    key: key,//key\n    ref: ref,//ref属性\n    props: props,//props\n    _owner: owner,\n  };\n  return element;\n};\n$$typeof表示的是组件的类型，例如在源码中有一个检查是否是合法Element的函数，就是根object.$$typeof === REACT_ELEMENT_TYPE来判断的\n//ReactElement.js\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n如果组件是ClassComponent则type是class本身，如果组件是FunctionComponent创建的，则type是这个function，源码中用ClassComponent.prototype.isReactComponent来区别二者。注意class或者function创建的组件一定要首字母大写，不然后被当成普通节点，type就是字符串。jsx对象上没有优先级、状态、effectTag等标记，这些标记在Fiber对象上，在mount时Fiber根据jsx对象来构建，在update时根据最新状态的jsx和current Fiber对比，形成新的workInProgress Fiber，最后workInProgress Fiber切换成current Fiber。render\n//ReactDOMLegacy.js\nexport function render(\n  element: React$Element<any>,//jsx对象\n  container: Container,//挂载dom\n  callback: ?Function,//回调\n) {\n  \n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}\n可以看到render所做的事也就是调用legacyRenderSubtreeIntoContainer，这里重点关注ReactDom.render()使用时候的三个参数。components\n//ReactBaseClasses.js\nfunction Component(props, context, updater) {\n  this.props = props;//props属性\n  this.context = context;//当前的context\n  this.refs = emptyObject;//ref挂载的对象\n  this.updater = updater || ReactNoopUpdateQueue;//更新的对像\n}\nComponent.prototype.isReactComponent = {};//表示是classComponent\ncomponent函数中主要在当前实例上挂载了props、context、refs、updater等，所以在组件的实例上能拿到这些，而更新主要的承载结构就是updater， 主要关注isReactComponent，它用来表示这个组件是类组件总结：jsx是React.createElement的语法糖，jsx通过babel转化成React.createElement函数，React.createElement执行之后返回jsx对象，也叫virtual-dom，Fiber会根据jsx对象和current Fiber进行对比形成workInProgress FiberpureComponent也很简单，和component差不多，他会进行原型继承，然后赋值isPureReactComponent\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nconst pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\npureComponentPrototype.constructor = PureComponent;\nObject.assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\nexport {Component, PureComponent};"}},"/posts/react/legacy-concurrent":{"title":"legacy和concurrent模式","data":{"":"图：Nguyen Nhut","react启动的模式#react启动的模式":"react有3种模式进入主体函数的入口，我们可以从 react官方文档 使用 Concurrent 模式（实验性）中对比三种模式：\n* legacy 模式： ReactDOM.render(<App />, rootNode)。这是当前 React app 使用的方式。当前没有计划删除本模式，但是这个模式可能不支持这些新功能。\n* blocking 模式： ReactDOM.createBlockingRoot(rootNode).render(<App />)。目前正在实验中。作为迁移到 concurrent 模式的第一个步骤。\n* concurrent 模式： ReactDOM.createRoot(rootNode).render(<App />)。目前在实验中，未来稳定之后，打算作为 React 的默认开发模式。这个模式开启了所有的新功能。\nlegacy 模式在合成事件中有自动批处理的功能，但仅限于一个浏览器任务。非 React 事件想使用这个功能必须使用 unstable_batchedUpdates。在 blocking 模式和 concurrent 模式下，所有的 setState 在默认情况下都是批处理的。会在开发中发出警告","不同模式在react运行时的含义#不同模式在react运行时的含义":"legacy模式是我们常用的，它构建dom的过程是同步的，所以在render的reconciler中，如果diff的过程特别耗时，那么导致的结果就是js一直阻塞高优先级的任务(例如用户的点击事件)，表现为页面的卡顿，无法响应。concurrent Mode是react未来的模式，它用时间片调度实现了异步可中断的任务，根据设备性能的不同，时间片的长度也不一样，在每个时间片中，如果任务到了过期时间，就会主动让出线程给高优先级的任务。这部分将在第15节 scheduler&lane模型 。","两种模式函数主要执行过程#两种模式函数主要执行过程":"黄色部分是主要任务是创建fiberRootNode和rootFiber，红色部分是创建Update，蓝色部分是调度render阶段的入口函数","legacy模式#legacy模式":"render调用legacyRenderSubtreeIntoContainer，最后createRootImpl会调用到createFiberRoot创建fiberRootNode,然后调用createHostRootFiber创建rootFiber，其中fiberRootNode是整个项目的的根节点，rootFiber是当前应用挂在的节点，也就是ReactDOM.render调用后的根节点\n//最上层的节点是整个项目的根节点fiberRootNode\nReactDOM.render(<App />, document.getElementById(\"root\"));//rootFiber\nReactDOM.render(<App />, document.getElementById(\"root\"));//rootFiber\n创建完Fiber节点后，legacyRenderSubtreeIntoContainer调用updateContainer创建创建Update对象挂载到updateQueue的环形链表上，然后执行scheduleUpdateOnFiber调用performSyncWorkOnRoot进入render阶段和commit阶段","concurrent模式#concurrent模式":"createRoot调用createRootImpl创建fiberRootNode和rootNode\n创建完Fiber节点后，调用ReactDOMRoot.prototype.render执行updateContainer，然后scheduleUpdateOnFiber异步调度performConcurrentWorkOnRoot进入render阶段和commit阶段","两种模式的不同点#两种模式的不同点":"createRootImpl中传入的第二个参数不一样 一个是LegacyRoot一个是ConcurrentRoot\nrequestUpdateLane中获取的lane的优先级不同\n在函数scheduleUpdateOnFiber中根据不同优先级进入不同分支，legacy模式进入performSyncWorkOnRoot，concurrent模式会异步调度performConcurrentWorkOnRoot"}},"/posts/react/mini-react-1":{"title":"React Mini版实现(1)","data":{"":"图：Vivivian","准备#准备":"","jsx#JSX":"React 使用 JSX 来替代常规的 JavaScript。JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。表面上像 HTML，本质上还是通过 babel 转换为 js 执行。jsx 就是一段 js，只是写成了 html 的样子，而我们读取他的时候，jsx 会自动转换成 vnode 对象给我们，这里都由 react-script 的内置的 babel 帮助我们完成。\nreturn <div>Hello Word</div>;\n//实际上是：\nreturn React.createElement(\"div\", null, \"Hello\");\nJSX 本质上就是转换为 React.createElement 在 React 内部构建虚拟 Dom，最终渲染出页面。","虚拟-dom#虚拟 Dom":"先看一个最简单的 react 组件渲染\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nfunction App(props){\n     return <div>你好</div>\n </div>\n}\nReactDOM.render(<App/>,  document.getElementById('root'))\n在上述的 js 文件中，我们使用了 jsx。但是 jsx 的编译是需要 react 的，所以不引用 react 就会报错。\nreact 的作用，就是把 jsx 转换为虚拟dom对象。JSX 本质上就是转换为React.createElement在 React 内部构建虚拟 Dom，最终渲染出页面。\nReact 负责逻辑控制，数据 -> VDOM\nReactDom 渲染实际 DOM，VDOM -> DOM\nReact 将 jsx 转换为“虚拟 dom”对象。我们再利用 ReactDom 的虚拟 dom 通过 render 函数，转换成 dom。再通过插入到我们的真是页面中。","实现#实现":"下面我们来看下实现react 的功能化问题，暂时不考虑。例如，启动 react，怎么去识别 JSX，实现热更新服务等等，我们的重点在于 react 自身。我们借用一下一下 react-scripts 插件。","初始化项目#初始化项目":"新建 package.json\n{\n  \"name\": \"react_mini\",\n  \"scripts\": {\n    \"start\": \"react-scripts start\"\n  },\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react-scripts\": \"3.4.1\"\n  }\n}\nnpm i\n新建 public/index.js, src/index.js, src/react.js, src/react.dom.js最终目录结构如下\n.\n├── package.json\n├── public\n│   └── index.html\n└── src\n    ├── index.js\n    ├── react-dom.js\n    └── react.js","indexhtml#index.html":"react-scripts 会起一个 server 加载这个 html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head> </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>","indexjs#index.js":"react-scripts 会以这个文件为入口加载 js\n这个文件写一些我们的测试代码\nimport ReactDOM from \"./react-dom\";\nimport React from \"./react.js\";\n// 类组件示例\nclass MyClassCmp extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return <div className=\"class_2\">这是{this.props.name}</div>;\n  }\n}\n//函数组件示例\nfunction MyFuncCmp(props) {\n  return <div className=\"class_1\">这是{props.name}</div>;\n}\nconst hello = () => {\n  alert(\"Hello Mini React\");\n};\nlet jsx = (\n  <div>\n    <h1>Mini React</h1>\n    <div className=\"className1\" onClick={hello}>\n      <div>This is my Mini React</div>\n      <MyFuncCmp name=\"函数组件\" />\n      <MyClassCmp name=\"类组件\" />\n    </div>\n  </div>\n);\nReactDOM.render(jsx, document.getElementById(\"root\"));","reactjs#react.js":"以下就是 react 的 mini 版实现\n/**\n * 创建虚拟dom函数\n *\n * @param {*} type // 节点类型\n * @param {*} props // 属性参数\n * @param {*} children // 子组件\n * @return {*}\n */\nfunction createElement(type, props, ...children) {\n  console.log(\"type\", type);\n  props.children = children;\n  let vtype;\n  if (typeof type === \"string\") {\n    // 判断类型为string则是原生html类型\n    vtype = 1;\n  }\n  if (typeof type === \"function\") {\n    // 判断是否是函数组件或类组件\n    vtype = type.isReactComponent ? 2 : 3; // 判断是函数组件还是类组件\n  }\n  return {\n    // 返回虚拟dom节点\n    vtype, // 虚拟dom类型\n    type, // 节点类型\n    props, // 属性参数\n  };\n}\n//类组件定义\nclass Component {\n  static isReactComponent = true;\n  constructor(props) {\n    this.props = props;\n    this.state = {};\n  }\n  setState = () => {};\n}\nexport default {\n  createElement,\n  Component,\n};","react-domjs#react-dom.js":"以下就是react-dom的迷你版实现\n//渲染函数\nfunction render(vnode, container) {\n  mount(vnode, container);\n}\n//主挂载函数\nfunction mount(vnode, container) {\n  const { vtype } = vnode;\n  if (!vtype) {\n    //处理文本节点\n    mountTextNode(vnode, container);\n  }\n  if (vtype === 1) {\n    //处理原生标签\n    mountHtml(vnode, container);\n  }\n  if (vtype === 3) {\n    //处理函数组件\n    mountFunc(vnode, container);\n  }\n  if (vtype === 2) {\n    //处理class组件\n    mountClass(vnode, container);\n  }\n}\n//文本节点挂载函数\nfunction mountTextNode(vnode, container) {\n  const node = document.createTextNode(vnode);\n  container.appendChild(node);\n}\n//原生节点挂载函数\nfunction mountHtml(vnode, container) {\n  const { type, props } = vnode;\n  const node = document.createElement(type); //创建一个真实dom\n  const { children, ...rest } = props;\n  children.map((item) => {\n    //子元素递归\n    if (Array.isArray(item)) {\n      item.map((c) => {\n        mount(c, node);\n      });\n    } else {\n      mount(item, node);\n    }\n  });\n  Object.keys(rest).map((item) => {\n    if (item === \"className\") {\n      node.setAttribute(\"class\", rest[item]);\n    }\n    if (item.slice(0, 2) === \"on\") {\n      node.addEventListener(\"click\", rest[item]);\n    }\n  });\n  container.appendChild(node);\n}\n//函数组件挂载函数\nfunction mountFunc(vnode, container) {\n  const { type, props } = vnode;\n  const node = new type(props);\n  mount(node, container);\n}\n//类组件挂载函数\nfunction mountClass(vnode, container) {\n  const { type, props } = vnode;\n  const node = new type(props);\n  mount(node.render(), container);\n}\nexport default {\n  render,\n};","验证效果#验证效果":"以上就实现了mini react的渲染"}},"/posts/react/mobx":{"title":"mobx-react 使用","data":{"":"图：Vivivian","index#index":"import { render } from \"react-dom\";\nimport App from \"./App\";\nimport store from \"./store\";\nimport { Provider } from \"mobx-react\";\nconst rootElement = document.getElementById(\"root\");\nrender(\n  <Provider {...store}>\n    <App />\n  </Provider>,\n  rootElement\n);\nimport { makeObservable, observable, action } from \"mobx\";\nclass Home {\n  constructor() {\n    makeObservable(this, {\n      data: observable,\n      onChange: action.bound\n    });\n  }\n  data = \"home\";\n  onChange(data) {\n    this.data = data;\n  }\n}\nclass About {\n  constructor() {\n    makeObservable(this, {\n      value: observable,\n      onChange: action.bound\n    });\n  }\n  value = \"About\";\n  onChange(value) {\n    this.value = value;\n  }\n}\n// 上⾯的模块应该分散在各⾃的业务中，这⾥就不使⽤导⼊的⽅式了\nexport default {\n  home: new Home(),\n  about: new About()\n};\nimport React from \"react\";\nimport { inject, Observer } from \"mobx-react\";\nfunction MobxReact({ home, about }) {\n  return (\n    <h3>\n      <h2>mobx-react</h2>\n      <button onClick={() => home.onChange(Math.random())}>\n        home:\n        <Observer>{() => home.data}</Observer>\n      </button>\n      <br />\n      <button onClick={() => about.onChange(Math.random())}>\n        about:\n        <Observer>{() => about.value}</Observer>\n      </button>\n    </h3>\n  );\n}\nexport default inject(\"home\", \"about\")(MobxReact);"}},"/posts/react/performance":{"title":"React性能优化","data":{"":"图：Kashish Arora","code-splitting#Code Splitting":"可以帮你“懒加载”代码，如果你没办法直接减少应用的体积，那么不妨尝试把应用从单个 bundle 拆分成单个 bundle + 多份动态代码的形式。","解耦#解耦":"组件尽可能的进行拆分、解耦","bind-函数优化#bind 函数优化":"class App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      num:1,\n      title:'react study'\n    }\n    this.handleClick = this.handleClick.bind(this);\n    this.item = {react:'redux'};\n  }\n  handleClick(){\n    this.setState({\n      num: this.state.num + 1\n    })\n  }\n  render(){\n    return (\n      <div className=\"App\">\n        <h2> {this.state.num} </h2>\n        <button onClick={this.handleClick}>btn1</div>\n        <button onClick={this.handleClick.bind(this)}>btn2</div>\n        <button onClick={()=>this.handleClick()}>btn3</div>\n      </div>\n    )\n  }\n}\n第一种是在构造函数中绑定 this，第二种是在 render()函数里面绑定 this，第三种就是使用箭头函数，都能实现上述方法；但是哪一种方法的性能最好，是我们要考虑的问题。应该大家都知道答案：第一种的性能最好。因为第一种，构造函数每一次渲染的时候只会执行一遍；而第二种方法，在每次 render()的时候都会重新执行一遍函数；第三种方法的话，每一次 render()的时候，都会生成一个新的箭头函数，即使两个箭头函数的内容是一样的。第三种方法我们可以举一个例子，因为 react 判断是否需要进行 render 是浅层比较，简单来说就是通过===来判断的，如果 state 或者 prop 的类型是字符串或者数字，只要值相同，那么浅层比较就会认为其相同；但是如果前者的类型是复杂的对象的时候，我们知道对象是引用类型，浅层比较只会认为这两个 prop 是不是同一个引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是两个不同的 prop。","不要滥用-props#不要滥用 props":"不要滥用 props,props 尽量只传需要的数据，避免多余的更新，尽量避免使用{…props}","动态导入#动态导入":"import(``\"./math\"``).then(math => {\n  console.log(math.add(16, 26));\n  });\nreact-loadable","使用不可突变数据结构#使用不可突变数据结构":"使用Immutable对象\nMap：键值对集合，对应Object，Es6种也有专门的Map对象\nList：有序可重复列表，对应于Array\nArraySet：有序且不可重复的列表\n使用Map生成一个immutable对象\nimport { Map , is } from 'immutable';\nlet obj = Map({\n  'name': 'react study',\n  'course': Map({name: 'react+redux'})\n})\nlet obj1 = obj.set('name','darrell');\nconsole.log(obj.get('course') === obj1.get('course')); // 返回true\nconsole.log(obj === obj1); // 返回false\nImmutable.is 比较的是两个对象的 hashCode 或 valueOf（对于 JavaScript 对象）。由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。\nlet obj = Map({name:1,title:'react'});\nlet obj1 = Map({name:1,title:'react'});\nconsole.log(is(obj,obj1)); // 返回true\nlet obj2 = {name:1,title:'react'};\nlet obj3 = {name:1,title:'react'};\nconsole.log(is(obj2,obj3)); // 返回false\nImmutable优点：\n减少内存的使用\n并发安全\n降低项目的复杂度\n便于比较复杂数据，定制shouldComponentUpdate方便\n时间旅行功能\n函数式编程\nImmutable缺点：\n学习成本\n库的大小（建议使用seamless-immutable）\n对现有项目入侵严重\n容易与原生的对象进行混淆","减少重复渲染#减少重复渲染":"如果是类组件，使用shouldComponentUpdate减少重新渲染，如果是函数组件，要写清楚依赖项数组","减少dom结构更改#减少dom结构更改":"如果要操作Vitural Dom，尽量减少dom结构更改","key的优化#key的优化":"列表要声明key","虚拟列表#虚拟列表":"大数据量的列表需要使用虚拟滚动列表\n见 react virtualList 虚拟列表无限滚动实现"}},"/posts/react/redux":{"title":"手写Mini Redux实现","data":{"":"图：Nguyen Nhut","实现#实现":"我们用2个文件来实现store和connect的逻辑，用2个文件来做测试用例\n目录结构如下：\n.\n├── connect.js //connect实现\n├── index.jsx  //测试用例\n├── reducer.js //测试用例的reducer\n└── store.js  //store实现","store实现-storejs#store实现 store.js":"主要实现全局数据仓库，getStore,dispatch,subscribe方法\n// 迷你版redux实现,全局数据仓库构造函数\nfunction createStore(reducers) {\n  var state = {};\n  var listeners = [];\n  var getState = () => state;\n  var dispatch = (actionObj) => {\n    let [model, action] = actionObj.type.split(\"/\"); \n    state = reducers[model](state, action);\n    listeners.forEach((l) => l());\n  };\n  var subscribe = (listener) => {\n    listeners.push(listener);\n    return () => {\n      listeners = listeners.filter((l) => l !== listener);\n    };\n  };\n  return {\n    getState,\n    dispatch,\n    subscribe,\n  };\n}\nexport default createStore;","connect实现-connectjs#connect实现, connect.js":"connect实现主要使用了高阶组件HOC\nimport React, { useState, useMemo, useReducer } from \"react\";\nimport createStore from \"./store\";\nimport reducers from \"./reducer\";\nfunction baseReducer(state, action) {\n  return {\n    ...state,\n    ...action.payload,\n  };\n}\n//迷你简易版redux-react实现\nconst ConnectAdvanced = ({ WrappedComponent, actualChildProps }) => {\n  const renderedWrappedComponent = useMemo(\n    () => <WrappedComponent {...actualChildProps} />,\n    [WrappedComponent, actualChildProps]\n  );\n  return <>{renderedWrappedComponent}</>;\n};\nconst ConnectFunction = (props) => {\n  const { store, mapStateToProps, dispatch, state, component } = props;\n  // let [actualProps, setActualProps] = useState(state);\n  let [actualProps,dispatchBase] = useReducer(baseReducer,state)\n  store.subscribe(function () {\n    const storeData = store.getState();\n    let state = mapStateToProps(storeData);\n    // setActualProps(state);\n    dispatchBase({\n      type:'save',\n      payload:state\n    })\n  });\n  return (\n    <ConnectAdvanced\n      WrappedComponent={component}\n      actualChildProps={{ ...actualProps, dispatch }}\n    />\n  );\n};\nconst connect = (mapStateToProps) => {\n  var store = window.store\n    ? window.store\n    : (window.store = createStore(reducers));\n  const storeData = store.getState();\n  let state = mapStateToProps(storeData);\n  let dispatch = store.dispatch;\n  return (component) => {\n    return () => {\n      return (\n        <ConnectFunction\n          component={component}\n          store={store}\n          mapStateToProps={mapStateToProps}\n          dispatch={dispatch}\n          state={state}\n        />\n      );\n    };\n  };\n};\nexport default connect;","reducer实现-reducerjs#reducer实现, reducer.js":"全局reducers\n//数据处理器，纯函数\nvar countReducer = (state = {}, action) => {\n  if (!action) return state;\n  const { count = 0 } = state;\n  console.log(action);\n  switch (action) {\n    case \"INCREMENT\":\n      return { ...state, count: count + 1 };\n    case \"DECREMENT\":\n      return { ...state, count: count - 1 };\n    default:\n      return { ...state, count };\n  }\n};\nexport default {countReducer}","测试用例-indexjs#测试用例 index.js":"import React from \"react\";\nimport connect from \"./connect\";\nconst Page = function (props) {\n  const { count = 0, dispatch = () => {} } = props;\n  console.log(\"count\", count);\n  return (\n    <>\n      <div id=\"counter\">count:{count}</div>\n      <button\n        id=\"addBtn\"\n        onClick={() => {\n          dispatch({ type: \"countReducer/INCREMENT\" });\n        }}\n      >\n        addBtn\n      </button>\n      <button\n        id=\"minusBtn\"\n        onClick={() => {\n          dispatch({ type: \"countReducer/DECREMENT\" });\n        }}\n      >\n        minusBtn\n      </button>\n    </>\n  );\n};\nconst connectedPage = connect(({ count }) => ({ count }))(Page);\nexport default connectedPage;"}},"/posts/react/setstate-usestate":{"title":"setState是同步的还是异步的","data":{"":"图：Mako Tsereteli","异步#“异步”？":"所谓同步还是异步指的是调用 setState 之后是否马上能得到最新的 statesetState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”最终决定setState是同步渲染还是异步渲染的关键因素是ReactFiberWorkLoop工作空间的执行上下文.","什么时候是异步#什么时候是\"异步\"":"legacy模式下：命中batchedUpdates时是异步 未命中batchedUpdates时是同步的concurrent模式下：都是异步的函数组件里使用useState都是异步的\n//以下写法都会是”异步“效果\n//所有打印的num都是0\nexport default () => {\n  const [num, setNum] = useState(0);\n  const handerClick = () => {\n    setNum(num + 1);\n    console.log(num);\n    setNum(num + 1);\n    console.log(num);\n    setNum(num + 1);\n    console.log(num);\n    setTimeout(() => {\n      setNum(num + 1);\n      console.log(num);\n      setNum(num + 1);\n      console.log(num);\n      setNum(num + 1);\n      console.log(num);\n    }, 1000);\n    Promise.resolve().then(() => {\n      setNum(num + 1);\n      console.log(num);\n      setNum(num + 1);\n      console.log(num);\n      setNum(num + 1);\n      console.log(num);\n    });\n  };\n  useLayoutEffect(() => {\n    const dom = document.getElementById(\"button\");\n    if (!dom) return;\n    dom.addEventListener(\"click\", handerClick);\n  }, []);\n  \n  return (\n    <div>\n      <button id=\"button\">{num}</button>\n    </div>\n  );\n};","什么时候是同步#什么时候是同步":"class组件原生事件触发的setState就是同步的\nclass组件在setTimeout里是同步的\nclass组件在promise.then里是同步的\n// 以下表现就是同步的\n// 每一步会打印不同的值\nexport default class Index extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      number: 0,\n    };\n  }\n  handerClick = () => {\n    setTimeout(() => {\n      this.setState({ number: this.state.number + 1 });\n      console.log(this.state.number);\n      this.setState({ number: this.state.number + 1 });\n      console.log(this.state.number);\n      this.setState({ number: this.state.number + 1 });\n      console.log(this.state.number);\n    }, 1000);\n    Promise.resolve().then(() => {\n      this.setState({ number: this.state.number + 1 });\n      console.log(this.state.number);\n      this.setState({ number: this.state.number + 1 });\n      console.log(this.state.number);\n      this.setState({ number: this.state.number + 1 });\n      console.log(this.state.number);\n    });\n  };\n  render() {\n    return (\n      <div>\n        <button onClick={this.handerClick}>num++</button>\n      </div>\n    );\n  }\n}","如何手动合并多次更新#如何手动合并多次更新":"ReactDOM.unstable_batchedUpdates","为什么#为什么？":"合成事件会走batchUpdate\n在 setState 的时候react内部会创建一个 updateQueue ，通过 firstUpdate 、 lastUpdate 、 lastUpdate.next 去维护一个更新的队列，在最终的 performWork 中，相同的key会被覆盖，只会对最后一次的 setState 进行更新\n在批量更新上下文中（比如点击事件对应的处理函数），this.setState 会创建一个update，这个更新对应一个 expirationTime，Sync mode下（默认情况）它的值是1。将这个 update 添加到 该组件对应fiber 的 updateQueue。同时将这个过期时间添加到RootFiber。由于处于批量更新上下文中，这些update不会被执行。\n然后继续this.setState，再次创建一个 expirationTime 为 1 的update，将这个 update 添加到 fiber 的 updateQueue....如此反复。\n直到退出事件处理函数，然后将批量更新的标志（isBatchingUpdates）设置为false，此时 performSyncWork 执行所有的update。","tips#Tips":"批量更新：是一个组件连续 setState 多次，这个组件只更新一次，这与过期时间无关\n批处理：同一时间，这个组件应该并发更新多少次，这个和过期时间有关，或者说和 lane 有关"}},"/posts/react/synthetic-event":{"title":"react合成事件","data":{"":"图：Amrit Pal Singh\nReact 并不会在该 DOM 元素上直接绑定事件处理器. React 内部自定义了一套事件系统，在这个系统上统一进行事件订阅和分发.具体来讲，React 利用事件委托机制在 Document(17 是 rootFiber) 上统一监听 DOM 事件，再根据触发的 target 将事件分发到具体的组件实例。另外上面 e 是一个合成事件对象(SyntheticEvent), 而不是原始的 DOM 事件对象.","原理#原理":"从实现上讲, 主要分为 3 步:\n监听原生事件: 对齐 DOM 元素和 fiber 元素\n收集 listeners: 遍历 fiber 树, 收集所有监听本事件的 listener 函数.\n派发合成事件: 构造合成事件, 遍历 listeners 进行派发.","动机#动机":"抹平浏览器之间的兼容性差异。\n抽象跨平台事件机制\nReact 打算做更多优化\nReact 打算干预事件的分发","事件代理#事件代理":"区别于浏览器事件处理方式，React 并未将事件处理函数与对应的 DOM 节点直接关联，而是在顶层使用\n了一个全局事件监听器监听所有的事件；\nReact 会在内部维护一个映射表记录事件与组件事件处理函数的对应关系；\n当某个事件触发时，React 根据这个内部映射表将事件分派给指定的事件处理函数；\n当映射表中没有事件处理函数时，React 不做任何操作；\n当一个组件安装或者卸载时，相应的事件处理函数会自动被添加到事件监听器的内部映射表中或从表中删除。","合成事件#合成事件":"与浏览器事件处理稍微有不同的是，React 中的事件处理程序所接收的事件参数是被称为“合成事件（SyntheticEvent）”的实例。\n合成事件是对浏览器原生事件跨浏览器的封装，并与浏览器原生事件有着同样的接口，如 stopPropagation(),preventDefault()等，并且\n这些接口是跨浏览器兼容的。\n如果需要使用浏览器原生事件，可以通过合成事件的 nativeEvent 属性获取\nReact 合成事件原理\n使用 JSX，在 React 中绑定事件：\n<button onClick={this.onClick}>单击触发react事件</button>\nReact 并不是将 click 事件绑在该 div 的真实 DOM 上，而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装并交由真正的处理函数运行","基本概念#基本概念":"ReactEventListener - 事件处理器. 在这里进行事件处理器的绑定。当 DOM 触发事件时，会从这里开始调度分发到 React 组件树\nReactEventEmitter - 暴露接口给 React 组件层用于添加事件订阅\nEventPluginHub - 如其名，这是一个‘插件插槽’，负责管理和注册各种插件。在事件分发时，调用插件来生成合成事件\nPlugin - React 事件系统使用了插件机制来管理不同行为的事件。这些插件会处理自己感兴趣的事件类型，并生成合成事件对象。目前 ReactDOM 有以下几种插件类型:\nSimpleEventPlugin - 简单事件, 处理一些比较通用的事件类型，例如 click、input、keyDown、mouseOver、mouseOut、pointerOver、pointerOut\nEventPropagators 按照 DOM 事件传播的两个阶段，遍历 React 组件树，并收集所有组件的事件处理器.\nEventBatching 负责批量执行事件队列和事件处理器，处理事件冒泡。\nSyntheticEvent 这是‘合成’事件的基类，可以对应 DOM 的 Event 对象。只不过 React 为了减低内存损耗和垃圾回收，使用一个对象池来构建和释放事件对象， 也就是说 SyntheticEvent 不能用于异步引用，它在同步执行完事件处理器后就会被释放。","事件分类与优先级#事件分类与优先级":"SimpleEventPlugin 将事件类型划分成了三类, 对应不同的优先级(优先级由低到高):\nDiscreteEvent 离散事件. 例如 blur、focus、 click、 submit、 touchStart. 这些事件都是离散触发的\nUserBlockingEvent 用户阻塞事件. 例如 touchMove、mouseMove、scroll、drag、dragOver 等等。这些事件会'阻塞'用户的交互。\nContinuousEvent 可连续事件。例如 load、error、loadStart、abort、animationEnd. 这个优先级最高，也就是说它们应该是立即同步执行的，这就是 Continuous 的意义，即可连续的执行，不被打断.","react-有-5-个优先级级别#React 有 5 个优先级级别:":"Immediate - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断\nUserBlocking(250ms timeout) 这些任务一般是用户交互的结果, 需要即时得到反馈 .\nNormal (5s timeout) 应对哪些不需要立即感受到的任务，例如网络请求\nLow (10s timeout) 这些任务可以放后，但是最终应该得到执行. 例如分析通知\nIdle (no timeout) 一些没有必要做的任务 (e.g. 比如隐藏的内容).","如何绑定#如何绑定":"在 props 初始化和更新时会进行事件绑定。首先 React 会判断元素是否是媒体类型，媒体类型的事件是无法在 Document 监听的，所以会直接在元素上进行绑定\n反之就在 rootFiber 上绑定. 这里面需要两个信息，一个就是上文提到的'事件依赖列表', 比如 onMouseEnter 依赖 mouseover/mouseout; 第二个是 ReactBrowserEventEmitter 维护的'已订阅事件表'。事件处理器只需在 Document 订阅一次，所以相比在每个元素上订阅事件会节省很多资源.\nexport function listenTo(\n  registrationName: string, // 注册名称，如onClick\n  mountAt: Document | Element | Node // 组件树容器，一般是Document\n): void {\n  const listeningSet = getListeningSetForElement(mountAt); // 已订阅事件表\n  const dependencies = registrationNameDependencies[registrationName]; // 事件依赖\n  for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i];\n    if (!listeningSet.has(dependency)) {\n      // 未订阅\n      switch (dependency) {\n        // ... 特殊的事件监听处理\n        default:\n          const isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1;\n          if (!isMediaEvent) {\n            trapBubbledEvent(dependency, mountAt); // 设置事件处理器\n          }\n          break;\n      }\n      listeningSet.add(dependency); // 更新已订阅表\n    }\n  }\n}","如何触发#如何触发":"不同的事件类型有不同的事件处理器, 它们的区别是调度的优先级不一样:\n// 离散事件\n// discrentUpdates 在UserBlocking优先级中执行\nfunction dispatchDiscreteEvent(topLevelType, eventSystemFlags, nativeEvent) {\n  flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);\n  discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, nativeEvent);\n}\n// 阻塞事件\nfunction dispatchUserBlockingUpdate(\n  topLevelType,\n  eventSystemFlags,\n  nativeEvent\n) {\n  // 如果开启了enableUserBlockingEvents, 则在UserBlocking优先级中调度，\n  // 开启enableUserBlockingEvents可以防止饥饿问题，因为阻塞事件中有scroll、mouseMove这类频繁触发的事件\n  // 否则同步执行\n  if (enableUserBlockingEvents) {\n    runWithPriority(\n      UserBlockingPriority,\n      dispatchEvent.bind(null, topLevelType, eventSystemFlags, nativeEvent)\n    );\n  } else {\n    dispatchEvent(topLevelType, eventSystemFlags, nativeEvent);\n  }\n}\n// 可连续事件则直接同步调用dispatchEvent\n最终都会调用 dispatchEvent 函数. dispatchEvent 中会从 DOM 原生事件对象获取事件触发的 target，再根据这个 target 获取关联的 React 节点实例.","插件是如何处理事件#插件是如何处理事件":"SimpleEventPlugin\nconst SimpleEventPlugin: PluginModule<MouseEvent> & {\n  getEventPriority: (topLevelType: TopLevelType) => EventPriority,\n} = {\n  eventTypes: eventTypes,\n  // 抽取事件对象\n  extractEvents: function (\n    topLevelType: TopLevelType,\n    targetInst: null | Fiber,\n    nativeEvent: MouseEvent,\n    nativeEventTarget: EventTarget\n  ): null | ReactSyntheticEvent {\n    // 事件配置\n    const dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    // 1️⃣ 根据事件类型获取SyntheticEvent子类事件构造器\n    let EventConstructor;\n    switch (topLevelType) {\n      // ...\n      case DOMTopLevelEventTypes.TOP_KEY_DOWN:\n      case DOMTopLevelEventTypes.TOP_KEY_UP:\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case DOMTopLevelEventTypes.TOP_BLUR:\n      case DOMTopLevelEventTypes.TOP_FOCUS:\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      // ... 省略\n      case DOMTopLevelEventTypes.TOP_GOT_POINTER_CAPTURE:\n      // ...\n      case DOMTopLevelEventTypes.TOP_POINTER_UP:\n        EventConstructor = SyntheticPointerEvent;\n        break;\n      default:\n        EventConstructor = SyntheticEvent;\n        break;\n    }\n    // 2️⃣ 构造事件对象, 从对象池中获取\n    const event = EventConstructor.getPooled(\n      dispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    // 3️⃣ 根据DOM事件传播的顺序获取用户事件处理器\n    accumulateTwoPhaseDispatches(event);\n    return event;\n  },\n};\n根据事件的类型确定 SyntheticEvent 构造器\n构造 SyntheticEvent 对象。\n根据 DOM 事件传播的顺序获取用户事件处理器列表\n为了避免频繁创建和释放事件对象导致性能损耗(对象创建和垃圾回收)，React 使用一个事件池来负责管理事件对象，使用完的事件对象会放回池中，以备后续的复用。"}},"/posts/react/useeffect-comply":{"title":"Mini useEffect实现","data":{"":"图：Tran Mau Tri Tam","mini实现#Mini实现":"当做启发，不是真实内部实现\nimport React, { useState } from \"react\";\nimport ReactDOM from \"react-dom\";\nfunction CounterEffect() {\n    effectCursor = 0; // 注意将 effectCursor 重置为0\n    const [count, setCount] = useState(0);\n    const [count1, setCount1] = useState(0);\n    useEffect(() => {\n        console.log(count);\n    }, [count]);\n    useEffect(() => {\n        console.log(count1 + \"哈哈哈\");\n    }, [count1]);\n    const onClick = () => {\n        setCount(count + 1);\n    };\n    const onClick1 = () => {\n        setCount1(count1 + 1);\n    };\n    return (\n        <div>\n            <div>{count}</div>\n            <button onClick={onClick}>点击</button>\n            <div>{count1}</div>\n            <button onClick={onClick1}>点击</button>\n        </div>\n    );\n}\nconst allDeps: Array<any[] | undefined> = [];\nlet effectCursor: number = 0;\nfunction useEffect(callback: () => void, depArray?: any[]) {\n    if (!depArray) {\n        callback();\n        allDeps[effectCursor] = depArray;\n        effectCursor++;\n        return;\n    }\n    const deps = allDeps[effectCursor];\n    const hasChangedDeps = deps\n        ? depArray.some((el, i) => el !== deps[i])\n        : true;\n    if (hasChangedDeps) {\n        callback();\n        allDeps[effectCursor] = depArray;\n    }\n    effectCursor++;\n}\nexport function render() {\n    ReactDOM.render(\n        <React.StrictMode>\n            <CounterEffect />\n        </React.StrictMode>,\n        document.getElementById(\"root\")\n    );\n}"}},"/posts/react/virtuallist":{"title":"react virtualList 虚拟列表无限滚动实现","data":{"":"图：Mako Tsereteli","分析#分析":"为了提升性能，不能一次性把大量数据直接渲染到页面上，所以就需要一个机制来实现一个虚拟的列表，只渲染用户可视区域看到内容\n下拉到底，继续加载数据并拼接\n渲染的数据只是用户看到的内容","虚拟列表#虚拟列表":"虚拟列表的实现，实际上就是在首屏加载的时候，只加载可视区域内需要的列表项，当滚动发生时，动态通过计算获得可视区域内的列表项，并将非可视区域内存在的列表项删除。如下图所示","核心变量#核心变量":"通过容器高度和每一条的高度计算视口应该渲染的可以看到的条数（visibleCount）\n计算当前可视区域起始索引位置（start）\n计算当前可视区域结束索引位置（end）\n计算当前可视区域的数据，并渲染到页面中 （visibleData）\n计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset 并设置到列表上 （offset）\nconst visibleCount = Math.ceil(containerHeight / itemHeight);\nconst start = Math.floor(scrollTop / itemHeight);\nconst end = start + visibleCount;\nconst visibleData = data.slice(start, Math.min(end, data.length));\nconst offset = scrollTop - (scrollTop % itemHeight);","无限滚动#无限滚动":"滚动时要设置数据的视口，即通过设置 star 的方式间接地设置数据的滑动窗口\n当滚动后，由于渲染区域相对于可视区域已经发生了偏移，此时我需要获取一个偏移量 offset，通过样式控制将渲染区域偏移至可视区域中。","实现#实现":"import \"./styles.css\";\nimport Faker from \"faker\";\nimport { useState, useRef, useEffect, useMemo, useCallback } from \"react\";\nconst itemHeight = 100;\nconst total = 1000000;\nexport default function App() {\n  const ref = useRef();\n  // 可视区域高度\n  const containerHeight = document.body.clientHeight;\n  // 可显示的列表项数\n  const visibleCount = Math.ceil(containerHeight / itemHeight);\n  const [listData, setListData] = useState([]);\n  // 偏移量\n  const [startOffset, setStartOffset] = useState(0);\n  // 起始索引\n  const [start, setStart] = useState(0);\n  // 结束索引\n  const end = start + visibleCount;\n  // 列表总高度\n  const listHeight = useMemo(() => {\n    return listData.length * itemHeight;\n  }, [listData]);\n  // 获取真实显示列表数据\n  const visibleData = useMemo(() => {\n    return listData.slice(start, Math.min(end, listData.length));\n  }, [listData, start, end]);\n  //加载随机数据\n  const getTenListData = useCallback(() => {\n    if (listData.length >= total) {\n      return [];\n    }\n    return new Array(10).fill({}).map((item) => ({\n      id: Faker.random.uuid(),\n      avatar: Faker.image.avatar(),\n      title: Faker.name.firstName(),\n      content: Faker.company.companyName(),\n    }));\n  }, [listData]);\n  useEffect(() => {\n    const data = getTenListData();\n    setListData(data);\n  }, []);\n  const scrollToTop = () => {\n    ref.current.scrollTo({\n      top: 0,\n      left: 0,\n      behavior: \"smooth\",\n    });\n  };\n  const scrollEvent = useCallback(\n    (e) => {\n      // 当前滚动位置\n      const scrollTop = ref.current.scrollTop;\n      // 此时的开始索引\n      const start = Math.floor(scrollTop / itemHeight);\n      const end = start + visibleCount;\n      setStart(start);\n      if (end >= listData.length) {\n        const data = listData.concat(getTenListData());\n        setListData(data);\n      }\n      // 此时的偏移量\n      const offset = scrollTop;\n      setStartOffset(offset);\n    },\n    [listData, getTenListData, visibleCount]\n  );\n  useEffect(() => {\n    let dom = ref.current;\n    scrollEvent();\n    if (dom) {\n      dom.addEventListener(\"scroll\", scrollEvent);\n    }\n    return () => {\n      if (dom) {\n        dom.removeEventListener(\"scroll\", scrollEvent);\n      }\n    };\n  }, [scrollEvent]);\n  return (\n    <div className=\"infinite-list-container\" ref={ref}>\n      <div className=\"scrollTopBtn\" onClick={scrollToTop}>\n        ∧\n      </div>\n      <div\n        className=\"infinite-list-phantom\"\n        style={{ height: Math.max(listHeight, containerHeight + 1) }}\n      />\n      <div\n        className=\"infinite-list\"\n        style={{ transform: `translate3d(0,${startOffset}px,0)` }}\n      >\n        {visibleData.map((item) => (\n          <div\n            className=\"infinite-list-item\"\n            key={item.id}\n            style={{ height: itemHeight }}\n          >\n            <div\n              className=\"left-section\"\n              style={{ backgroundImage: `url(${item.avatar})` }}\n            ></div>\n            <div className=\"right-section\">\n              <div className=\"title\">{item.title}</div>\n              <div className=\"desc\">{item.content}</div>\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}"}},"/posts/react/usestate-comply":{"title":"Mini useState 实现","data":{"":"图：Tran Mau Tri Tam","mini版实现#Mini版实现":"import React from \"react\";\nimport ReactDOM from \"react-dom\";\nfunction Counter() {\n  var [count, setCount] = useState(0);\n  var [name, setName] = useState(\"john\");\n  const onClick = () => {\n    setCount(count + 1);\n  };\n  const onClickName = () => {\n    setName(\"name\" + Math.random());\n  };\n  return (\n    <div>\n      <div>{count}</div>\n      <button onClick={onClick}>点击</button>\n      <div>{name}</div>\n      <button onClick={onClickName}>点击</button>\n    </div>\n  );\n}\nlet stateArray = [];\nlet cursor = 0;\nfunction useState(initialState) {\n  const currentCursor = cursor;\n  stateArray[currentCursor] = stateArray[currentCursor] || initialState;\n  function setState(newState) {\n    stateArray[currentCursor] = newState;\n    render();\n  }\n  ++cursor;\n  return [stateArray[currentCursor], setState];\n}\nexport function render() {\n  ReactDOM.render(\n    <React.StrictMode>\n      <Counter />\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n  );\n  cursor = 0;\n}\nrender();\n真实的 react useState 比这个复杂的多mini版每次都要重新生成RootFiber，并且要重置状态’指针‘mini版把状态存在了全局作用域，react 真实的实现是挂在 fiber 节点上的 memoizedState,mini版本的状态指针“cursor”是个数组的索引，而真实的是通过链表实现的，mini 版的实现只能当做一种启发","进阶版实现#进阶版实现":"尽可能的模拟内部实现\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nlet workInProgressHook;//当前工作中的hook\nlet isMount = true;//是否时mount时\nconst fiber = {//fiber节点\n  memoizedState: null,//hook链表\n  stateNode: App//dom\n};\nconst Dispatcher = (() => {//Dispatcher对象\n  function mountWorkInProgressHook() {//mount时调用\n    const hook = {//构建hook\n      queue: {//更新队列\n        pending: null//未执行的update队列\n      },\n      memoizedState: null,//当前state\n      next: null//下一个hook\n    };\n    if (!fiber.memoizedState) {\n      fiber.memoizedState = hook;//第一个hook的话直接赋值给fiber.memoizedState\n    } else {\n      workInProgressHook.next = hook;//不是第一个的话就加在上一个hook的后面，形成链表\n    }\n    workInProgressHook = hook;//记录当前工作的hook\n    return workInProgressHook;\n  }\n  function updateWorkInProgressHook() {//update时调用\n    let curHook = workInProgressHook;\n    workInProgressHook = workInProgressHook.next;//下一个hook\n    return curHook;\n  }\n  function useState(initialState) {\n    let hook;\n    if (isMount) {\n      hook = mountWorkInProgressHook();\n      hook.memoizedState = initialState;//初始状态\n    } else {\n      hook = updateWorkInProgressHook();\n    }\n    let baseState = hook.memoizedState;//初始状态\n    if (hook.queue.pending) {\n      let firstUpdate = hook.queue.pending.next;//第一个update\n      do {\n        const action = firstUpdate.action;\n        baseState = action(baseState);\n        firstUpdate = firstUpdate.next;//循环update链表\n      } while (firstUpdate !== hook.queue.pending);//通过update的action计算state\n      hook.queue.pending = null;//重置update链表\n    }\n    hook.memoizedState = baseState;//赋值新的state\n    return [baseState, dispatchAction.bind(null, hook.queue)];//useState的返回\n  }\n  return {\n    useState\n  };\n})();\nfunction dispatchAction(queue, action) {//触发更新\n  const update = {//构建update\n    action,\n    next: null\n  };\n  if (queue.pending === null) {\n    update.next = update;//update的环状链表\n  } else {\n    update.next = queue.pending.next;//新的update的next指向前一个update\n    queue.pending.next = update;//前一个update的next指向新的update\n  }\n  queue.pending = update;//更新queue.pending\n  isMount = false;//标志mount结束\n  workInProgressHook = fiber.memoizedState;//更新workInProgressHook\n  schedule();//调度更新\n}\nfunction App() {\n  let [count, setCount] = Dispatcher.useState(1);\n  let [age, setAge] = Dispatcher.useState(10);\n  return (\n    <>\n      <p>Clicked {count} times</p>\n      <button onClick={() => setCount(() => count + 1)}> Add count</button>\n      <p>Age is {age}</p>\n      <button onClick={() => setAge(() => age + 1)}> Add age</button>\n    </>\n  );\n}\nfunction schedule() {\n  ReactDOM.render(<App />, document.querySelector(\"#root\"));\n}\nschedule();"}},"/posts/ts/base":{"title":"TypeScript基础","data":{"":"图：Nguyen Nhut","ts#TS":"TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。 -- 官方文档\nTypeScript\tJavaScript\tJavaScript 的超集，用于解决大型项目的代码复杂性\t一种脚本语言，用于创建动态网页。\t强类型，支持静态和动态类型\t动态弱类型语言\t可以在编译期间发现并纠正错误\t只能在运行时发现错误\t不允许改变变量的数据类型\t变量可以被赋予不同类型的值","ts-的好处#TS 的好处":"1、超集，是 js 的加强版，只多不少\n2、面向对象\n3、静态检查\n4、可读性强","类型#类型":"12 种基本类型\nnumber;\nstring;\nboolean;\narray;\nobject;\nbigint;\nsymbol;\nnull;\nundefined;\nDate;\nError;\nRegExp;","undefined-和-null#undefined 和 null":"默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。\nlet age: number = null;\nlet realName: string = undefined;","anyunknown-和-void-类型#any、unknown 和 void 类型":"void 类型与 any 类型相反，它表示没有任何类型。\nfunction welcome(): void {\n  console.log(\"hello\");\n}","never-类型#never 类型":"never 类型表示的是那些永不存在的值的类型。\nconst A: never = 1; // error","元组类型#元组类型":"元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。\nlet tuple: [number, string] = [18, \"lin\"];\n可以对元组使用数组的方法，比如使用 push 时，不会有越界报错push 一个没有定义的类型，报错","可选参数#可选参数":"参数后加个问号，代表这个参数是可选的\nfunction add(x: number, y: number, z?: number): number {\n  return x + y;\n}\nadd(1, 2, 3);\nadd(1, 2);","enum-枚举#enum: 枚举":"字符串枚举的意义在于，提供有具体语义的字符串，可以更容易地理解代码和调试。\nenum HttpMethod {\n  GET,\n  POST,\n  PATCH,\n  PUT,\n  DELETE,\n}\ntype K = keyof typeof HttpMethod; // 'GET'|'POST'|'PATCH'|'PUT'|'DELETE'","字符串枚举#字符串枚举":"enum Direction {\n    Up = \"UP\",\n    Down = \"DOWN\",\n    Left = \"LEFT\",\n    Right = \"RIGHT\",\n}\nconst value = 'UP'\nif (value === Direction.Up) {\n    // do something\n}","常量枚举#常量枚举":"上文的例子，使用 const 来定义一个常量枚举\nconst enum Direction {\n    Up = \"UP\",\n    Down = \"DOWN\",\n    Left = \"LEFT\",\n    Right = \"RIGHT\",\n}\nconst value = 'UP'\nif (value === Direction.Up) {\n    // do something\n}","type#type":"类型别名\n类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 -- TS 文档","interface#interface":"interface(接口) 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。\ninterface Person {\n    name: string\n    age: number\n}\nconst p1: Person = {\n    name: 'lin',\n    age: 18\n}","type-和-interface-的区别#type 和 interface 的区别":"1、type 是用于声明类型的，interface 用于描述数据结构2、type 和 interface 都可以被相互继承和拓展3、type 可以声明基本类型的别名，联合类型和元组，interface 不行4、interface 可以合并重复声明","联合类型-#联合类型 |":"联合类型一次只能一种类型；而交叉类型每次都是多个类型的合并类型。1.基础类型联合\nlet a: string | number;\na = 1; //ok\na = \"a\"; //ok\n2、对象类型联合对象联合类型只能访问联合中所有共同成员\ninterface Women {\n  age: number;\n  sex: string;\n  cry(): void;\n}\ninterface Man {\n  age: number;\n  sex: string;\n}\ndeclare function People(): Women | Man;\nlet people = People();\npeople.age = 18; //ok\npeople.cry(); //error 非共同成员","交叉类型-#交叉类型 &":"联合类型一次只能一种类型；而交叉类型每次都是多个类型的合并类型。\n多种类型的集合，联合对象将具有所联合类型的所有成员\ninterface Women {\n  age: number;\n  sex: string;\n  cry(): void;\n}\ninterface Man {\n  age: number;\n  sex: string;\n}\ndeclare function People(): Women | Man;\nlet people = People();\npeople.age = 18; //ok\npeople.cry(); //ok 共同成员","typeof#typeof":"typeof 操作符可以用来获取一个变量声明或对象的类型。\nfunction toArray(x: number): Array<number> {\n  return [x];\n}\ntype Func = typeof toArray; // -> (x: number) => number[]","keyof#keyof":"keyof 操作符可以用来表示一个对象中的所有 key 值：\ninterface Person {\n  name: string;\n  age: number;\n}\ntype K1 = keyof Person; // \"name\" | \"age\"\ntype K1 = keyof boolean; // \"valueOf\"\ntype K2 = keyof any; // string | number | symbol","in#in":"in 用来遍历枚举类型：\ntype Keys = \"a\" | \"b\" | \"c\";\ntype Obj = {\n  [p in Keys]: any;\n}; // -> { a: any, b: any, c: any }","extends#extends":"有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。1、约束\nfunction getCnames<T extends { name: string }>(entities: T[]): string[] {\n  return entities.map((entity) => entity.cname);\n}\n2、继承\ninterface ILengthwise {\n  length: number;\n}\nfunction loggingIdentity<T extends ILengthwise>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\nloggingIdentity(3);\nloggingIdentity({ length: 10, value: 3 });","partial#partial":"Partial<T> 的作用就是将某个类型里的属性全部变为可选项 ?。\n// Partial\ninterface People {\n  name: string;\n  age: number;\n}\n// 报错 类型“{}”缺少类型“People”中的以下属性: name, age\nconst person1: People = {};\n/**\n  那这个时候我们就可以用到typescript自带的高级类型 Partial，就相当于将上方接口所有属性变成可选的\n  将我们需要定义的类型当做泛型传入Partial中，那么就相当于当前的类型里面的所有属性都是可选的\n */\nconst person2: Partial<People> = {}; // 可以\nconst person3: Partial<People> = { name: \"xiaodu\" }; // 可以\nconst person4: Partial<People> = { sex: \"男\" }; // 报错 “sex”不在类型“Partial<People>”中","reuqired#Reuqired":"Required<T> 的作用就是将某个类型里的属性全部变为必选项。\n// 必选参数\ninterface People {\n  name?: string;\n  age?: number;\n}\n// 类型 \"{ name: string; }\" 中缺少属性 \"age\"，但类型 \"Required<People>\" 中需要该属性\nconst person2: Required<People> = {\n  name: \"11\",\n};","readonly#Readonly":"Readonly<T> 的作用是将某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值。\n// 只读\ninterface People {\n  name: string;\n  age: number;\n  dog: {\n    name: string;\n    age: number;\n  };\n}\nconst xiaoling: Readonly<People> = {\n  name: \"小凌\", // 只读\n  age: 18, // 只读\n  dog: {\n    age: 1,\n    name: \"大黄\",\n  },\n};\n// 但是是浅层的。\nxiaoling.name = \"john\"; // 无法分配到 \"name\" ，因为它是只读属性。\nxiaoling.dog.age = 2; // 可以","record#Record":"Record<K extends keyof any, T> 的作用是将 K 中所有的属性的值转化为 T 类型。\ninterface PageInfo {\n  title: string;\n}\ntype Page = \"home\" | \"about\" | \"contact\";\nconst x: Record<Page, PageInfo> = {\n  about: { title: \"about\" },\n  contact: { title: \"contact\" },\n  home: { title: \"home\" },\n};","exclude#Exclude":"Exclude<T, U> 的作用是将某个类型中属于另一个的类型移除掉。取差集\ntype T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">; // \"b\" | \"c\"\ntype T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">; // \"c\"","omit#omit":"Omit<T, U>从类型 T 中剔除 U 中的所有属性\n省略 interface\ninterface IPerson {\n    name: string\n    age: number\n}\ntype IOmit = Omit<IPerson, 'age'>\n/**\n type somePeople = {\n    name: string;\n}\n */","extract#Extract":"Extract<T, U> 的作用是从 T 中提取出 U。取交集\ntype T0 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">; // \"a\"\ntype T1 = Extract<string | number | (() => void), Function>; // () => void","pick#Pick":"选择、摘取 interface\ntype Coord = Record<\"x\" | \"y\", number>;\ntype CoordX = Pick<Coord, \"x\">;\n// 等用于\ntype CoordX = {\n  x: number;\n};","泛型#泛型":"软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件\n泛型约束类定义一个栈，有入栈和出栈两个方法，如果想入栈和出栈的元素类型统一，就可以这么写：\nclass Stack<T> {\n    private data: T[] = []\n    push(item:T) {\n        return this.data.push(item)\n    }\n    pop():T | undefined {\n        return this.data.pop()\n    }\n}","parameters#Parameters":"提取函数的参数类型\ntype T1 = Parameters<() => string>; // []\ntype T2 = Parameters<(arg: string) => void>; // [string]\ntype T3 = Parameters<(arg1: string, arg2: number) => void>; // [arg1: string, arg2: number]","returntype#ReturnType":"提取函数的返回值类型\ntype T0 = ReturnType<() => string>; // string\ntype T1 = ReturnType<(s: string) => void>; // void","索引签名#索引签名":"interface PropChangeHandler {\n  [key: `${string}Changed`]: () => void;\n}\nlet handlers: PropChangeHandler = {\n  idChanged: () => {}, //ok\n  nameChanged: () => {}, //ok\n  ageChange: () => {}, //error\n};\n索引签名参数类型不能为字面量类型或泛型类型\n考虑使用映射的对象类型\ntype User1 = {\n  [key: \"id\"]: string; //error\n};\ntype User2 = {\n  [key: \"id\" | \"name\"]: string; //error\n};\ntype User3 = Record<\"id\", string>;\ntype User4 = Record<\"id\" | \"name\", string>;","const-断言#const 断言":"let requestMethod = 'Get';\nlet requestMethod2 = 'Get' as const;\ntype R0 = typeof requestMethod; //string\ntype R1 = typeof requestMethod2; // 'Get'"}},"/posts/ts/utils":{"title":"TypeScript里常用的工具类型","data":{"":"图：Amrit Pal Singh","使属性变为可选#使属性变为可选":"type PartialByKeys<T, K extends keyof T> = {\n  [P in K]?: T[P];\n} & Pick<T, Exclude<keyof T, K>>;","使属性变为必填#使属性变为必填":"type RequiredByKeys<T, K extends keyof T> = {\n  [P in K]-?: T[P];\n} & Omit<T, K>;","判断类型是否是另一个类型的子类型#判断类型是否是另一个类型的子类型":"type SubtypeOf<T, U> = T extends U ? true : false;","提取-interface-中非函数类型的名#提取 interface 中非函数类型的名":"type NonFunctionPropertyNames<T> = {\n  [K in keyof T]:T[K] extends Function ? never : K;\n}[keyof T];","提取-interface-中非函数类型的属性#提取 interface 中非函数类型的属性":"type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;"}},"/posts/engin/webpack-splitchunks":{"title":"Webpack Splitchunks 详解","data":{"":"图：Peter Tarka","使用目的#使用目的":"用 SplitChunks 插件来控制 Webpack 打包生成的 js 文件的内容的精髓就在于，防止模块被重复打包，拆分过大的 js 文件，合并零散的 js 文件。最终的目的就是减少请求资源的大小和请求次数。","splitchunks-插件配置选项#SplitChunks 插件配置选项":"","chunks#chunks":"选项，决定要提取那些模块。默认是 async：只提取异步加载的模块出来打包到一个文件中。\n异步加载的模块：通过 import('xxx')或 require(['xxx'],() =>)加载的模块。initial：提取同步加载和异步加载模块，如果 xxx 在项目中异步加载了，也同步加载了，那么 xxx 这个模块会被提取两次，分别打包到不同的文件中。\n同步加载的模块：通过 import xxx 或 require('xxx')加载的模块。all：不管异步加载还是同步加载的模块都提取出来，打包到一个文件中。如果设为\"initial\"，那么该缓存组只会分离应用初始加载需要的包。有时这是有必要的，因为设为一味设为\"all\"的话，打包出来的 js 都会在应用初始载入时加载，即使里面包含一些首页用不到的模块。","minsize#minSize":"规定被提取的模块在压缩前的大小最小值，单位为字节，默认为 30000，只有超过了 30000 字节才会被提取。","maxsize#maxSize":"把提取出来的模块打包生成的文件大小不能超过 maxSize 值，如果超过了，要对其进行分割并打包生成新的文件。单位为字节，默认为 0，表示不限制大小。","minchunks#minChunks":"表示要被提取的模块最小被引用次数，引用次数超过或等于 minChunks 值，才能被提取。","maxasyncrequests#maxAsyncRequests":"最大的按需(异步)加载次数，默认为 6。","maxinitialrequests#maxInitialRequests":"打包后的入口文件加载时，还能同时加载 js 文件的数量（包括入口文件），默认为 4。先说一下优先级 maxInitialRequests / maxAsyncRequests < maxSize < minSize。","automaticnamedelimiter#automaticNameDelimiter":"打包生成的 js 文件名的分割符，默认为~。","name#name":"打包生成 js 文件的名称。","cachegroups#cacheGroups":"核心重点，配置提取模块的方案。里面每一项代表一个提取模块的方案。下面是 cacheGroups 每项中特有的选项，其余选项和外面一致，若 cacheGroups 每项中有，就按配置的，没有就使用外面配置的。test 选项：用来匹配要提取的模块的资源路径或名称。值是正则或函数。priority 选项：方案的优先级，值越大表示提取模块时优先采用此方案。默认值为 0。reuseExistingChunk 选项：true/false。为 true 时，如果当前要提取的模块，在已经在打包生成的 js 文件中存在，则将重用该模块，而不是把当前要提取的模块打包生成新的 js 文件。enforce 选项：true/false。为 true 时，忽略 minSize，minChunks，maxAsyncRequests 和 maxInitialRequests 外面选项","示例#示例":"const config = {\n  //...\n  optimization: {\n    runtimeChunk: 'single',\n    minimizer: [new OptimizeCSSAssetsPlugin({})],\n    splitChunks: { \n      chunks: 'all',  //处理的 chunk 类型\n      minSize: 20000, // 允许新拆出 chunk 的最小体积\n      minRemainingSize: 0, //最小剩余尺寸\n      minChunks: 1,  //拆分前被 chunk 公用的最小次数\n      maxAsyncRequests: 30, //每个异步加载模块最多能被拆分的数量\n      maxInitialRequests: 30, //每个入口和它的同步依赖最多能被拆分的数量\n      enforceSizeThreshold: 50000, //强制执行拆分的体积阈值并忽略其他限制\n      cacheGroups: {\n        react: {\n          // name: \"react\",\n          filename: 'react.js',\n          chunks: 'all',\n          test: /[\\\\/]node_modules[\\\\/](react)[\\\\/]/,\n          priority: -1,\n          reuseExistingChunk: true, // 复用已被拆出的依赖模块，而不是继续包含在该组一起生成\n        },\n        'react-dom': {\n          // name: \"react-dom\",\n          filename: 'react-dom.js',\n          chunks: 'all',\n          test: /[\\\\/]node_modules[\\\\/](react-dom)[\\\\/]/,\n          priority: -1,\n          reuseExistingChunk: true,\n        },\n      },\n    },\n  },\n}"}},"/posts/js/module":{"title":"各种JS模块化特性","data":{"":"图：Nguyen Nhut\nAsynchronous module definitionAMD 的代表肯定就是大名鼎鼎的 RequireJSJames Burke 觉得 CMJ 很好，但是在浏览器里玩不转，所以自己提出了一个 AMD 规范","amd-usage#AMD Usage":"define(id?, depencies?, factory);\ndefine('foo', ['utils', 'bar'], function(utils, bar) {\n  utils.add(1, 2);\n  return {\n    name: 'foo'\n  }\n})","实现一个符合-amd-的-rjjs#实现一个符合 AMD 的 rj.js":"只是核心能力作为实现，具体：https://requirejs.org/docs/api.html1.可以直接配置依赖路径\nrj.config({ paths: {\n  'jquery': 'https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js'\n} });\nrj(['jquery'], function(jquery) {\n  // ....\n})\n2.加载模块\n// RequestJs('')\nrj(['moduleA'], function(moduleA) {});\n3.定义模块\nrj('moduleA', [], function() {\n  return 'hello zhuawa!';\n})","行为#行为":"// RequireJS\ndefine('a', function () {\n  console.log('a load')\n  return {\n    run: function () { console.log('a run') }\n  }\n})\ndefine('b', function () {\n  console.log('b load')\n  return {\n    run: function () { console.log('b run') }\n  }\n})\nrequire(['a', 'b'], function (a, b) {\n  console.log('main run') // 🔥\n  a.run()\n  b.run()\n})\n// a load\n// b load\n// main run\n// a run\n// b run\n记录一下：\n1.require 的时候加载了依赖的模块一些可以用来测试的 CDN 地址systemjs： https://cdn.bootcdn.net/ajax/libs/systemjs/6.8.3/system.min.jslodash： https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.min.jsCommon Module Definition玉伯 Seajs","usage#Usage":"// sea.js\ndefine('a', function (require, exports, module) {\n  console.log('a load')\n  exports.run = function () { console.log('a run') }\n})\ndefine('b', function (require, exports, module) {\n  console.log('b load')\n  exports.run = function () { console.log('b run') }\n})\ndefine('main', function (require, exports, module) {\n  console.log('main run')\n  var a = require('a')\n  a.run()\n  var b = require('b')\n  b.run()\n})\nseajs.use('main')\n// main run\n// a load\n// a run\n// b load\n// b run\n文件是一个模块，私有。内置两个变量 module require (exports = module.exports)一个引入一个导出，就构成了通信的基本结构","需要注意的两个问题#需要注意的两个问题":"1.缓存，require 会缓存一下，所以\n// a.js\nvar name = 'morrain'\nvar age = 18\nexports.name = name\nexports.getAge = function(){\n    return age\n}\n// b.js\nvar a = require('a.js')\nconsole.log(a.name) // 'morrain'\na.name = 'rename'\nvar b = require('a.js')\nconsole.log(b.name) // 'rename'\n2.引用拷贝还是值拷贝的问题(CMJ 是值拷贝)\n// a.js\nvar name = 'morrain'\nvar age = 18\nexports.name = name\nexports.age = age\nexports.setAge = function(a){\n    age = a\n}\n// b.js\nvar a = require('a.js')\nconsole.log(a.age) // 18\na.setAge(19)\nconsole.log(a.age) // 18\n3.运行时加载我们所说的esModule其实就是es6推出的javascript模块规范。在这之前由于没有规范所以社区推出了CommonJS规范、require.js等。esModule的语法是静态的、导出是绑定的什么是静态？\n静态的语法意味着可以在编译时确定导入和导出，更加快速的查找依赖，可以使用lint工具对模块依赖进行检查，可以对导入导出加上类型信息进行静态的类型检查什么是导出绑定？\n由于使用import导入的模块是运行在严格模式下的，且均为只读的(即无法被赋值。但是可以更改属性),且均为引用传递，无关类型，均是与原变量的引用。编译时加载（多阶段，异步）导出 export\n// ep.js\n// 最常用的大概就是声明命名导出了\nexport const name = 'bababa' // var let const function class 均可\n// 默认导出\nexport default constant\nexport default function() {}\nexport { constant as default } // 重命名默认导出\n// 命名导出\nexport { ep1, ep2, ep3 }\nexport { ep1 as _ep1, ep2 as _ep2, ep3 as _ep3 } // 重命名导出\n// 重定向导出\nexport * from 'action' // 重定向导出(导出不包含模块内的default的所有)，重定向的命名并不能在本模块使用，只是搭建一个桥梁。\n// 下面是几个错误范例\nexport 1\nconst $ep = 1\nexport $ep\n导入 import\n// 命名导入\nimport { ep1, ep2, ep3 } from './ep'\n// 重命名导入\nimport { ep1 as _ep1, ep2 as _ep2, ep3 as _ep3 } from './ep'\n// 混合导入\nimport * as ep from './ep'\nimport default,  { ep1, ep2, ep3 as $ep3 } from './ep'\n// effect 执行  多次引入也只会执行一次，有点像php里的include_once\nimport './ep'\n// 动态导入\nimport('./ep').then()\n// 下面是几个错误范例\nimport { 'ep1' + 'ep2' } from './ep' // import是编译阶段，所以不能动态加载"}},"/posts/react/concept":{"title":"react架构","data":{"":"图：Mako Tsereteli","总体#总体":"react 的核心可以用 ui=fn(state)来表示\nconst state = reconcile(update);\nconst UI = commit(state);\n3 大核心对象、3 大核心阶段、2 大工作循环\nScheduler（调度器）： 排序优先级，让优先级高的任务先进行 reconcile\nReconciler（协调器）： 找出哪些节点发生了改变，并打上不同的 Flags（旧版本 react 叫 Tag）\nRenderer（渲染器）： 将 Reconciler 中打好标签的节点渲染到视图上","scheduler调度器#Scheduler（调度器)":"我们知道了要实现异步可中断的更新，需要浏览器指定一个时间，如果没有时间剩余了就需要暂停任务，requestIdleCallback 貌似是个不错的选择，但是它存在兼容和触发不稳定的原因，react17 中采用 MessageChannel 来实现。在 Scheduler 中的每的每个任务的优先级使用过期时间表示的，如果一个任务的过期时间离现在很近，\n说明它马上就要过期了，优先级很高，如果过期时间很长，那它的优先级就低，没有过期的任务存放在 timerQueue 中，\n过期的任务存放在 taskQueue 中，timerQueue 和 timerQueue 都是小顶堆，\n所以 peek 取出来的都是离现在时间最近也就是优先级最高的那个任务，然后优先执行它。","优先级#优先级":"var expirationTime = startTime + timeout;","lane-模型#Lane 模型":"react 之前的版本用 expirationTime 属性代表优先级，该优先级和 IO 不能很好的搭配工作（io 的优先级高于 cpu 的优先级），现在有了更加细粒度的优先级表示方法 Lane，Lane 用二进制位表示优先级，二进制中的 1 表示位置，同一个二进制数可以有多个相同优先级的位，这就可以表示‘批’的概念，而且二进制方便计算。这好比赛车比赛，在比赛开始的时候会分配一个赛道，比赛开始之后大家都会抢内圈的赛道（react 中就是抢优先级高的 Lane），比赛的尾声，最后一名赛车如果落后了很多，它也会跑到内圈的赛道，最后到达目的地（对应 react 中就是饥饿问题，低优先级的任务如果被高优先级的任务一直打断，到了它的过期时间，它也会变成高优先级）Lane 的二进制位如下，1 的 bits 越多，优先级越低\n//ReactFiberLane.js\nexport const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;\nexport const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;\nexport const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;\nexport const SyncBatchedLane: Lane = /*                 */ 0b0000000000000000000000000000010;\nexport const InputDiscreteHydrationLane: Lane = /*      */ 0b0000000000000000000000000000100;\nconst InputDiscreteLanes: Lanes = /*                    */ 0b0000000000000000000000000011000;\nconst InputContinuousHydrationLane: Lane = /*           */ 0b0000000000000000000000000100000;\nconst InputContinuousLanes: Lanes = /*                  */ 0b0000000000000000000000011000000;\nexport const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000100000000;\nexport const DefaultLanes: Lanes = /*                   */ 0b0000000000000000000111000000000;\nconst TransitionHydrationLane: Lane = /*                */ 0b0000000000000000001000000000000;\nconst TransitionLanes: Lanes = /*                       */ 0b0000000001111111110000000000000;\nconst RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000;\nexport const SomeRetryLane: Lanes = /*                  */ 0b0000010000000000000000000000000;\nexport const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000;\nconst NonIdleLanes = /*                                 */ 0b0000111111111111111111111111111;\nexport const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000;\nconst IdleLanes: Lanes = /*                             */ 0b0110000000000000000000000000000;\nexport const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;","reconciler协调器#Reconciler（协调器）":"","fiber-双缓存#Fiber 双缓存":"Fiber 对象上面保存了包括这个节点的属性、类型、dom 等，Fiber 通过 child、sibling、return（指向父节点）来形成 Fiber 树双缓存是指存在两颗 Fiber 树，current Fiber 树描述了当前呈现的 dom 树，workInProgress Fiber 是正在更新的 Fiber 树，这两颗 Fiber 树都是在内存中运行的，在 workInProgress Fiber 构建完成之后会将它作为 current Fiber 应用到 dom 上Fiber 本质是环形链表结构，因为虚拟 dom 的结构还是树，所以一般称为 Fiber 树，遍历方式是深度优先遍历，child->sibling->return,\nchild 和 sibling 都执行 beginWork, return 都执行 completeWork,遍历到每个节点，都会计算 state, 对比节点差异，为节点赋值相应的 effectFlags。‘捕获’阶段发生在 beginWork 函数中，该函数做的主要工作是\n创建 Fiber 节点，\n计算 state\ndiff 算法\n‘冒泡’阶段发生在 completeWork 中，\n该函数主要是做一些收尾工作，例如\n处理节点的 props\n形成一条 effectList 的链表\n该链表是被标记了更新的节点形成的链表,commit 阶段其实是拿这个 fiberEffectList 做更新Reconciler 会创建或者更新 Fiber 节点。在 mount 的时候会根据 jsx 生成 Fiber 对象，\n在 update 的时候会根据最新的 state 形成的 jsx 对象和 current Fiber 树对比构建 workInProgress Fiber 树，\n这个对比的过程就是 diff 算法。在 mount 时（首次渲染），会根据 jsx 对象（Class Component 或的 render 函数者 Function Component 的返回值），构建 Fiber 对象，形成 Fiber 树，\n然后这颗 Fiber 树会作为 current Fiber 应用到真实 dom 上，在 update（状态更新时如 setState）的时候，会根据状态变更后的 jsx 对象和 current Fiber 做对比形成新的 workInProgress Fiber，\n然后 workInProgress Fiber 切换成 current Fiber 应用到真实 dom 就达到了更新的目的，而这一切都是在内存中发生的，从而减少了对 dom 好性能的操作。","diff-算法#diff 算法":"diff 算法发生在 render 阶段的 reconcileChildFibers 函数中，diff 算法分为单节点的 diff 和多节点的 diff（例如一个节点中包含多个子节点就属于多节点的 diff），单节点会根据节点的 key 和 type，props 等来判断节点是复用还是直接新创建节点，多节点 diff 会涉及节点的增删和节点位置的变化reconcile 时会在这些 Fiber 上打上 Flags 标签，在 commit 阶段把这些标签应用到真实 dom 上，这些标签代表节点的增删改，如\n//ReactFiberFlags.js\nexport const Placement = /*             */ 0b0000000000010;\nexport const Update = /*                */ 0b0000000000100;\nexport const PlacementAndUpdate = /*    */ 0b0000000000110;\nexport const Deletion = /*              */ 0b0000000001000;","updatequeue#updateQueue":"Fiber 还保存了更新状态时用于计算 state 的 updateQueue，updateQueue 是一种链表结构，上面可能存在多个未计算的 update，update 也是一种数据结构，上面包含了更新的数据、优先级等，除了这些之外，上面还有和副作用有关的信息。","effectlist#effectList":"effectList 生成方式示例如下：\nfunction App() {\n  const [count, setCount] = useState(0);\n  return (\n    <>\n      <h1\n        onClick={() => {\n          setCount(() => count + 1);\n        }}\n      >\n        <p title={count}>{count}</p> John\n      </h1>\n    </>\n  );\n}\n当点击 h1 时，会生成红色线条的 effectList","renderer渲染器#Renderer（渲染器）":"Renderer 发生在 commit 阶段，commit 阶段遍历 effectList 执行对应的 dom 操作或部分生命周期。Renderer 是在 commit 阶段工作的，commit 阶段会遍历 render(reconciler)阶段形成的 effectList，并执行真实 dom 节点的操作和一些生命周期，不同平台对应的 Renderer 不同，例如浏览器对应的就是 react-dom。commit 阶段发生在 commitRoot 函数中，该函数主要遍历 effectList，分别用三个函数来处理 effectList 上的节点，这三个函数是 commitBeforeMutationEffects、commitMutationEffects、commitLayoutEffects","concurrent#concurrent":"它是一类功能的合集（如 fiber、schduler、lane、suspense），其目的是为了提高应用的响应速度，使应用 cpu 密集型的更新不在那么卡顿，其核心是实现了一套异步可中断、带优先级的更新。我们知道一般浏览器的 fps 是 60Hz，也就是每 16.6ms 会刷新一次，而 js 执行线程和 GUI 也就是浏览器的绘制是互斥的，因为 js 可以操作 dom，影响最后呈现的结果，所以如果 js 执行的时间过长，会导致浏览器没时间绘制 dom，造成卡顿。react17 会在每一帧分配一个时间（时间片）给 js 执行，如果在这个时间内 js 还没执行完，那就要暂停它的执行，等下一帧继续执行，把执行权交回给浏览器去绘制。","最后#最后":"以上就是 react 的核心架构解析，详细的每个块的分析可以查阅其他文章 😬"}},"/posts/react/react-redux-context":{"title":"React Redux 实现 （Context 版）","data":{"":"图：nework","redux-store#redux store":"export const createStore = (reducer: Function, initialState: any) => {\n  let state = initialState;\n  let listeners: Function[] = [];\n  const getState = () => {\n    return state;\n  };\n  const subscribe = (listener: Function) => {\n    listeners.push(listener);\n    return () => {\n      listeners = listeners.filter((l) => l !== listener);\n    };\n  };\n  const dispatch = (action: { type: string; payload: any }) => {\n    state = reducer(state, action);\n    listeners.forEach((l) => l());\n  };\n  return { dispatch, getState, subscribe };\n};\nexport default { createStore };\nimport { storeContext } from \"./context\";\nexport const Provider = (props: any) => {\n  const { store, children } = props;\n  const ProviderComponent = storeContext.Provider;\n  return <ProviderComponent value={store}>{children}</ProviderComponent>;\n};\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport { storeContext } from \"./context\";\nexport const ConnectComponent = (props: any) => {\n  const {\n    WrapperComponent,\n    mapStateToProps,\n    mapDispatchToProps,\n    ...restProps\n  } = props;\n  const [, forceUpdate] = useState<any>();\n  const { dispatch, getState, subscribe } = useContext(storeContext);\n  const state = getState();\n  const mapState = useMemo(() => {\n    if (!mapStateToProps) {\n      return state;\n    }\n    return mapStateToProps(state);\n  }, [state]);\n  const mapAction = useMemo(() => {\n    if (!mapDispatchToProps) {\n      return {};\n    }\n    return mapDispatchToProps(dispatch);\n  }, [dispatch]);\n  const memoComponent = useMemo(() => {\n    return (\n      <WrapperComponent\n        {...mapState}\n        {...mapAction}\n        {...restProps}\n        dispatch={dispatch}\n      />\n    );\n  }, [mapState, mapAction]);\n  const unsubscribe = subscribe(() => {\n    forceUpdate({});\n  });\n  return memoComponent;\n};\nexport const connect = (mapStateToProps?: any, mapDispatchToProps?: any) => {\n  return (WrapperComponent: React.ElementType) => (props: any) => (\n    <ConnectComponent\n      {...props}\n      mapStateToProps={mapStateToProps}\n      WrapperComponent={WrapperComponent}\n      mapDispatchToProps={mapDispatchToProps}\n    />\n  );\n};","-遇事不决加一层#😅 遇事不决加一层":""}},"/tags/[tag]":{"title":"Posts Tagged with “”","data":{}}}